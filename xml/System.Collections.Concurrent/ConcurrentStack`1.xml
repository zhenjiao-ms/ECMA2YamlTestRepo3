<Type Name="ConcurrentStack&lt;T&gt;" FullName="System.Collections.Concurrent.ConcurrentStack&lt;T&gt;">
  <TypeSignature Language="C#" Value="public class ConcurrentStack&lt;T&gt; : System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit ConcurrentStack`1&lt;T&gt; extends System.Object implements class System.Collections.Concurrent.IProducerConsumerCollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Concurrent.SystemCollectionsConcurrent_ProducerConsumerCollectionDebugView`1))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">To be added.</typeparam>
    <summary>Represents a thread-safe last in-first out (LIFO) collection.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  ConcurrentStack(T) implements the <xref:System.Collections.Generic.IReadOnlyCollection%601> interface starting with the [!INCLUDE[net_v46](~/add/includes/net-v46-md.md)]; in previous versions of the .NET Framework, the ConcurrentStack(T) class did not implement this interface.  
  
 ConcurrentStack(T) provides a few main operations:  
  
-   <xref:System.Collections.Concurrent.ConcurrentStack%601.Push%2A> inserts an element at the top of the ConcurrentStack(T).  
  
-   <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPop%2A> removes an element from the top of the ConcurrentStack(T), or returns `false` if the item cannot be removed.  
  
-   <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPeek%2A> returns an element that is at the top of the ConcurrentStack(T) but does not remove it from the ConcurrentStack(T).  
  
-   The <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPopRange%2A> and <xref:System.Collections.Concurrent.ConcurrentStack%601.PushRange%2A> methods provide efficient pushing and popping of multiple elements in a single operation.  
  
   
  
## Examples  
 The following example shows how to use a ConcurrentStack(T) to push and pop individual items:  
  
 [!code-vb[System.Collections.Concurrent.ConcurrentStack#2](~/add/codesnippet/visualbasic/t-system.collections.con_4_1.vb)]
 [!code-cs[System.Collections.Concurrent.ConcurrentStack#2](~/add/codesnippet/csharp/t-system.collections.con_4_1.cs)]  
  
 The following example shows how to use a ConcurrentStack(T) to push and pop ranges of items:  
  
 [!code-vb[System.Collections.Concurrent.ConcurrentStack#1](~/add/codesnippet/visualbasic/t-system.collections.con_4_2.vb)]
 [!code-cs[System.Collections.Concurrent.ConcurrentStack#1](~/add/codesnippet/csharp/t-system.collections.con_4_2.cs)]  
  
 ]]></format>
    </remarks>
    <threadsafe>All public and protected members of ConcurrentStack(T) are thread-safe and may be used concurrently from multiple threads.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConcurrentStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="System.Collections.Concurrent.ConcurrentStack%601" /> class.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConcurrentStack (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">The collection whose elements are copied to the new <see cref="System.Collections.Concurrent.ConcurrentStack%601" />.</param>
        <summary>Initializes a new instance of the <see cref="System.Collections.Concurrent.ConcurrentStack%601" /> class that contains elements copied from the specified collection</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="collection" /> argument is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Removes all objects from the <see cref="System.Collections.Concurrent.ConcurrentStack%601" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 index) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from the <see cref="System.Collections.Concurrent.ConcurrentStack%601" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
        <param name="index">The zero-based index in `array` at which copying begins.</param>
        <summary>Copies the <see cref="System.Collections.Concurrent.ConcurrentStack%601" /> elements to an existing one-dimensional <see cref="T:System.Array" />, starting at the specified array index.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is a null reference (Nothing in Visual Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> is equal to or greater than the length of the <paramref name="array" /> -or- The number of elements in the source <see cref="System.Collections.Concurrent.ConcurrentStack%601" /> is greater than the available space from <paramref name="index" /> to the end of the destination <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of elements contained in the <see cref="System.Collections.Concurrent.ConcurrentStack%601" />.</summary>
        <value>The number of elements contained in the <see cref="System.Collections.Concurrent.ConcurrentStack%601" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 For determining whether the collection contains any items, use of the <xref:System.Collections.Concurrent.ConcurrentStack%601.IsEmpty%2A> property is recommended rather than retrieving the number of items from the Count property and comparing it to 0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerator&lt;T&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an enumerator that iterates through the <see cref="System.Collections.Concurrent.ConcurrentStack%601" />.</summary>
        <returns>An enumerator for the <see cref="System.Collections.Concurrent.ConcurrentStack%601" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The enumeration represents a moment-in-time snapshot of the contents of the stack. It does not reflect any updates to the collection after GetEnumerator was called. The enumerator is safe to use concurrently with reads from and writes to the stack. The enumerator returns items in LIFO (last-in, first-out) order.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the <see cref="System.Collections.Concurrent.ConcurrentStack%601" /> is empty.</summary>
        <value>true if the <see cref="System.Collections.Concurrent.ConcurrentStack%601" /> is empty; otherwise, false.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 For determining whether the collection contains any items, use of this property is recommended rather than retrieving the number of items from the <xref:System.Collections.Concurrent.ConcurrentStack%601.Count%2A> property and comparing it to 0. However, as this collection is intended to be accessed concurrently, it may be the case that another thread will modify the collection after IsEmpty returns, thus invalidating the result.  
  
 For a code example, see <xref:System.Collections.Concurrent.ConcurrentStack%601>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Push">
      <MemberSignature Language="C#" Value="public void Push (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Push(!T item) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">The object to push onto the <see cref="System.Collections.Concurrent.ConcurrentStack%601" />. The value can be a null reference (Nothing in Visual Basic) for reference types.</param>
        <summary>Inserts an object at the top of the <see cref="System.Collections.Concurrent.ConcurrentStack%601" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PushRange">
      <MemberSignature Language="C#" Value="public void PushRange (T[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushRange(!T[] items) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="items" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="items">The objects to push onto the <see cref="System.Collections.Concurrent.ConcurrentStack%601" />.</param>
        <summary>Inserts multiple objects at the top of the <see cref="System.Collections.Concurrent.ConcurrentStack%601" /> atomically.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 When adding multiple items to the stack, using PushRange is a more efficient mechanism than using <xref:System.Collections.Concurrent.ConcurrentStack%601.Push%2A> one item at a time. Additionally, PushRange guarantees that all of the elements will be added atomically, meaning that no other threads will be able to inject elements between the elements being pushed. Items at lower indices in the `items` array will be pushed before items at higher indices.  
  
 For a code example, see <xref:System.Collections.Concurrent.ConcurrentStack%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="items" /> is a null reference (Nothing in Visual Basic).</exception>
      </Docs>
    </Member>
    <Member MemberName="PushRange">
      <MemberSignature Language="C#" Value="public void PushRange (T[] items, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushRange(!T[] items, int32 startIndex, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="items" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="items">The objects to push onto the <see cref="System.Collections.Concurrent.ConcurrentStack%601" />.</param>
        <param name="startIndex">The zero-based offset in `items` at which to begin inserting elements onto the top of the <see cref="System.Collections.Concurrent.ConcurrentStack%601" />.</param>
        <param name="count">The number of elements to be inserted onto the top of the <see cref="System.Collections.Concurrent.ConcurrentStack%601" />.</param>
        <summary>Inserts multiple objects at the top of the <see cref="System.Collections.Concurrent.ConcurrentStack%601" /> atomically.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 When adding multiple items to the stack, using PushRange is a more efficient mechanism than using <xref:System.Collections.Concurrent.ConcurrentStack%601.Push%2A> one item at a time. Additionally, PushRange guarantees that all of the elements will be added atomically, meaning that no other threads will be able to inject elements between the elements being pushed. Items at lower indices in the `items` array will be pushed before items at higher indices.  
  
 For a code example, see <xref:System.Collections.Concurrent.ConcurrentStack%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="items" /> is a null reference (Nothing in Visual Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> or <paramref name="count" /> is negative. Or <paramref name="startIndex" /> is greater than or equal to the length of <paramref name="items" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="startIndex" /> + <paramref name="count" /> is greater than the length of <paramref name="items" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt;.TryAdd">
      <MemberSignature Language="C#" Value="bool IProducerConsumerCollection&lt;T&gt;.TryAdd (T item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt;.TryAdd(!T item) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">The object to add to the <see cref="System.Collections.Concurrent.IProducerConsumerCollection%601" />. The value can be a null reference (Nothing in Visual Basic) for reference types.</param>
        <summary>Attempts to add an object to the <see cref="System.Collections.Concurrent.IProducerConsumerCollection%601" />.</summary>
        <returns>true if the object was added successfully; otherwise, false.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 For <xref:System.Collections.Concurrent.ConcurrentStack%601>, this operation will always insert the object onto the top of the <xref:System.Collections.Concurrent.ConcurrentStack%601> and return true.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt;.TryTake">
      <MemberSignature Language="C#" Value="bool IProducerConsumerCollection&lt;T&gt;.TryTake (out T item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt;.TryTake(!T item) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="item">When this method returns, if the operation was successful, `item` contains the object removed. If no object was available to be removed, the value is unspecified.</param>
        <summary>Attempts to remove and return an object from the <see cref="System.Collections.Concurrent.IProducerConsumerCollection%601" />.</summary>
        <returns>true if an element was removed and returned succesfully; otherwise, false.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 For <xref:System.Collections.Concurrent.ConcurrentStack%601>, this operation will attempt to pop the object at the top of the <xref:System.Collections.Concurrent.ConcurrentStack%601>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from the <see cref="System.Collections.Concurrent.ConcurrentStack%601" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
        <param name="index">The zero-based index in `array` at which copying begins.</param>
        <summary>Copies the elements of the <see cref="T:System.Collections.ICollection" /> to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is a null reference (Nothing in Visual Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> is multidimensional. -or- <paramref name="array" /> does not have zero-based indexing. -or- <paramref name="index" /> is equal to or greater than the length of the <paramref name="array" /> -or- The number of elements in the source <see cref="T:System.Collections.ICollection" /> is greater than the available space from <paramref name="index" /> to the end of the destination <paramref name="array" />. -or- The type of the source <see cref="T:System.Collections.ICollection" /> cannot be cast automatically to the type of the destination <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection" /> is synchronized with the SyncRoot.</summary>
        <value>true if access to the <see cref="T:System.Collections.ICollection" /> is synchronized with the SyncRoot; otherwise, false. For <see cref="System.Collections.Concurrent.ConcurrentStack%601" />, this property always returns false.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />. This property is not supported.</summary>
        <value>Returns null (Nothing in Visual Basic).</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">The SyncRoot property is not supported</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an enumerator that iterates through a collection.</summary>
        <returns>An <see cref="T:System.Collections.IEnumerator" /> that can be used to iterate through the collection.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The enumeration represents a moment-in-time snapshot of the contents of the stack. It does not reflect any updates to the collection after <xref:System.Collections.Concurrent.ConcurrentStack%601.GetEnumerator%2A> was called. The enumerator is safe to use concurrently with reads from and writes to the stack.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance !T[] ToArray() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copies the items stored in the <see cref="System.Collections.Concurrent.ConcurrentStack%601" /> to a new array.</summary>
        <returns>A new array containing a snapshot of elements copied from the <see cref="System.Collections.Concurrent.ConcurrentStack%601" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryPeek">
      <MemberSignature Language="C#" Value="public bool TryPeek (out T result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryPeek(!T result) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="T&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result">When this method returns, `result` contains an object from the top of the <see cref="System.Collections.Concurrent.ConcurrentStack%601" />or an unspecified value if the operation failed.</param>
        <summary>Attempts to return an object from the top of the <see cref="System.Collections.Concurrent.ConcurrentStack%601" /> without removing it.</summary>
        <returns>true if and object was returned successfully; otherwise, false.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryPop">
      <MemberSignature Language="C#" Value="public bool TryPop (out T result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryPop(!T result) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="T&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result">When this method returns, if the operation was successful, `result` contains the object removed. If no object was available to be removed, the value is unspecified.</param>
        <summary>Attempts to pop and return the object at the top of the <see cref="System.Collections.Concurrent.ConcurrentStack%601" />.</summary>
        <returns>true if an element was removed and returned from the top of the <see cref="System.Collections.Concurrent.ConcurrentStack%601" /> successfully; otherwise, false.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 For a code example, see <xref:System.Collections.Concurrent.ConcurrentStack%601>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryPopRange">
      <MemberSignature Language="C#" Value="public int TryPopRange (T[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 TryPopRange(!T[] items) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="items" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="items">The <see cref="T:System.Array" /> to which objects popped from the top of the <see cref="System.Collections.Concurrent.ConcurrentStack%601" /> will be added.</param>
        <summary>Attempts to pop and return multiple objects from the top of the <see cref="System.Collections.Concurrent.ConcurrentStack%601" /> atomically.</summary>
        <returns>The number of objects successfully popped from the top of the <see cref="System.Collections.Concurrent.ConcurrentStack%601" /> and inserted in <paramref name="items" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 When popping multiple items, if there is little contention on the stack, using `TryPopRange` can be more efficient than using <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPop%2A> once per item to be removed. Nodes fill the `items` array with the first item to be popped at the startIndex, the second item to be popped at startIndex + 1, and so on.  
  
 For a code example, see <xref:System.Collections.Concurrent.ConcurrentStack%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="items" /> is a null argument (Nothing in Visual Basic).</exception>
      </Docs>
    </Member>
    <Member MemberName="TryPopRange">
      <MemberSignature Language="C#" Value="public int TryPopRange (T[] items, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 TryPopRange(!T[] items, int32 startIndex, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="items" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="items">The <see cref="T:System.Array" /> to which objects popped from the top of the <see cref="System.Collections.Concurrent.ConcurrentStack%601" /> will be added.</param>
        <param name="startIndex">The zero-based offset in `items` at which to begin inserting elements from the top of the <see cref="System.Collections.Concurrent.ConcurrentStack%601" />.</param>
        <param name="count">The number of elements to be popped from top of the <see cref="System.Collections.Concurrent.ConcurrentStack%601" /> and inserted into `items`.</param>
        <summary>Attempts to pop and return multiple objects from the top of the <see cref="System.Collections.Concurrent.ConcurrentStack%601" /> atomically.</summary>
        <returns>The number of objects successfully popped from the top of the stack and inserted in <paramref name="items" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 When popping multiple items, if there is little contention on the stack, using TryPopRange can be more efficient than using <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPop%2A> once per item to be removed. Nodes fill the `items` array with the first item to be popped at the startIndex, the second item to be popped at startIndex + 1, and so on.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="items" /> is a null reference (Nothing in Visual Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> or <paramref name="count" /> is negative. Or <paramref name="startIndex" /> is greater than or equal to the length of <paramref name="items" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="startIndex" /> + <paramref name="count" /> is greater than the length of <paramref name="items" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>