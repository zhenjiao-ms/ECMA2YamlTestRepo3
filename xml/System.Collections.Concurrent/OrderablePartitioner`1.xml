<Type Name="OrderablePartitioner&lt;TSource&gt;" FullName="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;">
  <TypeSignature Language="C#" Value="public abstract class OrderablePartitioner&lt;TSource&gt; : System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit OrderablePartitioner`1&lt;TSource&gt; extends System.Collections.Concurrent.Partitioner`1&lt;!TSource&gt;" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TSource" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Collections.Concurrent.Partitioner&lt;TSource&gt;</BaseTypeName>
    <BaseTypeArguments>
      <BaseTypeArgument TypeParamName="TSource">TSource</BaseTypeArgument>
    </BaseTypeArguments>
  </Base>
  <Interfaces />
  <Docs>
    <typeparam name="TSource">To be added.</typeparam>
    <summary>Represents a particular manner of splitting an orderable data source into multiple partitions.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The implementation of the derived class is responsible for ordering the elements into key-value pairs in whatever manner is appropriate. For more information, see [Custom Partitioners for PLINQ and TPL](../Topic/Custom%20Partitioners%20for%20PLINQ%20and%20TPL.md).  
  
   
  
## Examples  
 The following example shows how to implement an orderable partitioner that returns one element at a time:  
  
 [!code-cs[System.Collections.Concurrent.OrderablePartitioner#1](~/add/codesnippet/csharp/t-system.collections.con_1_1.cs)]
 [!code-vb[System.Collections.Concurrent.OrderablePartitioner#1](~/add/codesnippet/visualbasic/t-system.collections.con_1_1.vb)]  
  
 ]]></format>
    </remarks>
    <threadsafe>All public members of OrderablePartitioner(TSource) are thread-safe and may be called from multiple threads concurrently.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected OrderablePartitioner (bool keysOrderedInEachPartition, bool keysOrderedAcrossPartitions, bool keysNormalized);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(bool keysOrderedInEachPartition, bool keysOrderedAcrossPartitions, bool keysNormalized) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="keysOrderedInEachPartition" Type="System.Boolean" />
        <Parameter Name="keysOrderedAcrossPartitions" Type="System.Boolean" />
        <Parameter Name="keysNormalized" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="keysOrderedInEachPartition">Indicates whether the elements in each partition are yielded in the order of increasing keys.</param>
        <param name="keysOrderedAcrossPartitions">Indicates whether elements in an earlier partition always come before elements in a later partition. If true, each element in partition 0 has a smaller order key than any element in partition 1, each element in partition 1 has a smaller order key than any element in partition 2, and so on.</param>
        <param name="keysNormalized">Indicates whether keys are normalized. If true, all order keys are distinct integers in the range [0 .. numberOfElements-1]. If false, order keys must still be distinct, but only their relative order is considered, not their absolute values.</param>
        <summary>Called from constructors in derived classes to initialize the <see cref="System.Collections.Concurrent.OrderablePartitioner%601" /> class with the specified constraints on the index keys.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 For more information, see [Custom Partitioners for PLINQ and TPL](../Topic/Custom%20Partitioners%20for%20PLINQ%20and%20TPL.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDynamicPartitions">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IEnumerable&lt;TSource&gt; GetDynamicPartitions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IEnumerable`1&lt;!TSource&gt; GetDynamicPartitions() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates an object that can partition the underlying collection into a variable number of partitions.</summary>
        <returns>An object that can create partitions over the underlying data source.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The returned object implements the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=fullName> interface. Calling <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> on the object creates another partition over the sequence.  
  
 The default implementation provides the same behavior as <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> except that the returned set of partitions does not provide the keys for the elements.  
  
 The GetDynamicPartitions method is only supported if the <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> property returns true.  
  
 For more information, see [Custom Partitioners for PLINQ and TPL](../Topic/Custom%20Partitioners%20for%20PLINQ%20and%20TPL.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Dynamic partitioning is not supported by the base class. It must be implemented in derived classes.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetOrderableDynamicPartitions">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;long,TSource&gt;&gt; GetOrderableDynamicPartitions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;int64, !TSource&gt;&gt; GetOrderableDynamicPartitions() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.Int64,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates an object that can partition the underlying collection into a variable number of partitions.</summary>
        <returns>An object that can create partitions over the underlying data source.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The returned object implements the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=fullName> interface. Calling <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> on the object creates another partition over the sequence.  
  
 Each partition is represented as an enumerator over key-value pairs. The value in the pair is the element itself, and the key is an integer which determines the relative ordering of this element against other elements.  
  
 The GetOrderableDynamicPartitions method is only supported if the <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> property returns true.  
  
 For more information, see [Custom Partitioners for PLINQ and TPL](../Topic/Custom%20Partitioners%20for%20PLINQ%20and%20TPL.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Dynamic partitioning is not supported by this partitioner.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetOrderablePartitions">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IList&lt;System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;long,TSource&gt;&gt;&gt; GetOrderablePartitions (int partitionCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;int64, !TSource&gt;&gt;&gt; GetOrderablePartitions(int32 partitionCount) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.Int64,TSource&gt;&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partitionCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="partitionCount">The number of partitions to create.</param>
        <summary>Partitions the underlying collection into the specified number of orderable partitions.</summary>
        <returns>A list containing <paramref name="partitionCount" /> enumerators.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Each partition is represented as an enumerator over key-value pairs.  
  
 The value of the pair is the element itself, and the key is an integer which determines the relative ordering of this element against other elements in the data source.  
  
 For more information, see [Custom Partitioners for PLINQ and TPL](../Topic/Custom%20Partitioners%20for%20PLINQ%20and%20TPL.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPartitions">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IList&lt;System.Collections.Generic.IEnumerator&lt;TSource&gt;&gt; GetPartitions (int partitionCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IList`1&lt;class System.Collections.Generic.IEnumerator`1&lt;!TSource&gt;&gt; GetPartitions(int32 partitionCount) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Collections.Generic.IEnumerator&lt;TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partitionCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="partitionCount">The number of partitions to create.</param>
        <summary>Partitions the underlying collection into the given number of ordered partitions.</summary>
        <returns>A list containing <paramref name="partitionCount" /> enumerators.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The default implementation provides the same behavior as <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> except that the returned set of partitions does not provide the keys for the elements.  
  
 For more information, see [Custom Partitioners for PLINQ and TPL](../Topic/Custom%20Partitioners%20for%20PLINQ%20and%20TPL.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeysNormalized">
      <MemberSignature Language="C#" Value="public bool KeysNormalized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeysNormalized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets whether order keys are normalized.</summary>
        <value>true if the keys are normalized; otherwise false.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If KeysNormalized returns true, all order keys are distinct integers in the range [0 .. numberOfElements-1]. If the property returns false, order keys must still be distinct, but only their relative order is considered, not their absolute values.  
  
 For more information, see [Custom Partitioners for PLINQ and TPL](../Topic/Custom%20Partitioners%20for%20PLINQ%20and%20TPL.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeysOrderedAcrossPartitions">
      <MemberSignature Language="C#" Value="public bool KeysOrderedAcrossPartitions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeysOrderedAcrossPartitions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets whether elements in an earlier partition always come before elements in a later partition.</summary>
        <value>true if the elements in an earlier partition always come before elements in a later partition; otherwise false.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If KeysOrderedAcrossPartitions returns true, each element in partition 0 has a smaller order key than any element in partition 1, each element in partition 1 has a smaller order key than any element in partition 2, and so on.  
  
 For more information, see [Custom Partitioners for PLINQ and TPL](../Topic/Custom%20Partitioners%20for%20PLINQ%20and%20TPL.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeysOrderedInEachPartition">
      <MemberSignature Language="C#" Value="public bool KeysOrderedInEachPartition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeysOrderedInEachPartition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets whether elements in each partition are yielded in the order of increasing keys.</summary>
        <value>true if the elements in each partition are yielded in the order of increasing keys; otherwise false.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 For more information, see [Custom Partitioners for PLINQ and TPL](../Topic/Custom%20Partitioners%20for%20PLINQ%20and%20TPL.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>