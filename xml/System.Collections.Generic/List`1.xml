<Type Name="List&lt;T&gt;" FullName="System.Collections.Generic.List&lt;T&gt;">
  <TypeSignature Language="C#" Value="public class List&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IList&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.IReadOnlyList&lt;T&gt;, System.Collections.IList" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit List`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IList`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyList`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_CollectionDebugView`1))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">To be added.</typeparam>
    <summary>Represents a strongly typed list of objects that can be accessed by index. Provides methods to search, sort, and manipulate lists.  
  
 To browse the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/collections/generic/list.cs#cf7f4095e4de7646).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/collections/generic/list.cs#cf7f4095e4de7646). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  
  
 The List(T) class is the generic equivalent of the <xref:System.Collections.ArrayList> class. It implements the <xref:System.Collections.Generic.IList%601> generic interface by using an array whose size is dynamically increased as required.  
  
 You can add items to a List(T) by using the <xref:System.Collections.Generic.List%601.Add%2A> or <xref:System.Collections.Generic.List%601.AddRange%2A> methods.  
  
 The List(T) class uses both an equality comparer and an ordering comparer.  
  
-   Methods such as <xref:System.Collections.Generic.List%601.Contains%2A>, <xref:System.Collections.Generic.List%601.IndexOf%2A>, <xref:System.Collections.Generic.List%601.LastIndexOf%2A>, and <xref:System.Collections.Generic.Dictionary%602.Remove%2A> use an equality comparer for the list elements. The default equality comparer for type `T` is determined as follows. If type `T` implements the <xref:System.IEquatable%601> generic interface, then the equality comparer is the <xref:System.IEquatable%601.Equals%28%600%29> method of that interface; otherwise, the default equality comparer is <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName>.  
  
-   Methods such as <xref:System.Collections.Generic.List%601.BinarySearch%2A> and <xref:System.Collections.Generic.List%601.Sort%2A> use an ordering comparer for the list elements. The default comparer for type `T` is determined as follows.  If type `T` implements the <xref:System.IComparable%601> generic interface, then the default comparer is the <xref:System.IComparable%601.CompareTo%28%600%29> method of that interface; otherwise, if type `T` implements the nongeneric <xref:System.IComparable> interface, then the default comparer is the <xref:System.IComparable.CompareTo%28System.Object%29> method of that interface. If type `T` implements neither interface, then there is no default comparer, and a comparer or comparison delegate must be provided explicitly.  
  
 The List(T) is not guaranteed to be sorted.  You must sort the List(T) before performing operations (such as <xref:System.Collections.Generic.List%601.BinarySearch%2A>) that require the List(T) to be sorted.  
  
 Elements in this collection can be accessed using an integer index.  Indexes in this collection are zero-based.  
  
 For very large List(T) objects, you can increase the maximum capacity to 2 billion elements on a 64-bit system by setting the `enabled` attribute of the  configuration element to `true` in the run-time environment.  
  
 List(T) accepts `null` as a valid value for reference types and allows duplicate elements.  
  
 For an immutable version of the List(T) class, see <xref:System.Collections.Immutable.ImmutableList%601>.  
  
## Performance Considerations  
 In deciding whether to use the List(T) or <xref:System.Collections.ArrayList> class, both of which have similar functionality, remember that the List(T) class performs better in most cases and is type safe. If a reference type is used for type `T` of the List(T) class, the behavior of the two classes is identical. However, if a value type is used for type `T`, you need to consider implementation and boxing issues.  
  
 If a value type is used for type `T`, the compiler generates an implementation of the List(T) class specifically for that value type. That means a list element of a List(T) object does not have to be boxed before the element can be used, and after about 500 list elements are created the memory saved not boxing list elements is greater than the memory used to generate the class implementation.  
  
 Make certain the value type used for type `T` implements the <xref:System.IEquatable%601> generic interface. If not, methods such as <xref:System.Collections.Generic.List%601.Contains%2A> must call the <xref:System.Object.Equals%28System.Object%29?displayProperty=fullName> method, which boxes the affected list element. If the value type implements the <xref:System.IComparable> interface and you own the source code, also implement the <xref:System.IComparable%601> generic interface to prevent the <xref:System.Collections.Generic.List%601.BinarySearch%2A> and <xref:System.Collections.Generic.List%601.Sort%2A> methods from boxing list elements. If you do not own the source code, pass an <xref:System.Collections.Generic.IComparer%601> object to the <xref:System.Collections.Generic.List%601.BinarySearch%2A> and <xref:System.Collections.Generic.List%601.Sort%2A> methods  
  
 It is to your advantage to use the type-specific implementation of the List(T) class instead of using the <xref:System.Collections.ArrayList> class or writing a strongly typed wrapper collection yourself. The reason is your implementation must do what the .NET Framework does for you already, and the common language runtime can share Microsoft intermediate language code and metadata, which your implementation cannot.  
  
## F# Considerations  
 The List(T) class is used infrequently in F# code.  Instead, [Lists](../Topic/Lists%20\(F%23\).md), which are immutable, singly-linked lists, are typically preferred. An F# List provides an ordered, immutable series of values, and is supported for use in functional-style development. When used from F#, theList(T) class is typically referred to by the  [ResizeArray\<'T>](https://msdn.microsoft.com/library/ee353447.aspx) type abbreviation to avoid naming conflicts with F# Lists  
  
   
  
## Examples  
 The following example demonstrates how to add, remove, and insert a simple business object in a List(T).  
  
 [!code-cs[System.Collections.Generic.List.AddRemoveInsert#1](~/add/codesnippet/csharp/t-system.collections.gen_6_1.cs)]
 [!code-fs[System.Collections.Generic.List.AddRemoveInsert#1](~/add/codesnippet/fsharp/t-system.collections.gen_6_1.fs)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/add/codesnippet/visualbasic/t-system.collections.gen_6_1.vb)]  
  
 The following example demonstrates several properties and methods of the List(T) generic class of type string. (For an example of a List(T) of complex types, see the <xref:System.Collections.Generic.List%601.Contains%2A> method.)  
  
 The default constructor is used to create a list of strings with the default capacity. The <xref:System.Collections.Generic.List%601.Capacity%2A> property is displayed and then the <xref:System.Collections.Generic.List%601.Add%2A> method is used to add several items. The items are listed, and the <xref:System.Collections.Generic.List%601.Capacity%2A> property is displayed again, along with the <xref:System.Collections.Generic.List%601.Count%2A> property, to show that the capacity has been increased as needed.  
  
 The <xref:System.Collections.Generic.List%601.Contains%2A> method is used to test for the presence of an item in the list, the <xref:System.Collections.Generic.List%601.Insert%2A> method is used to insert a new item in the middle of the list, and the contents of the list are displayed again.  
  
 The default <xref:System.Collections.Generic.List%601.Item%2A> property (the indexer in C#) is used to retrieve an item, the <xref:System.Collections.Generic.List%601.Remove%2A> method is used to remove the first instance of the duplicate item added earlier, and the contents are displayed again. The <xref:System.Collections.Generic.List%601.Remove%2A> method always removes the first instance it encounters.  
  
 The <xref:System.Collections.Generic.List%601.TrimExcess%2A> method is used to reduce the capacity to match the count, and the <xref:System.Collections.Generic.List%601.Capacity%2A> and <xref:System.Collections.Generic.List%601.Count%2A> properties are displayed. If the unused capacity had been less than 10 percent of total capacity, the list would not have been resized.  
  
 Finally, the <xref:System.Collections.Generic.List%601.Clear%2A> method is used to remove all items from the list, and the <xref:System.Collections.Generic.List%601.Capacity%2A> and <xref:System.Collections.Generic.List%601.Count%2A> properties are displayed.  
  
 [!code-cpp[List`1_Class#1](~/add/codesnippet/cpp/t-system.collections.gen_6_2.cpp)]
 [!code-cs[List`1_Class#1](~/add/codesnippet/csharp/t-system.collections.gen_6_2.cs)]
 [!code-fs[List`1_Class#1](~/add/codesnippet/fsharp/t-system.collections.gen_6_2.fs)]
 [!code-vb[List`1_Class#1](~/add/codesnippet/visualbasic/t-system.collections.gen_6_2.vb)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Public static (<see langword="Shared" /> in Visual Basic) members of this type are thread safe. Any instance members are not guaranteed to be thread safe.  
  
 It is safe to perform multiple read operations on a List(T), but issues can occur if the collection is modified while it’s being read. To ensure thread safety, lock the collection during a read or write operation. To enable a collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization. For collections with built-in synchronization, see the classes in the <see cref="N:System.Collections.Concurrent" /> namespace. For an inherently thread–safe alternative, see the <see cref="System.Collections.Immutable.ImmutableList%601" /> class.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="System.Collections.Generic.List%601" /> class that is empty and has the default initial capacity.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The capacity of a <xref:System.Collections.Generic.List%601> is the number of elements that the <xref:System.Collections.Generic.List%601> can hold. As elements are added to a <xref:System.Collections.Generic.List%601>, the capacity is automatically increased as required by reallocating the internal array.  
  
 If the size of the collection can be estimated, using the <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> constructor and specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <xref:System.Collections.Generic.List%601>.  
  
 The capacity can be decreased by calling the <xref:System.Collections.Generic.List%601.TrimExcess%2A> method or by setting the <xref:System.Collections.Generic.List%601.Capacity%2A> property explicitly. Decreasing the capacity reallocates memory and copies all the elements in the <xref:System.Collections.Generic.List%601>.  
  
 This constructor is an O(1) operation.  
  
   
  
## Examples  
 The following example demonstrates the default constructor of the <xref:System.Collections.Generic.List%601> generic class. The default constructor creates a list with the default capacity, as demonstrated by displaying the <xref:System.Collections.Generic.List%601.Capacity%2A> property.  
  
 The example adds, inserts, and removes items, showing how the capacity changes as these methods are used.  
  
 [!code-cpp[List`1_Class#1](~/add/codesnippet/cpp/m-system.collections.gen_39_1.cpp)]
 [!code-cs[List`1_Class#1](~/add/codesnippet/csharp/m-system.collections.gen_39_1.cs)]
 [!code-fs[List`1_Class#1](~/add/codesnippet/fsharp/m-system.collections.gen_39_1.fs)]
 [!code-vb[List`1_Class#1](~/add/codesnippet/visualbasic/m-system.collections.gen_39_1.vb)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">The collection whose elements are copied to the new list.</param>
        <summary>Initializes a new instance of the <see cref="System.Collections.Generic.List%601" /> class that contains elements copied from the specified collection and has sufficient capacity to accommodate the number of elements copied.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The elements are copied onto the <xref:System.Collections.Generic.List%601> in the same order they are read by the enumerator of the collection.  
  
 This constructor is an O(`n`) operation, where `n` is the number of elements in `collection`.  
  
   
  
## Examples  
 The following example demonstrates the List(T) constructor and various methods of the <xref:System.Collections.Generic.List%601> class that act on ranges. An array of strings is created and passed to the constructor, populating the list with the elements of the array. The <xref:System.Collections.Generic.List%601.Capacity%2A> property is then displayed, to show that the initial capacity is exactly what is required to hold the input elements.  
  
 [!code-vb[List`1_Ranges#1](~/add/codesnippet/visualbasic/e6f3ad9d-3bf0-429a-8d2e-_1.vb)]
 [!code-cpp[List`1_Ranges#1](~/add/codesnippet/cpp/e6f3ad9d-3bf0-429a-8d2e-_1.cpp)]
 [!code-cs[List`1_Ranges#1](~/add/codesnippet/csharp/e6f3ad9d-3bf0-429a-8d2e-_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">The number of elements that the new list can initially store.</param>
        <summary>Initializes a new instance of the <see cref="System.Collections.Generic.List%601" /> class that is empty and has the specified initial capacity.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The capacity of a <xref:System.Collections.Generic.List%601> is the number of elements that the <xref:System.Collections.Generic.List%601> can hold. As elements are added to a <xref:System.Collections.Generic.List%601>, the capacity is automatically increased as required by reallocating the internal array.  
  
 If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <xref:System.Collections.Generic.List%601>.  
  
 The capacity can be decreased by calling the <xref:System.Collections.Generic.List%601.TrimExcess%2A> method or by setting the <xref:System.Collections.Generic.List%601.Capacity%2A> property explicitly. Decreasing the capacity reallocates memory and copies all the elements in the <xref:System.Collections.Generic.List%601>.  
  
 This constructor is an O(`n`) operation, where `n` is `capacity`.  
  
   
  
## Examples  
 The following example demonstrates the List(T) constructor. A <xref:System.Collections.Generic.List%601> of strings with a capacity of 4 is created, because the ultimate size of the list is known to be exactly 4. The list is populated with four strings, and a read-only copy is created by using the <xref:System.Collections.Generic.List%601.AsReadOnly%2A> method.  
  
 [!code-cs[List`1_AsReadOnly#1](~/add/codesnippet/csharp/m-system.collections.gen_30_1.cs)]
 [!code-cpp[List`1_AsReadOnly#1](~/add/codesnippet/cpp/m-system.collections.gen_30_1.cpp)]
 [!code-vb[List`1_AsReadOnly#1](~/add/codesnippet/visualbasic/m-system.collections.gen_30_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> is less than 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!T item) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">The object to be added to the end of the <see cref="System.Collections.Generic.List%601" />. The value can be <see langword="null" /> for reference types.</param>
        <summary>Adds an object to the end of the <see cref="System.Collections.Generic.List%601" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> accepts `null` as a valid value for reference types and allows duplicate elements.  
  
 If <xref:System.Collections.Generic.List%601.Count%2A> already equals <xref:System.Collections.Generic.List%601.Capacity%2A>, the capacity of the <xref:System.Collections.Generic.List%601> is increased by automatically reallocating the internal array, and the existing elements are copied to the new array before the new element is added.  
  
 If <xref:System.Collections.Generic.List%601.Count%2A> is less than <xref:System.Collections.Generic.List%601.Capacity%2A>, this method is an O(1) operation. If the capacity needs to be increased to accommodate the new element, this method becomes an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 The following example demonstrates how to add, remove, and insert a simple business object in a <xref:System.Collections.Generic.List%601>.  
  
 [!code-cs[System.Collections.Generic.List.AddRemoveInsert#1](~/add/codesnippet/csharp/m-system.collections.gen_14_1.cs)]
 [!code-fs[System.Collections.Generic.List.AddRemoveInsert#1](~/add/codesnippet/fsharp/m-system.collections.gen_14_1.fs)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/add/codesnippet/visualbasic/m-system.collections.gen_14_1.vb)]  
  
 The following example demonstrates several properties and methods of the <xref:System.Collections.Generic.List%601> generic class, including the Add method. The default constructor is used to create a list of strings with a capacity of 0. The <xref:System.Collections.Generic.List%601.Capacity%2A> property is displayed, and then the Add method is used to add several items. The items are listed, and the <xref:System.Collections.Generic.List%601.Capacity%2A> property is displayed again, along with the <xref:System.Collections.Generic.List%601.Count%2A> property, to show that the capacity has been increased as needed.  
  
 Other properties and methods are used to search for, insert, and remove elements from the list, and finally to clear the list.  
  
 [!code-cpp[List`1_Class#1](~/add/codesnippet/cpp/m-system.collections.gen_14_2.cpp)]
 [!code-cs[List`1_Class#1](~/add/codesnippet/csharp/m-system.collections.gen_14_2.cs)]
 [!code-fs[List`1_Class#1](~/add/codesnippet/fsharp/m-system.collections.gen_14_2.fs)]
 [!code-vb[List`1_Class#1](~/add/codesnippet/visualbasic/m-system.collections.gen_14_2.vb)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">The collection whose elements should be added to the end of the <see cref="System.Collections.Generic.List%601" />. The collection itself cannot be <see langword="null" />, but it can contain elements that are <see langword="null" />, if type `T` is a reference type.</param>
        <summary>Adds the elements of the specified collection to the end of the <see cref="System.Collections.Generic.List%601" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The order of the elements in the collection is preserved in the <xref:System.Collections.Generic.List%601>.  
  
 If the new <xref:System.Collections.Generic.List%601.Count%2A> (the current <xref:System.Collections.Generic.List%601.Count%2A> plus the size of the collection) will be greater than <xref:System.Collections.Generic.List%601.Capacity%2A>, the capacity of the <xref:System.Collections.Generic.List%601> is increased by automatically reallocating the internal array to accommodate the new elements, and the existing elements are copied to the new array before the new elements are added.  
  
 If the <xref:System.Collections.Generic.List%601> can accommodate the new elements without increasing the <xref:System.Collections.Generic.List%601.Capacity%2A>, this method is an O(`n`) operation, where `n` is the number of elements to be added. If the capacity needs to be increased to accommodate the new elements, this method becomes an O(`n` + `m`) operation, where `n` is the number of elements to be added and `m` is <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 The following example demonstrates the AddRange method and various other methods of the <xref:System.Collections.Generic.List%601> class that act on ranges. An array of strings is created and passed to the constructor, populating the list with the elements of the array. The AddRange method is called, with the list as its argument. The result is that the current elements of the list are added to the end of the list, duplicating all the elements.  
  
 [!code-vb[List`1_Ranges#1](~/add/codesnippet/visualbasic/95b86b69-0130-4a96-a1d8-_1.vb)]
 [!code-cpp[List`1_Ranges#1](~/add/codesnippet/cpp/95b86b69-0130-4a96-a1d8-_1.cpp)]
 [!code-cs[List`1_Ranges#1](~/add/codesnippet/csharp/95b86b69-0130-4a96-a1d8-_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsReadOnly">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!T&gt; AsReadOnly() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a read-only <see cref="System.Collections.ObjectModel.ReadOnlyCollection%601" /> wrapper for the current collection.</summary>
        <returns>An object that acts as a read-only wrapper around the current <see cref="System.Collections.Generic.List%601" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To prevent any modifications to the <xref:System.Collections.Generic.List%601> object, expose it only through this wrapper. A  <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> object does not expose methods that modify the collection. However, if changes are made to the underlying <xref:System.Collections.Generic.List%601> object, the read-only collection reflects those changes.  
  
 This method is an O(1) operation.  
  
   
  
## Examples  
 The following example demonstrates the AsReadOnly method. A <xref:System.Collections.Generic.List%601> of strings with a capacity of 4 is created, because the ultimate size of the list is known to be exactly 4. The list is populated with four strings, and the AsReadOnly method is used to get a read-only <xref:System.Collections.Generic.IList%601> generic interface implementation that wraps the original list.  
  
 An element of the original list is set to "Coelophysis" using the <xref:System.Collections.Generic.List%601.Item%2A> property (the indexer in C#), and the contents of the read-only list are displayed again to demonstrate that it is just a wrapper for the original list.  
  
 [!code-cs[List`1_AsReadOnly#1](~/add/codesnippet/csharp/m-system.collections.gen_41_1.cs)]
 [!code-cpp[List`1_AsReadOnly#1](~/add/codesnippet/cpp/m-system.collections.gen_41_1.cpp)]
 [!code-vb[List`1_AsReadOnly#1](~/add/codesnippet/visualbasic/m-system.collections.gen_41_1.vb)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">The object to locate. The value can be <see langword="null" /> for reference types.</param>
        <summary>Searches the entire sorted <see cref="System.Collections.Generic.List%601" /> for an element using the default comparer and returns the zero-based index of the element.</summary>
        <returns>The zero-based index of <paramref name="item" /> in the sorted <see cref="System.Collections.Generic.List%601" />, if <paramref name="item" /> is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than <paramref name="item" /> or, if there is no larger element, the bitwise complement of <see cref="System.Collections.Generic.List%601.Count%2A" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method uses the default comparer <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName> for type `T` to determine the order of list elements. The <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName> property checks whether type `T` implements the <xref:System.IComparable%601> generic interface and uses that implementation, if available.  If not, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName> checks whether type `T` implements the <xref:System.IComparable> interface.  If type `T` does not implement either interface, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName> throws an <xref:System.InvalidOperationException>.  
  
 The <xref:System.Collections.Generic.List%601> must already be sorted according to the comparer implementation; otherwise, the result is incorrect.  
  
 Comparing `null` with any reference type is allowed and does not generate an exception when using the <xref:System.IComparable%601> generic interface. When sorting, `null` is considered to be less than any other object.  
  
 If the <xref:System.Collections.Generic.List%601> contains more than one element with the same value, the method returns only one of the occurrences, and it might return any one of the occurrences, not necessarily the first one.  
  
 If the <xref:System.Collections.Generic.List%601> does not contain the specified value, the method returns a negative integer. You can apply the bitwise complement operation (~) to this negative integer to get the index of the first element that is larger than the search value. When inserting the value into the <xref:System.Collections.Generic.List%601>, this index should be used as the insertion point to maintain the sort order.  
  
 This method is an O(log `n`) operation, where `n` is the number of elements in the range.  
  
   
  
## Examples  
 The following example demonstrates the <xref:System.Collections.Generic.List%601.Sort> method overload and the BinarySearch method overload. A <xref:System.Collections.Generic.List%601> of strings is created and populated with four strings, in no particular order. The list is displayed, sorted, and displayed again.  
  
 The BinarySearch method overload is then used to search for two strings that are not in the list, and the <xref:System.Collections.Generic.List%601.Insert%2A> method is used to insert them. The return value of the BinarySearch method is negative in each case, because the strings are not in the list. Taking the bitwise complement (the ~ operator in C# and Visual C++, `Xor` -1 in Visual Basic) of this negative number produces the index of the first element in the list that is larger than the search string, and inserting at this location preserves the sort order. The second search string is larger than any element in the list, so the insertion position is at the end of the list.  
  
 [!code-cpp[List`1_SortSearch#1](~/add/codesnippet/cpp/m-system.collections.gen_44_1.cpp)]
 [!code-cs[List`1_SortSearch#1](~/add/codesnippet/csharp/m-system.collections.gen_44_1.cs)]
 [!code-vb[List`1_SortSearch#1](~/add/codesnippet/visualbasic/m-system.collections.gen_44_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The default comparer <see cref="System.Collections.Generic.Comparer%601.Default%2A" /> cannot find an implementation of the <see cref="System.IComparable%601" /> generic interface or the <see cref="T:System.IComparable" /> interface for type <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="item">The object to locate. The value can be <see langword="null" /> for reference types.</param>
        <param name="comparer">The <see cref="System.Collections.Generic.IComparer%601" /> implementation to use when comparing elements.  
  
 -or-  
  
 <see langword="null" /> to use the default comparer <see cref="System.Collections.Generic.Comparer%601.Default%2A" />.</param>
        <summary>Searches the entire sorted <see cref="System.Collections.Generic.List%601" /> for an element using the specified comparer and returns the zero-based index of the element.</summary>
        <returns>The zero-based index of <paramref name="item" /> in the sorted <see cref="System.Collections.Generic.List%601" />, if <paramref name="item" /> is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than <paramref name="item" /> or, if there is no larger element, the bitwise complement of <see cref="System.Collections.Generic.List%601.Count%2A" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The comparer customizes how the elements are compared. For example, you can use a <xref:System.Collections.CaseInsensitiveComparer> instance as the comparer to perform case-insensitive string searches.  
  
 If `comparer` is provided, the elements of the <xref:System.Collections.Generic.List%601> are compared to the specified value using the specified <xref:System.Collections.Generic.IComparer%601> implementation.  
  
 If `comparer` is `null`, the default comparer <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName> checks whether type `T` implements the <xref:System.IComparable%601> generic interface and uses that implementation, if available.  If not, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName> checks whether type `T` implements the <xref:System.IComparable> interface.  If type `T` does not implement either interface, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName> throws <xref:System.InvalidOperationException>.  
  
 The <xref:System.Collections.Generic.List%601> must already be sorted according to the comparer implementation; otherwise, the result is incorrect.  
  
 Comparing `null` with any reference type is allowed and does not generate an exception when using the <xref:System.IComparable%601> generic interface. When sorting, `null` is considered to be less than any other object.  
  
 If the <xref:System.Collections.Generic.List%601> contains more than one element with the same value, the method returns only one of the occurrences, and it might return any one of the occurrences, not necessarily the first one.  
  
 If the <xref:System.Collections.Generic.List%601> does not contain the specified value, the method returns a negative integer. You can apply the bitwise complement operation (~) to this negative integer to get the index of the first element that is larger than the search value. When inserting the value into the <xref:System.Collections.Generic.List%601>, this index should be used as the insertion point to maintain the sort order.  
  
 This method is an O(log `n`) operation, where `n` is the number of elements in the range.  
  
   
  
## Examples  
 The following example demonstrates the <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> method overload and the BinarySearch method overload.  
  
 The example defines an alternative comparer for strings named DinoCompare, which implements the `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer\<String^>` in Visual C++) generic interface. The comparer works as follows: First, the comparands are tested for `null`, and a null reference is treated as less than a non-null. Second, the string lengths are compared, and the longer string is deemed to be greater. Third, if the lengths are equal, ordinary string comparison is used.  
  
 A <xref:System.Collections.Generic.List%601> of strings is created and populated with four strings, in no particular order. The list is displayed, sorted using the alternate comparer, and displayed again.  
  
 The BinarySearch method overload is then used to search for several strings that are not in the list, employing the alternate comparer. The <xref:System.Collections.Generic.List%601.Insert%2A> method is used to insert the strings. These two methods are located in the function named `SearchAndInsert`, along with code to take the bitwise complement (the ~ operator in C# and Visual C++, `Xor` -1 in Visual Basic) of the negative number returned by BinarySearch and use it as an index for inserting the new string.  
  
 [!code-cpp[List`1_SortSearchComparer#1](~/add/codesnippet/cpp/1c01c0fd-2c33-49f3-8a3d-_1.cpp)]
 [!code-vb[List`1_SortSearchComparer#1](~/add/codesnippet/visualbasic/1c01c0fd-2c33-49f3-8a3d-_1.vb)]
 [!code-cs[List`1_SortSearchComparer#1](~/add/codesnippet/csharp/1c01c0fd-2c33-49f3-8a3d-_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> is <see langword="null" />, and the default comparer <see cref="System.Collections.Generic.Comparer%601.Default%2A" /> cannot find an implementation of the <see cref="System.IComparable%601" /> generic interface or the <see cref="T:System.IComparable" /> interface for type <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (int index, int count, T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(int32 index, int32 count, !T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based starting index of the range to search.</param>
        <param name="count">The length of the range to search.</param>
        <param name="item">The object to locate. The value can be <see langword="null" /> for reference types.</param>
        <param name="comparer">The <see cref="System.Collections.Generic.IComparer%601" /> implementation to use when comparing elements, or <see langword="null" /> to use the default comparer <see cref="System.Collections.Generic.Comparer%601.Default%2A" />.</param>
        <summary>Searches a range of elements in the sorted <see cref="System.Collections.Generic.List%601" /> for an element using the specified comparer and returns the zero-based index of the element.</summary>
        <returns>The zero-based index of <paramref name="item" /> in the sorted <see cref="System.Collections.Generic.List%601" />, if <paramref name="item" /> is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than <paramref name="item" /> or, if there is no larger element, the bitwise complement of <see cref="System.Collections.Generic.List%601.Count%2A" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The comparer customizes how the elements are compared. For example, you can use a <xref:System.Collections.CaseInsensitiveComparer> instance as the comparer to perform case-insensitive string searches.  
  
 If `comparer` is provided, the elements of the <xref:System.Collections.Generic.List%601> are compared to the specified value using the specified <xref:System.Collections.Generic.IComparer%601> implementation.  
  
 If `comparer` is `null`, the default comparer <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName> checks whether type `T` implements the <xref:System.IComparable%601> generic interface and uses that implementation, if available.  If not, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName> checks whether type `T` implements the <xref:System.IComparable> interface.  If type `T` does not implement either interface, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName> throws <xref:System.InvalidOperationException>.  
  
 The <xref:System.Collections.Generic.List%601> must already be sorted according to the comparer implementation; otherwise, the result is incorrect.  
  
 Comparing `null` with any reference type is allowed and does not generate an exception when using the <xref:System.IComparable%601> generic interface. When sorting, `null` is considered to be less than any other object.  
  
 If the <xref:System.Collections.Generic.List%601> contains more than one element with the same value, the method returns only one of the occurrences, and it might return any one of the occurrences, not necessarily the first one.  
  
 If the <xref:System.Collections.Generic.List%601> does not contain the specified value, the method returns a negative integer. You can apply the bitwise complement operation (~) to this negative integer to get the index of the first element that is larger than the search value. When inserting the value into the <xref:System.Collections.Generic.List%601>, this index should be used as the insertion point to maintain the sort order.  
  
 This method is an O(log `n`) operation, where `n` is the number of elements in the range.  
  
   
  
## Examples  
 The following example demonstrates the <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> method overload and the BinarySearch method overload.  
  
 The example defines an alternative comparer for strings named DinoCompare, which implements the `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer<String^>` in Visual C++) generic interface. The comparer works as follows: First, the comparands are tested for `null`, and a null reference is treated as less than a non-null. Second, the string lengths are compared, and the longer string is deemed to be greater. Third, if the lengths are equal, ordinary string comparison is used.  
  
 A <xref:System.Collections.Generic.List%601> of strings is created and populated with the names of five herbivorous dinosaurs and three carnivorous dinosaurs. Within each of the two groups, the names are not in any particular sort order. The list is displayed, the range of herbivores is sorted using the alternate comparer, and the list is displayed again.  
  
 The BinarySearch method overload is then used to search only the range of herbivores for "Brachiosaurus". The string is not found, and the bitwise complement (the ~ operator in C# and Visual C++, `Xor` -1 in Visual Basic) of the negative number returned by the BinarySearch method is used as an index for inserting the new string.  
  
 [!code-cs[List`1_SortSearchComparerRange#1](~/add/codesnippet/csharp/7e13138c-a0f3-4776-9c06-_1.cs)]
 [!code-vb[List`1_SortSearchComparerRange#1](~/add/codesnippet/visualbasic/7e13138c-a0f3-4776-9c06-_1.vb)]
 [!code-cpp[List`1_SortSearchComparerRange#1](~/add/codesnippet/cpp/7e13138c-a0f3-4776-9c06-_1.cpp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than 0.  
  
 -or-  
  
 <paramref name="count" /> is less than 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> and <paramref name="count" /> do not denote a valid range in the <see cref="System.Collections.Generic.List%601" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> is <see langword="null" />, and the default comparer <see cref="System.Collections.Generic.Comparer%601.Default%2A" /> cannot find an implementation of the <see cref="System.IComparable%601" /> generic interface or the <see cref="T:System.IComparable" /> interface for type <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the total number of elements the internal data structure can hold without resizing.</summary>
        <value>The number of elements that the <see cref="System.Collections.Generic.List%601" /> can contain before resizing is required.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Capacity is the number of elements that the <xref:System.Collections.Generic.List%601> can store before resizing is required, whereas <xref:System.Collections.Generic.List%601.Count%2A> is the number of elements that are actually in the <xref:System.Collections.Generic.List%601>.  
  
 Capacity is always greater than or equal to <xref:System.Collections.Generic.List%601.Count%2A>. If <xref:System.Collections.Generic.List%601.Count%2A> exceeds Capacity while adding elements, the capacity is increased by automatically reallocating the internal array before copying the old elements and adding the new elements.  
  
 If the capacity is significantly larger than the count and you want to reduce the memory used by the <xref:System.Collections.Generic.List%601>,  you can  decrease capacity by calling the <xref:System.Collections.Generic.List%601.TrimExcess%2A> method or by setting the Capacity property explicitly to a lower value. When the value of Capacity is set explicitly, the internal array is also reallocated to accommodate the specified capacity, and all the elements are copied.  
  
 Retrieving the value of this property is an O(1) operation; setting the property is an O(`n`) operation, where `n` is the new capacity.  
  
   
  
## Examples  
 The following example demonstrates how to check the capacity and count of a <xref:System.Collections.Generic.List%601> that contains a simple business object, and illustrates using the <xref:System.Collections.Generic.List%601.TrimExcess%2A> method to remove extra capacity.  
  
 [!code-cs[System.Collections.Generic.List.CapacityCount#1](~/add/codesnippet/csharp/p-system.collections.gen_1_1.cs)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/add/codesnippet/visualbasic/p-system.collections.gen_1_1.vb)]  
  
 The following example shows the Capacity property at several points in the life of a list. The default constructor is used to create a list of strings with a capacity of 0, and the Capacity property is displayed to demonstrate this. After the <xref:System.Collections.Generic.List%601.Add%2A> method has been used to add several items, the items are listed, and then the Capacity property is displayed again, along with the <xref:System.Collections.Generic.List%601.Count%2A> property, to show that the capacity has been increased as needed.  
  
 The Capacity property is displayed again after the <xref:System.Collections.Generic.List%601.TrimExcess%2A> method is used to reduce the capacity to match the count. Finally, the <xref:System.Collections.Generic.List%601.Clear%2A> method is used to remove all items from the list, and the Capacity and <xref:System.Collections.Generic.List%601.Count%2A> properties are displayed again.  
  
 [!code-cpp[List`1_Class#1](~/add/codesnippet/cpp/p-system.collections.gen_1_2.cpp)]
 [!code-cs[List`1_Class#1](~/add/codesnippet/csharp/p-system.collections.gen_1_2.cs)]
 [!code-fs[List`1_Class#1](~/add/codesnippet/fsharp/p-system.collections.gen_1_2.fs)]
 [!code-vb[List`1_Class#1](~/add/codesnippet/visualbasic/p-system.collections.gen_1_2.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Capacity is set to a value that is less than <see cref="System.Collections.Generic.List%601.Count%2A" />.</exception>
        <exception cref="T:System.OutOfMemoryException">There is not enough memory available on the system.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Removes all elements from the <see cref="System.Collections.Generic.List%601" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Count%2A> is set to 0, and references to other objects from elements of the collection are also released.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> remains unchanged. To reset the capacity of the <xref:System.Collections.Generic.List%601>, call the <xref:System.Collections.Generic.List%601.TrimExcess%2A> method or set the <xref:System.Collections.Generic.List%601.Capacity%2A> property directly. Decreasing the capacity reallocates memory and copies all the elements in the <xref:System.Collections.Generic.List%601>. Trimming an empty <xref:System.Collections.Generic.List%601> sets the capacity of the <xref:System.Collections.Generic.List%601> to the default capacity.  
  
 This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 The following example demonstrates the Clear method and various other properties and methods of the <xref:System.Collections.Generic.List%601> generic class. The Clear method is used at the end of the program, to remove all items from the list, and the <xref:System.Collections.Generic.List%601.Capacity%2A> and <xref:System.Collections.Generic.List%601.Count%2A> properties are then displayed.  
  
 [!code-cpp[List`1_Class#1](~/add/codesnippet/cpp/m-system.collections.gen_35_1.cpp)]
 [!code-cs[List`1_Class#1](~/add/codesnippet/csharp/m-system.collections.gen_35_1.cs)]
 [!code-fs[List`1_Class#1](~/add/codesnippet/fsharp/m-system.collections.gen_35_1.fs)]
 [!code-vb[List`1_Class#1](~/add/codesnippet/visualbasic/m-system.collections.gen_35_1.vb)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">The object to locate in the <see cref="System.Collections.Generic.List%601" />. The value can be <see langword="null" /> for reference types.</param>
        <summary>Determines whether an element is in the <see cref="System.Collections.Generic.List%601" />.</summary>
        <returns>
          <see langword="true" /> if <paramref name="item" /> is found in the <see cref="System.Collections.Generic.List%601" />; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method determines equality by using the default equality comparer, as defined by the object's implementation of the <xref:System.IEquatable%601.Equals%2A?displayProperty=fullName> method for `T` (the type of values in the list).  
  
 This method performs a linear search; therefore, this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 The following example demonstrates the Contains and <xref:System.Collections.Generic.List%601.Exists%2A> methods on a <xref:System.Collections.Generic.List%601> that contains a simple business object that implements <xref:System.IEquatable%601.Equals%2A>.  
  
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/add/codesnippet/visualbasic/m-system.collections.gen_38_1.vb)]
 [!code-cs[System.Collections.Generic.List.ContainsExists#1](~/add/codesnippet/csharp/m-system.collections.gen_38_1.cs)]  
  
 The following example contains a list of complex objects of type `Cube`. The `Cube` class implements the <xref:System.IEquatable%601.Equals%2A?displayProperty=fullName> method so that two cubes are considered equal if their dimensions are the same. In this example, the Contains method returns `true`, because a cube that has the specified dimensions is already in the collection.  
  
 [!code-vb[System.Collections.Generic.List.Contains#1](~/add/codesnippet/visualbasic/m-system.collections.gen_38_2.vb)]
 [!code-cs[System.Collections.Generic.List.Contains#1](~/add/codesnippet/csharp/m-system.collections.gen_38_2.cs)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;TOutput&gt; ConvertAll&lt;TOutput&gt; (Converter&lt;T,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!!TOutput&gt; ConvertAll&lt;TOutput&gt;(class System.Converter`2&lt;!T, !!TOutput&gt; converter) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="converter" Type="System.Converter&lt;T,TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">To be added.</typeparam>
        <param name="converter">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="System.Collections.Generic.List%601" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
        <summary>Copies the entire <see cref="System.Collections.Generic.List%601" /> to a compatible one-dimensional array, starting at the beginning of the target array.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method uses <xref:System.Array.Copy%2A?displayProperty=fullName> to copy the elements.  
  
 The elements are copied to the <xref:System.Array> in the same order in which the enumerator iterates through the <xref:System.Collections.Generic.List%601>.  
  
 This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 The following example demonstrates all three overloads of the CopyTo method. A <xref:System.Collections.Generic.List%601> of strings is created and populated with 5 strings. An empty string array of 15 elements is created, and the CopyTo method overload is used to copy all the elements of the list to the array beginning at the first element of the array. The [CopyTo(T\[\], Int32)](assetId:///M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)?qualifyHint=False&autoUpgrade=False) method overload is used to copy all the elements of the list to the array beginning at array index 6 (leaving index 5 empty). Finally, the [CopyTo(Int32, T\[\], Int32, Int32)](assetId:///M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=False) method overload is used to copy 3 elements from the list, beginning with index 2, to the array beginning at array index 12 (leaving index 11 empty). The contents of the array are then displayed.  
  
 [!code-vb[List`1_CopyTo#1](~/add/codesnippet/visualbasic/m-system.collections.gen_28_1.vb)]
 [!code-cpp[List`1_CopyTo#1](~/add/codesnippet/cpp/m-system.collections.gen_28_1.cpp)]
 [!code-cs[List`1_CopyTo#1](~/add/codesnippet/csharp/m-system.collections.gen_28_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The number of elements in the source <see cref="System.Collections.Generic.List%601" /> is greater than the number of elements that the destination <paramref name="array" /> can contain.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="System.Collections.Generic.List%601" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
        <param name="arrayIndex">The zero-based index in `array` at which copying begins.</param>
        <summary>Copies the entire <see cref="System.Collections.Generic.List%601" /> to a compatible one-dimensional array, starting at the specified index of the target array.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method uses <xref:System.Array.Copy%2A?displayProperty=fullName> to copy the elements.  
  
 The elements are copied to the <xref:System.Array> in the same order in which the enumerator iterates through the <xref:System.Collections.Generic.List%601>.  
  
 This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 The following example demonstrates all three overloads of the <xref:System.Collections.Generic.List%601.CopyTo%2A> method. A <xref:System.Collections.Generic.List%601> of strings is created and populated with 5 strings. An empty string array of 15 elements is created, and the [CopyTo(T\[\])](assetId:///M:System.Collections.Generic.List`1.CopyTo(`0[])?qualifyHint=False&autoUpgrade=False) method overload is used to copy all the elements of the list to the array beginning at the first element of the array. The CopyTo method overload is used to copy all the elements of the list to the array beginning at array index 6 (leaving index 5 empty). Finally, the [CopyTo(Int32, T\[\], Int32, Int32)](assetId:///M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=False) method overload is used to copy 3 elements from the list, beginning with index 2, to the array beginning at array index 12 (leaving index 11 empty). The contents of the array are then displayed.  
  
 [!code-vb[List`1_CopyTo#1](~/add/codesnippet/visualbasic/m-system.collections.gen_47_1.vb)]
 [!code-cpp[List`1_CopyTo#1](~/add/codesnippet/cpp/m-system.collections.gen_47_1.cpp)]
 [!code-cs[List`1_CopyTo#1](~/add/codesnippet/csharp/m-system.collections.gen_47_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> is less than 0.</exception>
        <exception cref="T:System.ArgumentException">The number of elements in the source <see cref="System.Collections.Generic.List%601" /> is greater than the available space from <paramref name="arrayIndex" /> to the end of the destination <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int index, T[] array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 index, !T[] array, int32 arrayIndex, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based index in the source <see cref="System.Collections.Generic.List%601" /> at which copying begins.</param>
        <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="System.Collections.Generic.List%601" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
        <param name="arrayIndex">The zero-based index in `array` at which copying begins.</param>
        <param name="count">The number of elements to copy.</param>
        <summary>Copies a range of elements from the <see cref="System.Collections.Generic.List%601" /> to a compatible one-dimensional array, starting at the specified index of the target array.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method uses <xref:System.Array.Copy%2A?displayProperty=fullName> to copy the elements.  
  
 The elements are copied to the <xref:System.Array> in the same order in which the enumerator iterates through the <xref:System.Collections.Generic.List%601>.  
  
 This method is an O(`n`) operation, where `n` is `count`.  
  
   
  
## Examples  
 The following example demonstrates all three overloads of the <xref:System.Collections.Generic.List%601.CopyTo%2A> method. A <xref:System.Collections.Generic.List%601> of strings is created and populated with 5 strings. An empty string array of 15 elements is created, and the [CopyTo(T\[\])](assetId:///M:System.Collections.Generic.List`1.CopyTo(`0[])?qualifyHint=False&autoUpgrade=False) method overload is used to copy all the elements of the list to the array beginning at the first element of the array. The [CopyTo(T\[\], Int32)](assetId:///M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)?qualifyHint=False&autoUpgrade=False) method overload is used to copy all the elements of the list to the array beginning at array index 6 (leaving index 5 empty). Finally, the CopyTo method overload is used to copy 3 elements from the list, beginning with index 2, to the array beginning at array index 12 (leaving index 11 empty). The contents of the array are then displayed.  
  
 [!code-vb[List`1_CopyTo#1](~/add/codesnippet/visualbasic/ca43b909-3076-4e7e-b85c-_1.vb)]
 [!code-cpp[List`1_CopyTo#1](~/add/codesnippet/cpp/ca43b909-3076-4e7e-b85c-_1.cpp)]
 [!code-cs[List`1_CopyTo#1](~/add/codesnippet/csharp/ca43b909-3076-4e7e-b85c-_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than 0.  
  
 -or-  
  
 <paramref name="arrayIndex" /> is less than 0.  
  
 -or-  
  
 <paramref name="count" /> is less than 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> is equal to or greater than the <see cref="System.Collections.Generic.List%601.Count%2A" /> of the source <see cref="System.Collections.Generic.List%601" />.  
  
 -or-  
  
 The number of elements from <paramref name="index" /> to the end of the source <see cref="System.Collections.Generic.List%601" /> is greater than the available space from <paramref name="arrayIndex" /> to the end of the destination <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of elements contained in the <see cref="System.Collections.Generic.List%601" />.</summary>
        <value>The number of elements contained in the <see cref="System.Collections.Generic.List%601" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A> is the number of elements that the <xref:System.Collections.Generic.List%601> can store before resizing is required. Count is the number of elements that are actually in the <xref:System.Collections.Generic.List%601>.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> is always greater than or equal to Count. If Count exceeds <xref:System.Collections.Generic.List%601.Capacity%2A> while adding elements, the capacity is increased by automatically reallocating the internal array before copying the old elements and adding the new elements.  
  
 Retrieving the value of this property is an O(1) operation.  
  
   
  
## Examples  
 The following example demonstrates how to check the capacity and count of a  <xref:System.Collections.Generic.List%601> that contains a simple business object, and illustrates using the <xref:System.Collections.Generic.List%601.TrimExcess%2A> method to remove extra capacity.  
  
 [!code-cs[System.Collections.Generic.List.CapacityCount#1](~/add/codesnippet/csharp/p-system.collections.gen_10_1.cs)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/add/codesnippet/visualbasic/p-system.collections.gen_10_1.vb)]  
  
 The following example shows the value of the Count property at various points in the life of a list. After the list has been created and populated and its elements displayed, the <xref:System.Collections.Generic.List%601.Capacity%2A> and Count properties are displayed. These properties are displayed again after the <xref:System.Collections.Generic.List%601.TrimExcess%2A> method has been called, and again after the contents of the list are cleared.  
  
 [!code-cpp[List`1_Class#1](~/add/codesnippet/cpp/p-system.collections.gen_10_2.cpp)]
 [!code-cs[List`1_Class#1](~/add/codesnippet/csharp/p-system.collections.gen_10_2.cs)]
 [!code-fs[List`1_Class#1](~/add/codesnippet/fsharp/p-system.collections.gen_10_2.fs)]
 [!code-vb[List`1_Class#1](~/add/codesnippet/visualbasic/p-system.collections.gen_10_2.vb)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public bool Exists (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Exists(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">The <see cref="System.Predicate%601" /> delegate that defines the conditions of the elements to search for.</param>
        <summary>Determines whether the <see cref="System.Collections.Generic.List%601" /> contains elements that match the conditions defined by the specified predicate.</summary>
        <returns>
          <see langword="true" /> if the <see cref="System.Collections.Generic.List%601" /> contains one or more elements that match the conditions defined by the specified predicate; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.  The elements of the current <xref:System.Collections.Generic.List%601> are individually passed to the <xref:System.Predicate%601> delegate, and processing is stopped when a match is found.  
  
 This method performs a linear search; therefore, this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 The following example demonstrates the <xref:System.Collections.Generic.List%601.Contains%2A> and Existsmethods on a <xref:System.Collections.Generic.List%601> that contains a simple business object that implements <xref:System.IEquatable%601.Equals%2A>.  
  
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/add/codesnippet/visualbasic/m-system.collections.gen_9_1.vb)]
 [!code-cs[System.Collections.Generic.List.ContainsExists#1](~/add/codesnippet/csharp/m-system.collections.gen_9_1.cs)]  
  
 The following example demonstrates the Exists method and several other methods that use the <xref:System.Predicate%601> generic delegate.  
  
 A <xref:System.Collections.Generic.List%601> of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus". The example also defines a search predicate method named `EndsWithSaurus`, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".  
  
 The <xref:System.Collections.Generic.List%601.Find%2A>, <xref:System.Collections.Generic.List%601.FindLast%2A>, and <xref:System.Collections.Generic.List%601.FindAll%2A> methods are used to search the list with the search predicate method, and then the <xref:System.Collections.Generic.List%601.RemoveAll%2A> method is used to remove all entries ending with "saurus".  
  
 Finally, the Exists method is called. It traverses the list from the beginning, passing each element in turn to the `EndsWithSaurus` method. The search stops and the method returns `true` if the `EndsWithSaurus` method returns `true` for any element. The Exists method returns `false` because all such elements have been removed.  
  
> [!NOTE]
>  In C# and Visual Basic, it is not necessary to create the `Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly. These languages infer the correct delegate from context and create it automatically.  
  
 [!code-cs[List`1_FindEtAl#1](~/add/codesnippet/csharp/m-system.collections.gen_9_2.cs)]
 [!code-cpp[List`1_FindEtAl#1](~/add/codesnippet/cpp/m-system.collections.gen_9_2.cpp)]
 [!code-vb[List`1_FindEtAl#1](~/add/codesnippet/visualbasic/m-system.collections.gen_9_2.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public T Find (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Find(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">The <see cref="System.Predicate%601" /> delegate that defines the conditions of the element to search for.</param>
        <summary>Searches for an element that matches the conditions defined by the specified predicate, and returns the first occurrence within the entire <see cref="System.Collections.Generic.List%601" />.</summary>
        <returns>The first element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.  The elements of the current <xref:System.Collections.Generic.List%601> are individually passed to the <xref:System.Predicate%601> delegate, moving forward in the <xref:System.Collections.Generic.List%601>, starting with the first element and ending with the last element.  Processing is stopped when a match is found.  
  
> [!IMPORTANT]
>  When searching a list containing value types, make sure the default value for the type does not satisfy the search predicate. Otherwise, there is no way to distinguish between a default value indicating that no match was found and a list element that happens to have the default value for the type. If the default value satisfies the search predicate, use the <xref:System.Collections.Generic.List%601.FindIndex%2A> method instead.  
  
 This method performs a linear search; therefore, this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 The following example demonstrates the Find method on a <xref:System.Collections.Generic.List%601> that contains a simple complex object.  
  
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/add/codesnippet/visualbasic/m-system.collections.gen_36_1.vb)]
 [!code-cs[System.Collections.Generic.List.ContainsExists#1](~/add/codesnippet/csharp/m-system.collections.gen_36_1.cs)]  
  
 The following example demonstrates the find methods for the <xref:System.Collections.Generic.List%601> class. The example for the <xref:System.Collections.Generic.List%601> class contains `book` objects, of class `Book`, using the data from the [Sample XML File: Books (LINQ to XML)](../Topic/Sample%20XML%20File:%20Books%20\(LINQ%20to%20XML\)2.md). The `FillList` method in the example uses [LINQ to XML](../Topic/LINQ%20to%20XML.md) to parse the values from the XML to property values of the `book` objects.  
  
 The following table describes the examples provided for the find methods.  
  
|Method|Example|  
|------------|-------------|  
|Find|Finds a book by an ID using the `IDToFind` predicate delegate.<br /><br /> C# example uses an anonymous delegate.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Find all books that whose `Genre` property is "Computer" using the `FindComputer` predicate delegate.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Finds the last book in the collection that has a publish date before 2001, using the `PubBefore2001` predicate delegate.<br /><br /> C# example uses an anonymous delegate.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Finds the index of first computer book using the `FindComputer` predicate delegate.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Finds the index of the last computer book using the `FindComputer` predicate delegate.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Finds the index of first computer book in the second half of the collection, using the `FindComputer` predicate delegate.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Finds the index of last computer book in the second half of the collection, using the `FindComputer` predicate delegate.|  
  
 [!code-cs[List`1_Find_Methods#1](~/add/codesnippet/csharp/m-system.collections.gen_36_2.cs)]
 [!code-vb[List`1_Find_Methods#1](~/add/codesnippet/visualbasic/m-system.collections.gen_36_2.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindAll">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; FindAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; FindAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">The <see cref="System.Predicate%601" /> delegate that defines the conditions of the elements to search for.</param>
        <summary>Retrieves all the elements that match the conditions defined by the specified predicate.</summary>
        <returns>A <see cref="System.Collections.Generic.List%601" /> containing all the elements that match the conditions defined by the specified predicate, if found; otherwise, an empty <see cref="System.Collections.Generic.List%601" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.  The elements of the current <xref:System.Collections.Generic.List%601> are individually passed to the <xref:System.Predicate%601> delegate, and the elements that match the conditions are saved in the returned <xref:System.Collections.Generic.List%601>.  
  
 This method performs a linear search; therefore, this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 The following example demonstrates the find methods for the <xref:System.Collections.Generic.List%601> class. The example for the <xref:System.Collections.Generic.List%601> class contains `book` objects, of class `Book`, using the data from the [Sample XML File: Books (LINQ to XML)](../Topic/Sample%20XML%20File:%20Books%20\(LINQ%20to%20XML\)2.md). The `FillList` method in the example uses [LINQ to XML](../Topic/LINQ%20to%20XML.md) to parse the values from the XML to property values of the `book` objects.  
  
 The following table describes the examples provided for the find methods.  
  
|Method|Example|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Finds a book by an ID using the `IDToFind` predicate delegate.<br /><br /> C# example uses an anonymous delegate.|  
|FindAll|Find all books that whose `Genre` property is "Computer" using the `FindComputer` predicate delegate.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Finds the last book in the collection that has a publish date before 2001, using the `PubBefore2001` predicate delegate.<br /><br /> C# example uses an anonymous delegate.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Finds the index of first computer book using the `FindComputer` predicate delegate.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Finds the index of the last computer book using the `FindComputer` predicate delegate.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Finds the index of first computer book in the second half of the collection, using the `FindComputer` predicate delegate.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Finds the index of last computer book in the second half of the collection, using the `FindComputer` predicate delegate.|  
  
 [!code-cs[List`1_Find_Methods#1](~/add/codesnippet/csharp/m-system.collections.gen_5_1.cs)]
 [!code-vb[List`1_Find_Methods#1](~/add/codesnippet/visualbasic/m-system.collections.gen_5_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">The <see cref="System.Predicate%601" /> delegate that defines the conditions of the element to search for.</param>
        <summary>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the entire <see cref="System.Collections.Generic.List%601" />.</summary>
        <returns>The zero-based index of the first occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Collections.Generic.List%601> is searched forward starting at the first element and ending at the last element.  
  
 The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.  The elements of the current <xref:System.Collections.Generic.List%601> are individually passed to the <xref:System.Predicate%601> delegate. The delegate has the signature:  
  
```c#  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 This method performs a linear search; therefore, this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 The following example defines an `Employee` class with two fields, `Name` and `Id`. It also defines an `EmployeeSearch` class with a single method, `StartsWith`, that indicates whether the `Employee.Name` field starts with a specified substring that is supplied to the `EmployeeSearch` class constructor. Note  the signature of this method  
  
<CodeContentPlaceHolder>2</CodeContentPlaceHolder>  
<CodeContentPlaceHolder>3</CodeContentPlaceHolder>  
 corresponds to the signature of the delegate that can be passed to the <xref:System.Collections.Generic.List%601.FindIndex%2A> method. The example instantiates a `List<Employee>` object, adds a number of `Employee` objets to it, and then calls the <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> method twice  to search the entire collection , the first time for the first `Employee` object whose `Name` field begins with "J", and the second time for the first `Employee` object whose `Name` field begins with "Ju".  
  
 [!code-cs[System.Collections.Generic.List.FindIndex#2](~/add/codesnippet/csharp/m-system.collections.gen_33_1.cs)]
 [!code-vb[System.Collections.Generic.List.FindIndex#2](~/add/codesnippet/visualbasic/m-system.collections.gen_33_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">The zero-based starting index of the search.</param>
        <param name="match">The <see cref="System.Predicate%601" /> delegate that defines the conditions of the element to search for.</param>
        <summary>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the <see cref="System.Collections.Generic.List%601" /> that extends from the specified index to the last element.</summary>
        <returns>The zero-based index of the first occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Collections.Generic.List%601> is searched forward starting at `startIndex` and ending at the last element.  
  
 The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.  The elements of the current <xref:System.Collections.Generic.List%601> are individually passed to the <xref:System.Predicate%601> delegate. The delegate has the signature:  
  
<CodeContentPlaceHolder>0</CodeContentPlaceHolder>  
<CodeContentPlaceHolder>1</CodeContentPlaceHolder>  
 This method performs a linear search; therefore, this method is an O(`n`) operation, where `n` is the number of elements from `startIndex` to the end of the <xref:System.Collections.Generic.List%601>.  
  
   
  
## Examples  
 The following example defines an `Employee` class with two fields, `Name` and `Id`. It also defines an `EmployeeSearch` class with a single method, `StartsWith`, that indicates whether the `Employee.Name` field starts with a specified substring that is supplied to the `EmployeeSearch` class constructor. Note  the signature of this method  
  
```c#  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 corresponds to the signature of the delegate that can be passed to the <xref:System.Collections.Generic.List%601.FindIndex%2A> method. The example instantiates a `List<Employee>` object, adds a number of `Employee` objets to it, and then calls the <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> method twice  to search the collection starting with its fifth member (that is, the member at index 4). The first time, it searches for the first `Employee` object whose `Name` field begins with "J"; the second time, it searches for the first `Employee` object whose `Name` field begins with "Ju".  
  
 [!code-cs[System.Collections.Generic.List.FindIndex#3](~/add/codesnippet/csharp/m-system.collections.gen_26_1.cs)]
 [!code-vb[System.Collections.Generic.List.FindIndex#3](~/add/codesnippet/visualbasic/m-system.collections.gen_26_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is outside the range of valid indexes for the <see cref="System.Collections.Generic.List%601" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">The zero-based starting index of the search.</param>
        <param name="count">The number of elements in the section to search.</param>
        <param name="match">The <see cref="System.Predicate%601" /> delegate that defines the conditions of the element to search for.</param>
        <summary>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the <see cref="System.Collections.Generic.List%601" /> that starts at the specified index and contains the specified number of elements.</summary>
        <returns>The zero-based index of the first occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Collections.Generic.List%601> is searched forward starting at `startIndex` and ending at `startIndex` plus `count` minus 1, if `count` is greater than 0.  
  
 The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.  The elements of the current <xref:System.Collections.Generic.List%601> are individually passed to the <xref:System.Predicate%601> delegate. The delegate has the signature:  
  
```c#  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 This method performs a linear search; therefore, this method is an O(`n`) operation, where `n` is `count`.  
  
   
  
## Examples  
 The following example defines an `Employee` class with two fields, `Name` and `Id`. It also defines an `EmployeeSearch` class with a single method, `StartsWith`, that indicates whether the `Employee.Name` field starts with a specified substring that is supplied to the `EmployeeSearch` class constructor. Note  the signature of this method  
  
```c#  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 corresponds to the signature of the delegate that can be passed to the <xref:System.Collections.Generic.List%601.FindIndex%2A> method. The example instantiates a `List<Employee>` object, adds a number of `Employee` objets to it, and then calls the FindIndex method twice  to search the entire collection (that is, the members from index 0 to index <xref:System.Collections.Generic.List%601.Count%2A> - 1). The first time, it searches for the first `Employee` object whose `Name` field begins with "J"; the second time, it searches for the first `Employee` object whose `Name` field begins with "Ju".  
  
 [!code-cs[System.Collections.Generic.List.FindIndex#1](~/add/codesnippet/csharp/06b1ebc4-7a82-481a-bbb2-_1.cs)]
 [!code-vb[System.Collections.Generic.List.FindIndex#1](~/add/codesnippet/visualbasic/06b1ebc4-7a82-481a-bbb2-_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is outside the range of valid indexes for the <see cref="System.Collections.Generic.List%601" />.  
  
 -or-  
  
 <paramref name="count" /> is less than 0.  
  
 -or-  
  
 <paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in the <see cref="System.Collections.Generic.List%601" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindLast">
      <MemberSignature Language="C#" Value="public T FindLast (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T FindLast(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">The <see cref="System.Predicate%601" /> delegate that defines the conditions of the element to search for.</param>
        <summary>Searches for an element that matches the conditions defined by the specified predicate, and returns the last occurrence within the entire <see cref="System.Collections.Generic.List%601" />.</summary>
        <returns>The last element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.  The elements of the current <xref:System.Collections.Generic.List%601> are individually passed to the <xref:System.Predicate%601> delegate, moving backward in the <xref:System.Collections.Generic.List%601>, starting with the last element and ending with the first element.  Processing is stopped when a match is found.  
  
> [!IMPORTANT]
>  When searching a list containing value types, make sure the default value for the type does not satisfy the search predicate. Otherwise, there is no way to distinguish between a default value indicating that no match was found and a list element that happens to have the default value for the type. If the default value satisfies the search predicate, use the <xref:System.Collections.Generic.List%601.FindLastIndex%2A> method instead.  
  
 This method performs a linear search; therefore, this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 The following example demonstrates the find methods for the <xref:System.Collections.Generic.List%601> class. The example for the <xref:System.Collections.Generic.List%601> class contains `book` objects, of class `Book`, using the data from the [Sample XML File: Books (LINQ to XML)](../Topic/Sample%20XML%20File:%20Books%20\(LINQ%20to%20XML\)2.md). The `FillList` method in the example uses [LINQ to XML](../Topic/LINQ%20to%20XML.md) to parse the values from the XML to property values of the `book` objects.  
  
 The following table describes the examples provided for the find methods.  
  
|Method|Example|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Finds a book by an ID using the `IDToFind` predicate delegate.<br /><br /> C# example uses an anonymous delegate.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Find all books that whose `Genre` property is "Computer" using the `FindComputer` predicate delegate.|  
|FindLast|Finds the last book in the collection that has a publish date before 2001, using the `PubBefore2001` predicate delegate.<br /><br /> C# example uses an anonymous delegate.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Finds the index of first computer book using the `FindComputer` predicate delegate.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Finds the index of the last computer book using the `FindComputer` predicate delegate.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Finds the index of first computer book in the second half of the collection, using the `FindComputer` predicate delegate.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Finds the index of last computer book in the second half of the collection, using the `FindComputer` predicate delegate.|  
  
 [!code-cs[List`1_Find_Methods#1](~/add/codesnippet/csharp/m-system.collections.gen_43_1.cs)]
 [!code-vb[List`1_Find_Methods#1](~/add/codesnippet/visualbasic/m-system.collections.gen_43_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">The <see cref="System.Predicate%601" /> delegate that defines the conditions of the element to search for.</param>
        <summary>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the entire <see cref="System.Collections.Generic.List%601" />.</summary>
        <returns>The zero-based index of the last occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Collections.Generic.List%601> is searched backward starting at the last element and ending at the first element.  
  
 The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.  The elements of the current <xref:System.Collections.Generic.List%601> are individually passed to the <xref:System.Predicate%601> delegate.  
  
 This method performs a linear search; therefore, this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 The following example demonstrates the find methods for the <xref:System.Collections.Generic.List%601> class. The example for the <xref:System.Collections.Generic.List%601> class contains `book` objects, of class `Book`, using the data from the [Sample XML File: Books (LINQ to XML)](../Topic/Sample%20XML%20File:%20Books%20\(LINQ%20to%20XML\)2.md). The `FillList` method in the example uses [LINQ to XML](../Topic/LINQ%20to%20XML.md) to parse the values from the XML to property values of the `book` objects.  
  
 The following table describes the examples provided for the find methods.  
  
|Method|Example|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Finds a book by an ID using the `IDToFind` predicate delegate.<br /><br /> C# example uses an anonymous delegate.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Find all books that whose `Genre` property is "Computer" using the `FindComputer` predicate delegate.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Finds the last book in the collection that has a publish date before 2001, using the `PubBefore2001` predicate delegate.<br /><br /> C# example uses an anonymous delegate.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Finds the index of first computer book using the `FindComputer` predicate delegate.|  
|FindLastIndex|Finds the index of the last computer book using the `FindComputer` predicate delegate.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Finds the index of first computer book in the second half of the collection, using the `FindComputer` predicate delegate.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Finds the index of last computer book in the second half of the collection, using the `FindComputer` predicate delegate.|  
  
 [!code-cs[List`1_Find_Methods#1](~/add/codesnippet/csharp/m-system.collections.gen_29_1.cs)]
 [!code-vb[List`1_Find_Methods#1](~/add/codesnippet/visualbasic/m-system.collections.gen_29_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">The zero-based starting index of the backward search.</param>
        <param name="match">The <see cref="System.Predicate%601" /> delegate that defines the conditions of the element to search for.</param>
        <summary>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the <see cref="System.Collections.Generic.List%601" /> that extends from the first element to the specified index.</summary>
        <returns>The zero-based index of the last occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Collections.Generic.List%601> is searched backward starting at `startIndex` and ending at the first element.  
  
 The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.  The elements of the current <xref:System.Collections.Generic.List%601> are individually passed to the <xref:System.Predicate%601> delegate.  
  
 This method performs a linear search; therefore, this method is an O(`n`) operation, where `n` is the number of elements from the beginning of the <xref:System.Collections.Generic.List%601> to `startIndex`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is outside the range of valid indexes for the <see cref="System.Collections.Generic.List%601" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">The zero-based starting index of the backward search.</param>
        <param name="count">The number of elements in the section to search.</param>
        <param name="match">The <see cref="System.Predicate%601" /> delegate that defines the conditions of the element to search for.</param>
        <summary>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the <see cref="System.Collections.Generic.List%601" /> that contains the specified number of elements and ends at the specified index.</summary>
        <returns>The zero-based index of the last occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Collections.Generic.List%601> is searched backward starting at `startIndex` and ending at `startIndex` minus `count` plus 1, if `count` is greater than 0.  
  
 The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.  The elements of the current <xref:System.Collections.Generic.List%601> are individually passed to the <xref:System.Predicate%601> delegate.  
  
 This method performs a linear search; therefore, this method is an O(`n`) operation, where `n` is `count`.  
  
   
  
## Examples  
 The following example demonstrates the find methods for the <xref:System.Collections.Generic.List%601> class. The example for the <xref:System.Collections.Generic.List%601> class contains `book` objects, of class `Book`, using the data from the [Sample XML File: Books (LINQ to XML)](../Topic/Sample%20XML%20File:%20Books%20\(LINQ%20to%20XML\)2.md). The `FillList` method in the example uses [LINQ to XML](../Topic/LINQ%20to%20XML.md) to parse the values from the XML to property values of the `book` objects.  
  
 The following table describes the examples provided for the find methods.  
  
|Method|Example|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Finds a book by an ID using the `IDToFind` predicate delegate.<br /><br /> C# example uses an anonymous delegate.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Find all books that whose `Genre` property is "Computer" using the `FindComputer` predicate delegate.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Finds the last book in the collection that has a publish date before 2001, using the `PubBefore2001` predicate delegate.<br /><br /> C# example uses an anonymous delegate.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Finds the index of first computer book using the `FindComputer` predicate delegate.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Finds the index of the last computer book using the `FindComputer` predicate delegate.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Finds the index of first computer book in the second half of the collection, using the `FindComputer` predicate delegate.|  
|FindLastIndex|Finds the index of last computer book in the second half of the collection, using the `FindComputer` predicate delegate.|  
  
 [!code-cs[List`1_Find_Methods#1](~/add/codesnippet/csharp/5c29f59b-43bb-4aee-9cd3-_1.cs)]
 [!code-vb[List`1_Find_Methods#1](~/add/codesnippet/visualbasic/5c29f59b-43bb-4aee-9cd3-_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is outside the range of valid indexes for the <see cref="System.Collections.Generic.List%601" />.  
  
 -or-  
  
 <paramref name="count" /> is less than 0.  
  
 -or-  
  
 <paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in the <see cref="System.Collections.Generic.List%601" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach">
      <MemberSignature Language="C#" Value="public void ForEach (Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ForEach(class System.Action`1&lt;!T&gt; action) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="action">The <see cref="System.Action%601" /> delegate to perform on each element of the <see cref="System.Collections.Generic.List%601" />.</param>
        <summary>Performs the specified action on each element of the <see cref="System.Collections.Generic.List%601" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Action%601> is a delegate to a method that performs an action on the object passed to it.  The elements of the current <xref:System.Collections.Generic.List%601> are individually passed to the <xref:System.Action%601> delegate.  
  
 This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Modifying the underlying collection in the body of the <xref:System.Action%601> delegate is not supported and causes undefined behavior.  
  
   
  
## Examples  
 The following example demonstrates the use of the <xref:System.Action%601> delegate to print the contents of a <xref:System.Collections.Generic.List%601> object. In this example the `Print` method is used to display the contents of the list to the console.  
  
> [!NOTE]
>  In addition to displaying the contents using the `Print` method, the C# example demonstrates the use of  to display the results to the console.  
  
 [!code-cs[System.Action_PrintExample#01](~/add/codesnippet/csharp/m-system.collections.gen_42_1.cs)]
 [!code-vb[System.Action_PrintExample#01](~/add/codesnippet/visualbasic/m-system.collections.gen_42_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">An element in the collection has been modified.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.List`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an enumerator that iterates through the <see cref="System.Collections.Generic.List%601" />.</summary>
        <returns>A <see cref="System.Collections.Generic.List%601.Enumerator" /> for the <see cref="System.Collections.Generic.List%601" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The `foreach` statement of the C# language (`for each` in C++, `For Each` in Visual Basic) hides the complexity of the enumerators. Therefore, using `foreach` is recommended, instead of directly manipulating the enumerator.  
  
 Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.  
  
 Initially, the enumerator is positioned before the first element in the collection. At this position, the <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> property is undefined. Therefore, you must call the <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> method to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.Generic.List%601.Enumerator.Current%2A>.  
  
 The <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> property returns the same object until <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> is called. <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> sets <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> to the next element.  
  
 If <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> returns `false`. When the enumerator is at this position, subsequent calls to <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> also return `false`. If the last call to <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> returned `false`, <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> is undefined. You cannot set <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> to the first element of the collection again; you must create a new enumerator instance instead.  
  
 An enumerator remains valid as long as the collection remains unchanged. If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.  
  
 The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure. To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.  To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.  
  
 Default implementations of collections in the <xref:System.Collections.Generic?displayProperty=fullName> namespace are not synchronized.  
  
 This method is an O(1) operation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRange">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; GetRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; GetRange(int32 index, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based <see cref="System.Collections.Generic.List%601" /> index at which the range starts.</param>
        <param name="count">The number of elements in the range.</param>
        <summary>Creates a shallow copy of a range of elements in the source <see cref="System.Collections.Generic.List%601" />.</summary>
        <returns>A shallow copy of a range of elements in the source <see cref="System.Collections.Generic.List%601" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A shallow copy of a collection of reference types, or a subset of that collection, contains only the references to the elements of the collection. The objects themselves are not copied. The references in the new list point to the same objects as the references in the original list.  
  
 A shallow copy of a collection of value types, or a subset of that collection, contains the elements of the collection. However, if the elements of the collection contain references to other objects, those objects are not copied. The references in the elements of the new collection point to the same objects as the references in the elements of the original collection.  
  
 In contrast, a deep copy of a collection copies the elements and everything directly or indirectly referenced by the elements.  
  
 This method is an O(`n`) operation, where `n` is `count`.  
  
   
  
## Examples  
 The following example demonstrates the GetRange method and other methods of the <xref:System.Collections.Generic.List%601> class that act on ranges. At the end of the example, the GetRange method is used to get three items from the list, beginning with index location 2. The <xref:System.Collections.Generic.List%601.ToArray%2A> method is called on the resulting <xref:System.Collections.Generic.List%601>, creating an array of three elements. The elements of the array are displayed.  
  
 [!code-vb[List`1_Ranges#1](~/add/codesnippet/visualbasic/m-system.collections.gen_22_1.vb)]
 [!code-cpp[List`1_Ranges#1](~/add/codesnippet/cpp/m-system.collections.gen_22_1.cpp)]
 [!code-cs[List`1_Ranges#1](~/add/codesnippet/csharp/m-system.collections.gen_22_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than 0.  
  
 -or-  
  
 <paramref name="count" /> is less than 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> and <paramref name="count" /> do not denote a valid range of elements in the <see cref="System.Collections.Generic.List%601" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(!T item) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">The object to locate in the <see cref="System.Collections.Generic.List%601" />. The value can be <see langword="null" /> for reference types.</param>
        <summary>Searches for the specified object and returns the zero-based index of the first occurrence within the entire <see cref="System.Collections.Generic.List%601" />.</summary>
        <returns>The zero-based index of the first occurrence of <paramref name="item" /> within the entire <see cref="System.Collections.Generic.List%601" />, if found; otherwise, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Collections.Generic.List%601> is searched forward starting at the first element and ending at the last element.  
  
 This method determines equality using the default equality comparer <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=fullName> for `T`, the type of values in the list.  
  
 This method performs a linear search; therefore, this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 The following example demonstrates all three overloads of the <xref:System.Collections.Generic.List%601.IndexOf%2A> method. A <xref:System.Collections.Generic.List%601> of strings is created, with one entry that appears twice, at index location 0 and index location 5. The IndexOf method overload searches the list from the beginning, and finds the first occurrence of the string. The <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> method overload is used to search the list beginning with index location 3 and continuing to the end of the list, and finds the second occurrence of the string. Finally, the <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> method overload is used to search a range of two entries, beginning at index location two; it returns –1 because there are no instances of the search string in that range.  
  
 [!code-cpp[List`1_IndexOf#1](~/add/codesnippet/cpp/m-system.collections.gen_40_1.cpp)]
 [!code-vb[List`1_IndexOf#1](~/add/codesnippet/visualbasic/m-system.collections.gen_40_1.vb)]
 [!code-cs[List`1_IndexOf#1](~/add/codesnippet/csharp/m-system.collections.gen_40_1.cs)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">The object to locate in the <see cref="System.Collections.Generic.List%601" />. The value can be <see langword="null" /> for reference types.</param>
        <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        <summary>Searches for the specified object and returns the zero-based index of the first occurrence within the range of elements in the <see cref="System.Collections.Generic.List%601" /> that extends from the specified index to the last element.</summary>
        <returns>The zero-based index of the first occurrence of <paramref name="item" /> within the range of elements in the <see cref="System.Collections.Generic.List%601" /> that extends from <paramref name="index" /> to the last element, if found; otherwise, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Collections.Generic.List%601> is searched forward starting at `index` and ending at the last element.  
  
 This method determines equality using the default equality comparer <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=fullName> for `T`, the type of values in the list.  
  
 This method performs a linear search; therefore, this method is an O(`n`) operation, where `n` is the number of elements from `index` to the end of the <xref:System.Collections.Generic.List%601>.  
  
   
  
## Examples  
 The following example demonstrates all three overloads of the <xref:System.Collections.Generic.List%601.IndexOf%2A> method. A <xref:System.Collections.Generic.List%601> of strings is created, with one entry that appears twice, at index location 0 and index location 5. The <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> method overload searches the list from the beginning, and finds the first occurrence of the string. The IndexOf method overload is used to search the list beginning with index location 3 and continuing to the end of the list, and finds the second occurrence of the string. Finally, the <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> method overload is used to search a range of two entries, beginning at index location two; it returns –1 because there are no instances of the search string in that range.  
  
 [!code-cpp[List`1_IndexOf#1](~/add/codesnippet/cpp/m-system.collections.gen_4_1.cpp)]
 [!code-vb[List`1_IndexOf#1](~/add/codesnippet/visualbasic/m-system.collections.gen_4_1.vb)]
 [!code-cs[List`1_IndexOf#1](~/add/codesnippet/csharp/m-system.collections.gen_4_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is outside the range of valid indexes for the <see cref="System.Collections.Generic.List%601" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">The object to locate in the <see cref="System.Collections.Generic.List%601" />. The value can be <see langword="null" /> for reference types.</param>
        <param name="index">The zero-based starting index of the search. 0 (zero) is valid in an empty list.</param>
        <param name="count">The number of elements in the section to search.</param>
        <summary>Searches for the specified object and returns the zero-based index of the first occurrence within the range of elements in the <see cref="System.Collections.Generic.List%601" /> that starts at the specified index and contains the specified number of elements.</summary>
        <returns>The zero-based index of the first occurrence of <paramref name="item" /> within the range of elements in the <see cref="System.Collections.Generic.List%601" /> that starts at <paramref name="index" /> and contains <paramref name="count" /> number of elements, if found; otherwise, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Collections.Generic.List%601> is searched forward starting at `index` and ending at `index` plus `count` minus 1, if `count` is greater than 0.  
  
 This method determines equality using the default equality comparer <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=fullName> for `T`, the type of values in the list.  
  
 This method performs a linear search; therefore, this method is an O(`n`) operation, where `n` is `count`.  
  
   
  
## Examples  
 The following example demonstrates all three overloads of the <xref:System.Collections.Generic.List%601.IndexOf%2A> method. A <xref:System.Collections.Generic.List%601> of strings is created, with one entry that appears twice, at index location 0 and index location 5. The <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> method overload searches the list from the beginning, and finds the first occurrence of the string. The <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> method overload is used to search the list beginning with index location 3 and continuing to the end of the list, and finds the second occurrence of the string. Finally, the IndexOf method overload is used to search a range of two entries, beginning at index location two; it returns –1 because there are no instances of the search string in that range.  
  
 [!code-cpp[List`1_IndexOf#1](~/add/codesnippet/cpp/m-system.collections.gen_34_1.cpp)]
 [!code-vb[List`1_IndexOf#1](~/add/codesnippet/visualbasic/m-system.collections.gen_34_1.vb)]
 [!code-cs[List`1_IndexOf#1](~/add/codesnippet/csharp/m-system.collections.gen_34_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is outside the range of valid indexes for the <see cref="System.Collections.Generic.List%601" />.  
  
 -or-  
  
 <paramref name="count" /> is less than 0.  
  
 -or-  
  
 <paramref name="index" /> and <paramref name="count" /> do not specify a valid section in the <see cref="System.Collections.Generic.List%601" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public void Insert (int index, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, !T item) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based index at which `item` should be inserted.</param>
        <param name="item">The object to insert. The value can be <see langword="null" /> for reference types.</param>
        <summary>Inserts an element into the <see cref="System.Collections.Generic.List%601" /> at the specified index.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> accepts `null` as a valid value for reference types and allows duplicate elements.  
  
 If <xref:System.Collections.Generic.List%601.Count%2A> already equals <xref:System.Collections.Generic.List%601.Capacity%2A>, the capacity of the <xref:System.Collections.Generic.List%601> is increased by automatically reallocating the internal array, and the existing elements are copied to the new array before the new element is added.  
  
 If `index` is equal to <xref:System.Collections.Generic.List%601.Count%2A>, `item` is added to the end of <xref:System.Collections.Generic.List%601>.  
  
 This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 The following example demonstrates how to add, remove, and insert a simple business object in a <xref:System.Collections.Generic.List%601>.  
  
 [!code-cs[System.Collections.Generic.List.AddRemoveInsert#1](~/add/codesnippet/csharp/m-system.collections.gen_10_1.cs)]
 [!code-fs[System.Collections.Generic.List.AddRemoveInsert#1](~/add/codesnippet/fsharp/m-system.collections.gen_10_1.fs)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/add/codesnippet/visualbasic/m-system.collections.gen_10_1.vb)]  
  
 The following example demonstrates the Insert method, along with various other properties and methods of the <xref:System.Collections.Generic.List%601> generic class. After the list is created, elements are added. The Insert method is used to insert an item into the middle of the list. The item inserted is a duplicate, which is later removed using the <xref:System.Collections.Generic.List%601.Remove%2A> method.  
  
 [!code-cpp[List`1_Class#1](~/add/codesnippet/cpp/m-system.collections.gen_10_2.cpp)]
 [!code-cs[List`1_Class#1](~/add/codesnippet/csharp/m-system.collections.gen_10_2.cs)]
 [!code-fs[List`1_Class#1](~/add/codesnippet/fsharp/m-system.collections.gen_10_2.fs)]
 [!code-vb[List`1_Class#1](~/add/codesnippet/visualbasic/m-system.collections.gen_10_2.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than 0.  
  
 -or-  
  
 <paramref name="index" /> is greater than <see cref="System.Collections.Generic.List%601.Count%2A" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InsertRange">
      <MemberSignature Language="C#" Value="public void InsertRange (int index, System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertRange(int32 index, class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based index at which the new elements should be inserted.</param>
        <param name="collection">The collection whose elements should be inserted into the <see cref="System.Collections.Generic.List%601" />. The collection itself cannot be <see langword="null" />, but it can contain elements that are <see langword="null" />, if type `T` is a reference type.</param>
        <summary>Inserts the elements of a collection into the <see cref="System.Collections.Generic.List%601" /> at the specified index.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> accepts `null` as a valid value for reference types and allows duplicate elements.  
  
 If the new <xref:System.Collections.Generic.List%601.Count%2A> (the current <xref:System.Collections.Generic.List%601.Count%2A> plus the size of the collection) will be greater than <xref:System.Collections.Generic.List%601.Capacity%2A>, the capacity of the <xref:System.Collections.Generic.List%601> is increased by automatically reallocating the internal array to accommodate the new elements, and the existing elements are copied to the new array before the new elements are added.  
  
 If `index` is equal to <xref:System.Collections.Generic.List%601.Count%2A>, the elements are added to the end of <xref:System.Collections.Generic.List%601>.  
  
 The order of the elements in the collection is preserved in the <xref:System.Collections.Generic.List%601>.  
  
 This method is an O(`n` + `m`) operation, where `n` is the number of elements to be added and `m` is <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 The following example demonstrates InsertRange method and various other methods of the <xref:System.Collections.Generic.List%601> class that act on ranges. After the list has been created and populated with the names of several peaceful plant-eating dinosaurs, the InsertRange method is used to insert an array of three ferocious meat-eating dinosaurs into the list, beginning at index location 3.  
  
 [!code-vb[List`1_Ranges#1](~/add/codesnippet/visualbasic/a382465b-6189-4dde-bde5-_1.vb)]
 [!code-cpp[List`1_Ranges#1](~/add/codesnippet/cpp/a382465b-6189-4dde-bde5-_1.cpp)]
 [!code-cs[List`1_Ranges#1](~/add/codesnippet/csharp/a382465b-6189-4dde-bde5-_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than 0.  
  
 -or-  
  
 <paramref name="index" /> is greater than <see cref="System.Collections.Generic.List%601.Count%2A" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based index of the element to get or set.</param>
        <summary>Gets or sets the element at the specified index.</summary>
        <value>The element at the specified index.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> accepts `null` as a valid value for reference types and allows duplicate elements.  
  
 This property provides the ability to access a specific element in the collection by using the following syntax: `myCollection[index]`.  
  
 Retrieving the value of this property is an O(1) operation; setting the property is also an O(1) operation.  
  
   
  
## Examples  
 The example in this section demonstrates the Item property (the indexer in C#) and various other properties and methods of the <xref:System.Collections.Generic.List%601> generic class. After the list has been created and populated using the <xref:System.Collections.Generic.List%601.Add%2A> method, an element is retrieved and displayed using the Item property. (For an example that uses the Item property to set the value of a list element, see <xref:System.Collections.Generic.List%601.AsReadOnly%2A>.)  
  
> [!NOTE]
>  Visual Basic, C#, and C++ all have syntax for accessing the Item property without using its name. Instead, the variable containing the <xref:System.Collections.Generic.List%601> is used as if it were an array.  
  
 The C# language uses the  keyword to define the indexers instead of implementing the Item property. Visual Basic implements Item as a default property, which provides the same indexing functionality.  
  
 [!code-cs[List`1_Class#2](~/add/codesnippet/csharp/p-system.collections.gen_12_1.cs)]
 [!code-vb[List`1_Class#2](~/add/codesnippet/visualbasic/p-system.collections.gen_12_1.vb)]  
[!code-cs[List`1_Class#3](~/add/codesnippet/csharp/p-system.collections.gen_12_2.cs)]
[!code-vb[List`1_Class#3](~/add/codesnippet/visualbasic/p-system.collections.gen_12_2.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than 0.  
  
 -or-  
  
 <paramref name="index" /> is equal to or greater than <see cref="System.Collections.Generic.List%601.Count%2A" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">The object to locate in the <see cref="System.Collections.Generic.List%601" />. The value can be <see langword="null" /> for reference types.</param>
        <summary>Searches for the specified object and returns the zero-based index of the last occurrence within the entire <see cref="System.Collections.Generic.List%601" />.</summary>
        <returns>The zero-based index of the last occurrence of <paramref name="item" /> within the entire the <see cref="System.Collections.Generic.List%601" />, if found; otherwise, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Collections.Generic.List%601> is searched backward starting at the last element and ending at the first element.  
  
 This method determines equality using the default equality comparer <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=fullName> for `T`, the type of values in the list.  
  
 This method performs a linear search; therefore, this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 The following example demonstrates all three overloads of the <xref:System.Collections.Generic.List%601.LastIndexOf%2A> method. A <xref:System.Collections.Generic.List%601> of strings is created, with one entry that appears twice, at index location 0 and index location 5. The LastIndexOf method overload searches the entire list from the end, and finds the second occurrence of the string. The <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> method overload is used to search the list backward beginning with index location 3 and continuing to the beginning of the list, so it finds the first occurrence of the string in the list. Finally, the <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> method overload is used to search a range of four entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns –1 because there are no instances of the search string in that range.  
  
 [!code-vb[List`1_LastIndexOf#1](~/add/codesnippet/visualbasic/m-system.collections.gen_46_1.vb)]
 [!code-cpp[List`1_LastIndexOf#1](~/add/codesnippet/cpp/m-system.collections.gen_46_1.cpp)]
 [!code-cs[List`1_LastIndexOf#1](~/add/codesnippet/csharp/m-system.collections.gen_46_1.cs)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">The object to locate in the <see cref="System.Collections.Generic.List%601" />. The value can be <see langword="null" /> for reference types.</param>
        <param name="index">The zero-based starting index of the backward search.</param>
        <summary>Searches for the specified object and returns the zero-based index of the last occurrence within the range of elements in the <see cref="System.Collections.Generic.List%601" /> that extends from the first element to the specified index.</summary>
        <returns>The zero-based index of the last occurrence of <paramref name="item" /> within the range of elements in the <see cref="System.Collections.Generic.List%601" /> that extends from the first element to <paramref name="index" />, if found; otherwise, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Collections.Generic.List%601> is searched backward starting at `index` and ending at the first element.  
  
 This method determines equality using the default equality comparer <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=fullName> for `T`, the type of values in the list.  
  
 This method performs a linear search; therefore, this method is an O(`n`) operation, where `n` is the number of elements from the beginning of the <xref:System.Collections.Generic.List%601> to `index`.  
  
   
  
## Examples  
 The following example demonstrates all three overloads of the <xref:System.Collections.Generic.List%601.LastIndexOf%2A> method. A <xref:System.Collections.Generic.List%601> of strings is created, with one entry that appears twice, at index location 0 and index location 5. The <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> method overload searches the entire list from the end, and finds the second occurrence of the string. The LastIndexOf method overload is used to search the list backward beginning with index location 3 and continuing to the beginning of the list, so it finds the first occurrence of the string in the list. Finally, the <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> method overload is used to search a range of four entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns –1 because there are no instances of the search string in that range.  
  
 [!code-vb[List`1_LastIndexOf#1](~/add/codesnippet/visualbasic/m-system.collections.gen_8_1.vb)]
 [!code-cpp[List`1_LastIndexOf#1](~/add/codesnippet/cpp/m-system.collections.gen_8_1.cpp)]
 [!code-cs[List`1_LastIndexOf#1](~/add/codesnippet/csharp/m-system.collections.gen_8_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is outside the range of valid indexes for the <see cref="System.Collections.Generic.List%601" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">The object to locate in the <see cref="System.Collections.Generic.List%601" />. The value can be <see langword="null" /> for reference types.</param>
        <param name="index">The zero-based starting index of the backward search.</param>
        <param name="count">The number of elements in the section to search.</param>
        <summary>Searches for the specified object and returns the zero-based index of the last occurrence within the range of elements in the <see cref="System.Collections.Generic.List%601" /> that contains the specified number of elements and ends at the specified index.</summary>
        <returns>The zero-based index of the last occurrence of <paramref name="item" /> within the range of elements in the <see cref="System.Collections.Generic.List%601" /> that contains <paramref name="count" /> number of elements and ends at <paramref name="index" />, if found; otherwise, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Collections.Generic.List%601> is searched backward starting at `index` and ending at `index` minus `count` plus 1, if `count` is greater than 0.  
  
 This method determines equality using the default equality comparer <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=fullName> for `T`, the type of values in the list.  
  
 This method performs a linear search; therefore, this method is an O(`n`) operation, where `n` is `count`.  
  
   
  
## Examples  
 The following example demonstrates all three overloads of the <xref:System.Collections.Generic.List%601.LastIndexOf%2A> method. A <xref:System.Collections.Generic.List%601> of strings is created, with one entry that appears twice, at index location 0 and index location 5. The <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> method overload searches the entire list from the end, and finds the second occurrence of the string. The <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> method overload is used to search the list backward beginning with index location 3 and continuing to the beginning of the list, so it finds the first occurrence of the string in the list. Finally, the LastIndexOf method overload is used to search a range of 4 entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns –1 because there are no instances of the search string in that range.  
  
 [!code-vb[List`1_LastIndexOf#1](~/add/codesnippet/visualbasic/m-system.collections.gen_23_1.vb)]
 [!code-cpp[List`1_LastIndexOf#1](~/add/codesnippet/cpp/m-system.collections.gen_23_1.cpp)]
 [!code-cs[List`1_LastIndexOf#1](~/add/codesnippet/csharp/m-system.collections.gen_23_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is outside the range of valid indexes for the <see cref="System.Collections.Generic.List%601" />.  
  
 -or-  
  
 <paramref name="count" /> is less than 0.  
  
 -or-  
  
 <paramref name="index" /> and <paramref name="count" /> do not specify a valid section in the <see cref="System.Collections.Generic.List%601" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">The object to remove from the <see cref="System.Collections.Generic.List%601" />. The value can be <see langword="null" /> for reference types.</param>
        <summary>Removes the first occurrence of a specific object from the <see cref="System.Collections.Generic.List%601" />.</summary>
        <returns>
          <see langword="true" /> if <paramref name="item" /> is successfully removed; otherwise, <see langword="false" />.  This method also returns <see langword="false" /> if <paramref name="item" /> was not found in the <see cref="System.Collections.Generic.List%601" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If type `T` implements the <xref:System.IEquatable%601> generic interface, the equality comparer is the <xref:System.IEquatable%601.Equals%2A> method of that interface; otherwise, the default equality comparer is <xref:System.Object.Equals%2A?displayProperty=fullName>.  
  
 This method performs a linear search; therefore, this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 The following example demonstrates how to add, remove, and insert a simple business object in a <xref:System.Collections.Generic.List%601>.  
  
 [!code-cs[System.Collections.Generic.List.AddRemoveInsert#1](~/add/codesnippet/csharp/m-system.collections.gen_48_1.cs)]
 [!code-fs[System.Collections.Generic.List.AddRemoveInsert#1](~/add/codesnippet/fsharp/m-system.collections.gen_48_1.fs)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/add/codesnippet/visualbasic/m-system.collections.gen_48_1.vb)]  
  
 The following example demonstrates Remove method. Several properties and methods of the <xref:System.Collections.Generic.List%601> generic class are used to add, insert, and search the list. After these operations, the list contains a duplicate. The Remove method is used to remove the first instance of the duplicate item, and the contents are displayed. The Remove method always removes the first instance it encounters.  
  
 [!code-cpp[List`1_Class#1](~/add/codesnippet/cpp/m-system.collections.gen_48_2.cpp)]
 [!code-cs[List`1_Class#1](~/add/codesnippet/csharp/m-system.collections.gen_48_2.cs)]
 [!code-fs[List`1_Class#1](~/add/codesnippet/fsharp/m-system.collections.gen_48_2.fs)]
 [!code-vb[List`1_Class#1](~/add/codesnippet/visualbasic/m-system.collections.gen_48_2.vb)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public int RemoveAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 RemoveAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">The <see cref="System.Predicate%601" /> delegate that defines the conditions of the elements to remove.</param>
        <summary>Removes all the elements that match the conditions defined by the specified predicate.</summary>
        <returns>The number of elements removed from the <see cref="System.Collections.Generic.List%601" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.  The elements of the current <xref:System.Collections.Generic.List%601> are individually passed to the <xref:System.Predicate%601> delegate, and the elements that match the conditions are removed from the <xref:System.Collections.Generic.List%601>.  
  
 This method performs a linear search; therefore, this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 The following example demonstrates the RemoveAll method and several other methods that use the <xref:System.Predicate%601> generic delegate.  
  
 A <xref:System.Collections.Generic.List%601> of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus". The example also defines a search predicate method named `EndsWithSaurus`, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".  
  
 The <xref:System.Collections.Generic.List%601.Find%2A>, <xref:System.Collections.Generic.List%601.FindLast%2A>, and <xref:System.Collections.Generic.List%601.FindAll%2A> methods are used to search the list with the search predicate method.  
  
 The RemoveAll method is used to remove all entries ending with "saurus". It traverses the list from the beginning, passing each element in turn to the `EndsWithSaurus` method. The element is removed if the `EndsWithSaurus` method returns `true`.  
  
> [!NOTE]
>  In C# and Visual Basic, it is not necessary to create the `Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly. These languages infer the correct delegate from context, and create it automatically.  
  
 Finally, the <xref:System.Collections.Generic.List%601.Exists%2A> method verifies that there are no strings in the list that end with "saurus".  
  
 [!code-cs[List`1_FindEtAl#1](~/add/codesnippet/csharp/m-system.collections.gen_11_1.cs)]
 [!code-cpp[List`1_FindEtAl#1](~/add/codesnippet/cpp/m-system.collections.gen_11_1.cpp)]
 [!code-vb[List`1_FindEtAl#1](~/add/codesnippet/visualbasic/m-system.collections.gen_11_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based index of the element to remove.</param>
        <summary>Removes the element at the specified index of the <see cref="System.Collections.Generic.List%601" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 When you call RemoveAt to remove an item, the remaining items in the list are renumbered to replace the removed item. For example, if you remove the item at index 3, the item at index 4 is moved to the 3 position. In addition, the number of items in the list (as represented by the <xref:System.Collections.Generic.List%601.Count%2A> property) is reduced by 1.  
  
 This method is an O(`n`) operation, where `n` is (<xref:System.Collections.Generic.List%601.Count%2A> - `index`).  
  
   
  
## Examples  
 The following example demonstrates how to add, remove, and insert a simple business object in a <xref:System.Collections.Generic.List%601>.  
  
 [!code-cs[System.Collections.Generic.List.AddRemoveInsert#1](~/add/codesnippet/csharp/m-system.collections.gen_24_1.cs)]
 [!code-fs[System.Collections.Generic.List.AddRemoveInsert#1](~/add/codesnippet/fsharp/m-system.collections.gen_24_1.fs)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/add/codesnippet/visualbasic/m-system.collections.gen_24_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than 0.  
  
 -or-  
  
 <paramref name="index" /> is equal to or greater than <see cref="System.Collections.Generic.List%601.Count%2A" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public void RemoveRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveRange(int32 index, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based starting index of the range of elements to remove.</param>
        <param name="count">The number of elements to remove.</param>
        <summary>Removes a range of elements from the <see cref="System.Collections.Generic.List%601" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The items are removed and all the elements following them in the <xref:System.Collections.Generic.List%601> have their indexes reduced by `count`.  
  
 This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 The following example demonstrates the RemoveRange method and various other methods of the <xref:System.Collections.Generic.List%601> class that act on ranges. After the list has been created and modified, the RemoveRange method is used to remove two elements from the list, beginning at index location 2.  
  
 [!code-vb[List`1_Ranges#1](~/add/codesnippet/visualbasic/m-system.collections.gen_2_1.vb)]
 [!code-cpp[List`1_Ranges#1](~/add/codesnippet/cpp/m-system.collections.gen_2_1.cpp)]
 [!code-cs[List`1_Ranges#1](~/add/codesnippet/csharp/m-system.collections.gen_2_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than 0.  
  
 -or-  
  
 <paramref name="count" /> is less than 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> and <paramref name="count" /> do not denote a valid range of elements in the <see cref="System.Collections.Generic.List%601" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reverses the order of the elements in the entire <see cref="System.Collections.Generic.List%601" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method uses <xref:System.Array.Reverse%2A?displayProperty=fullName> to reverse the order of the elements.  
  
 This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 The following example demonstrates both overloads of the Reverse method. The example creates a <xref:System.Collections.Generic.List%601> of strings and adds six strings. The Reverse method overload is used to reverse the list, and then the <xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29> method overload is used to reverse the middle of the list, beginning with element 1 and encompassing four elements.  
  
 [!code-cpp[List`1_Reverse#1](~/add/codesnippet/cpp/m-system.collections.gen_32_1.cpp)]
 [!code-vb[List`1_Reverse#1](~/add/codesnippet/visualbasic/m-system.collections.gen_32_1.vb)]
 [!code-cs[List`1_Reverse#1](~/add/codesnippet/csharp/m-system.collections.gen_32_1.cs)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse(int32 index, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based starting index of the range to reverse.</param>
        <param name="count">The number of elements in the range to reverse.</param>
        <summary>Reverses the order of the elements in the specified range.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method uses <xref:System.Array.Reverse%2A?displayProperty=fullName> to reverse the order of the elements.  
  
 This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 The following example demonstrates both overloads of the <xref:System.Collections.Generic.List%601.Reverse%2A> method. The example creates a <xref:System.Collections.Generic.List%601> of strings and adds six strings. The <xref:System.Collections.Generic.List%601.Reverse> method overload is used to reverse the list, and then the Reverse method overload is used to reverse the middle of the list, beginning with element 1 and encompassing four elements.  
  
 [!code-cpp[List`1_Reverse#1](~/add/codesnippet/cpp/m-system.collections.gen_19_1.cpp)]
 [!code-vb[List`1_Reverse#1](~/add/codesnippet/visualbasic/m-system.collections.gen_19_1.vb)]
 [!code-cs[List`1_Reverse#1](~/add/codesnippet/csharp/m-system.collections.gen_19_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than 0.  
  
 -or-  
  
 <paramref name="count" /> is less than 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> and <paramref name="count" /> do not denote a valid range of elements in the <see cref="System.Collections.Generic.List%601" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sorts the elements in the entire <see cref="System.Collections.Generic.List%601" /> using the default comparer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method uses the default comparer <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName> for type `T` to determine the order of list elements. The <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName> property checks whether type `T` implements the <xref:System.IComparable%601> generic interface and uses that implementation, if available.  If not, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName> checks whether type `T` implements the <xref:System.IComparable> interface.  If type `T` does not implement either interface, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName> throws an <xref:System.InvalidOperationException>.  
  
 This method uses the <xref:System.Array.Sort%2A?displayProperty=fullName> method, which applies the introspective sort as follows:  
  
-   If the partition size is fewer than 16 elements, it uses an insertion sort algorithm.  
  
-   If the number of partitions exceeds 2 \* LogN, where *N* is the range of the input array, it uses a Heapsort algorithm.  
  
-   Otherwise, it uses a Quicksort algorithm.  
  
 This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.  
  
 On average, this method is an O(`n` log `n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>; in the worst case it is an O(`n` ^ 2) operation.  
  
   
  
## Examples  
 The following example adds some names to a `List<String>` object, displays the list in unsorted order, calls the Sort method, and then displays the sorted list.  
  
 [!code-cs[System.Collections.Generic.List.Sort#2](~/add/codesnippet/csharp/m-system.collections.gen_45_1.cs)]
 [!code-vb[System.Collections.Generic.List.Sort#2](~/add/codesnippet/visualbasic/m-system.collections.gen_45_1.vb)]  
  
 The following code demonstrates the Sort and <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> method overloads on a simple business object. Calling the Sort method results in the use of the default comparer for the Part type, and the <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> method is implemented by using an anonymous method.  
  
 [!code-cs[System.Collections.Generic.List.Sort#1](~/add/codesnippet/csharp/m-system.collections.gen_45_2.cs)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/add/codesnippet/visualbasic/m-system.collections.gen_45_2.vb)]  
  
 The following example demonstrates the Sort method overload and the <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> method overload. A <xref:System.Collections.Generic.List%601> of strings is created and populated with four strings, in no particular order. The list is displayed, sorted, and displayed again.  
  
 The <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> method overload is then used to search for two strings that are not in the list, and the <xref:System.Collections.Generic.List%601.Insert%2A> method is used to insert them. The return value of the <xref:System.Collections.Generic.List%601.BinarySearch%2A> method is negative in each case, because the strings are not in the list. Taking the bitwise complement (the ~ operator in C# and Visual C++, `Xor` -1 in Visual Basic) of this negative number produces the index of the first element in the list that is larger than the search string, and inserting at this location preserves the sort order. The second search string is larger than any element in the list, so the insertion position is at the end of the list.  
  
 [!code-cpp[List`1_SortSearch#1](~/add/codesnippet/cpp/m-system.collections.gen_45_3.cpp)]
 [!code-cs[List`1_SortSearch#1](~/add/codesnippet/csharp/m-system.collections.gen_45_3.cs)]
 [!code-vb[List`1_SortSearch#1](~/add/codesnippet/visualbasic/m-system.collections.gen_45_3.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The default comparer <see cref="System.Collections.Generic.Comparer%601.Default%2A" /> cannot find an implementation of the <see cref="System.IComparable%601" /> generic interface or the <see cref="T:System.IComparable" /> interface for type <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">The <see cref="System.Collections.Generic.IComparer%601" /> implementation to use when comparing elements, or <see langword="null" /> to use the default comparer <see cref="System.Collections.Generic.Comparer%601.Default%2A" />.</param>
        <summary>Sorts the elements in the entire <see cref="System.Collections.Generic.List%601" /> using the specified comparer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If `comparer` is provided, the elements of the <xref:System.Collections.Generic.List%601> are sorted using the specified <xref:System.Collections.Generic.IComparer%601> implementation.  
  
 If `comparer` is `null`, the default comparer <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName> checks whether type `T` implements the <xref:System.IComparable%601> generic interface and uses that implementation, if available.  If not, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName> checks whether type `T` implements the <xref:System.IComparable> interface.  If type `T` does not implement either interface, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName> throws an <xref:System.InvalidOperationException>.  
  
 This method uses the <xref:System.Array.Sort%2A?displayProperty=fullName> method, which applies the introspective sort as follows:  
  
-   If the partition size is fewer than 16 elements, it uses an insertion sort algorithm.  
  
-   If the number of partitions exceeds 2 \* LogN, where *N* is the range of the input array, it uses a Heapsort algorithm.  
  
-   Otherwise, it uses a Quicksort algorithm.  
  
 This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.  
  
 On average, this method is an O(`n` log `n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>; in the worst case it is an O(`n` ^ 2) operation.  
  
   
  
## Examples  
 The following example demonstrates the Sort method overload and the <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> method overload.  
  
 The example defines an alternative comparer for strings named DinoCompare, which implements the `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer\<String^>` in Visual C++) generic interface. The comparer works as follows: First, the comparands are tested for `null`, and a null reference is treated as less than a non-null. Second, the string lengths are compared, and the longer string is deemed to be greater. Third, if the lengths are equal, ordinary string comparison is used.  
  
 A <xref:System.Collections.Generic.List%601> of strings is created and populated with four strings, in no particular order. The list is displayed, sorted using the alternate comparer, and displayed again.  
  
 The <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> method overload is then used to search for several strings that are not in the list, employing the alternate comparer. The <xref:System.Collections.Generic.List%601.Insert%2A> method is used to insert the strings. These two methods are located in the function named `SearchAndInsert`, along with code to take the bitwise complement (the ~ operator in C# and Visual C++, `Xor` -1 in Visual Basic) of the negative number returned by <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> and use it as an index for inserting the new string.  
  
 [!code-cpp[List`1_SortSearchComparer#1](~/add/codesnippet/cpp/59ae9e01-f7fb-45aa-8255-_1.cpp)]
 [!code-vb[List`1_SortSearchComparer#1](~/add/codesnippet/visualbasic/59ae9e01-f7fb-45aa-8255-_1.vb)]
 [!code-cs[List`1_SortSearchComparer#1](~/add/codesnippet/csharp/59ae9e01-f7fb-45aa-8255-_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> is <see langword="null" />, and the default comparer <see cref="System.Collections.Generic.Comparer%601.Default%2A" /> cannot find implementation of the <see cref="System.IComparable%601" /> generic interface or the <see cref="T:System.IComparable" /> interface for type <paramref name="T" />.</exception>
        <exception cref="T:System.ArgumentException">The implementation of <paramref name="comparer" /> caused an error during the sort. For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Comparison`1&lt;!T&gt; comparison) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparison">The <see cref="System.Comparison%601" /> to use when comparing elements.</param>
        <summary>Sorts the elements in the entire <see cref="System.Collections.Generic.List%601" /> using the specified <see cref="System.Comparison%601" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If `comparison` is provided, the elements of the <xref:System.Collections.Generic.List%601> are sorted using the method represented by the delegate.  
  
 If `comparison` is `null`, an <xref:System.ArgumentNullException> is thrown.  
  
 This method uses <xref:System.Array.Sort%2A?displayProperty=fullName>, which applies the introspective sort as follows:  
  
-   If the partition size is fewer than 16 elements, it uses an insertion sort algorithm  
  
-   If the number of partitions exceeds 2 * LogN, where N is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.  
  
-   Otherwise, it uses a Quicksort algorithm.  
  
 This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.  
  
 On average, this method is an O(`n` log `n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>; in the worst case it is an O(`n` ^ 2) operation.  
  
   
  
## Examples  
 The following code demonstrates the <xref:System.Collections.Generic.List%601.Sort%2A> and Sort method overloads on a simple business object. Calling the <xref:System.Collections.Generic.List%601.Sort%2A> method results in the use of the default comparer for the Part type, and the Sort method is implemented using an anonymous method.  
  
 [!code-cs[System.Collections.Generic.List.Sort#1](~/add/codesnippet/csharp/m-system.collections.gen_18_1.cs)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/add/codesnippet/visualbasic/m-system.collections.gen_18_1.vb)]  
  
 The following example demonstrates the Sort method overload.  
  
 The example defines an alternative comparison method for strings, named `CompareDinosByLength`. This method works as follows: First, the comparands are tested for `null`, and a null reference is treated as less than a non-null. Second, the string lengths are compared, and the longer string is deemed to be greater. Third, if the lengths are equal, ordinary string comparison is used.  
  
 A <xref:System.Collections.Generic.List%601> of strings is created and populated with four strings, in no particular order. The list also includes an empty string and a null reference. The list is displayed, sorted using a <xref:System.Comparison%601> generic delegate representing the `CompareDinosByLength` method, and displayed again.  
  
 [!code-cpp[List`1_SortComparison#1](~/add/codesnippet/cpp/m-system.collections.gen_18_2.cpp)]
 [!code-vb[List`1_SortComparison#1](~/add/codesnippet/visualbasic/m-system.collections.gen_18_2.vb)]
 [!code-cs[List`1_SortComparison#1](~/add/codesnippet/csharp/m-system.collections.gen_18_2.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="comparison" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The implementation of <paramref name="comparison" /> caused an error during the sort. For example, <paramref name="comparison" /> might not return 0 when comparing an item with itself.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (int index, int count, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(int32 index, int32 count, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based starting index of the range to sort.</param>
        <param name="count">The length of the range to sort.</param>
        <param name="comparer">The <see cref="System.Collections.Generic.IComparer%601" /> implementation to use when comparing elements, or <see langword="null" /> to use the default comparer <see cref="System.Collections.Generic.Comparer%601.Default%2A" />.</param>
        <summary>Sorts the elements in a range of elements in <see cref="System.Collections.Generic.List%601" /> using the specified comparer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If `comparer` is provided, the elements of the <xref:System.Collections.Generic.List%601> are sorted using the specified <xref:System.Collections.Generic.IComparer%601> implementation.  
  
 If `comparer` is `null`, the default comparer <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName> checks whether type `T` implements the <xref:System.IComparable%601> generic interface and uses that implementation, if available.  If not, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName> checks whether type `T` implements the <xref:System.IComparable> interface.  If type `T` does not implement either interface, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName> throws an <xref:System.InvalidOperationException>.  
  
 This method uses <xref:System.Array.Sort%2A?displayProperty=fullName>, which applies the introspective sort as follows:  
  
-   If the partition size is fewer than 16 elements, it uses an insertion sort algorithm  
  
-   If the number of partitions exceeds 2 * LogN, where N is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.  
  
-   Otherwise, it uses a Quicksort algorithm.  
  
 This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.  
  
 On average, this method is an O(`n` log `n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>; in the worst case it is an O(`n` ^ 2) operation.  
  
   
  
## Examples  
 The following example demonstrates the Sort method overload and the <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> method overload.  
  
 The example defines an alternative comparer for strings named DinoCompare, which implements the `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer<String^>` in Visual C++) generic interface. The comparer works as follows: First, the comparands are tested for `null`, and a null reference is treated as less than a non-null. Second, the string lengths are compared, and the longer string is deemed to be greater. Third, if the lengths are equal, ordinary string comparison is used.  
  
 A <xref:System.Collections.Generic.List%601> of strings is created and populated with the names of five herbivorous dinosaurs and three carnivorous dinosaurs. Within each of the two groups, the names are not in any particular sort order. The list is displayed, the range of herbivores is sorted using the alternate comparer, and the list is displayed again.  
  
 The <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> method overload is then used to search only the range of herbivores for "Brachiosaurus". The string is not found, and the bitwise complement (the ~ operator in C# and Visual C++, `Xor` -1 in Visual Basic) of the negative number returned by the <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> method is used as an index for inserting the new string.  
  
 [!code-cs[List`1_SortSearchComparerRange#1](~/add/codesnippet/csharp/c8cb70d5-254d-4d97-a451-_1.cs)]
 [!code-vb[List`1_SortSearchComparerRange#1](~/add/codesnippet/visualbasic/c8cb70d5-254d-4d97-a451-_1.vb)]
 [!code-cpp[List`1_SortSearchComparerRange#1](~/add/codesnippet/cpp/c8cb70d5-254d-4d97-a451-_1.cpp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is less than 0.  
  
 -or-  
  
 <paramref name="count" /> is less than 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> and <paramref name="count" /> do not specify a valid range in the <see cref="System.Collections.Generic.List%601" />.  
  
 -or-  
  
 The implementation of <paramref name="comparer" /> caused an error during the sort. For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> is <see langword="null" />, and the default comparer <see cref="System.Collections.Generic.Comparer%601.Default%2A" /> cannot find implementation of the <see cref="System.IComparable%601" /> generic interface or the <see cref="T:System.IComparable" /> interface for type <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="System.Collections.Generic.ICollection%601" /> is read-only.</summary>
        <value>
          <see langword="true" /> if the <see cref="System.Collections.Generic.ICollection%601" /> is read-only; otherwise, <see langword="false" />.  In the default implementation of <see cref="System.Collections.Generic.List%601" />, this property always returns <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A collection that is read-only does not allow the addition, removal, or modification of elements after the collection is created.  
  
 A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection; therefore, if changes are made to the underlying collection, the read-only collection reflects those changes.  
  
 Retrieving the value of this property is an O(1) operation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an enumerator that iterates through a collection.</summary>
        <returns>An <see cref="System.Collections.Generic.IEnumerator%601" /> that can be used to iterate through the collection.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The `foreach` statement of the C# language (`for each` in C++, `For Each` in Visual Basic) hides the complexity of the enumerators. Therefore, using `foreach` is recommended, instead of directly manipulating the enumerator.  
  
 Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.  
  
 Initially, the enumerator is positioned before the first element in the collection. At this position, the <xref:System.Collections.Generic.IEnumerator%601.Current%2A> property is undefined. Therefore, you must call the <xref:System.Collections.IEnumerator.MoveNext%2A> method to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.  
  
 The <xref:System.Collections.Generic.IEnumerator%601.Current%2A> property returns the same object until <xref:System.Collections.IEnumerator.MoveNext%2A> is called. <xref:System.Collections.IEnumerator.MoveNext%2A> sets <xref:System.Collections.Generic.IEnumerator%601.Current%2A> to the next element.  
  
 If <xref:System.Collections.IEnumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.IEnumerator.MoveNext%2A> returns `false`. When the enumerator is at this position, subsequent calls to <xref:System.Collections.IEnumerator.MoveNext%2A> also return `false`. If the last call to <xref:System.Collections.IEnumerator.MoveNext%2A> returned `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> is undefined. You cannot set <xref:System.Collections.Generic.IEnumerator%601.Current%2A> to the first element of the collection again; you must create a new enumerator instance instead.  
  
 An enumerator remains valid as long as the collection remains unchanged. If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.  
  
 The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure. To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.  To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.  
  
 Default implementations of collections in the <xref:System.Collections.Generic?displayProperty=fullName> namespace are not synchronized.  
  
 This method is an O(1) operation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.ICollection" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
        <param name="arrayIndex">The zero-based index in `array` at which copying begins.</param>
        <summary>Copies the elements of the <see cref="T:System.Collections.ICollection" /> to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  If the type of the source <xref:System.Collections.ICollection> cannot be cast automatically to the type of the destination `array`, the nongeneric implementations of <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=fullName> throw <xref:System.InvalidCastException>, whereas the generic implementations throw <xref:System.ArgumentException>.  
  
 This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> is less than 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> is multidimensional.  
  
 -or-  
  
 <paramref name="array" /> does not have zero-based indexing.  
  
 -or-  
  
 The number of elements in the source <see cref="T:System.Collections.ICollection" /> is greater than the available space from <paramref name="arrayIndex" /> to the end of the destination <paramref name="array" />.  
  
 -or-  
  
 The type of the source <see cref="T:System.Collections.ICollection" /> cannot be cast automatically to the type of the destination <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe).</summary>
        <value>
          <see langword="true" /> if access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe); otherwise, <see langword="false" />.  In the default implementation of <see cref="System.Collections.Generic.List%601" />, this property always returns <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Default implementations of collections in the <xref:System.Collections.Generic?displayProperty=fullName> namespace are not synchronized.  
  
 Enumerating through a collection is intrinsically not a thread-safe procedure.  In the rare case where enumeration contends with write accesses, you can lock the collection during the entire enumeration.  To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> returns an object that can be used to synchronize access to the <xref:System.Collections.ICollection>. Synchronization is effective only if all threads lock this object before accessing the collection.  
  
 Retrieving the value of this property is an O(1) operation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.</summary>
        <value>An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.  In the default implementation of <see cref="System.Collections.Generic.List%601" />, this property always returns the current instance.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Default implementations of collections in the <xref:System.Collections.Generic?displayProperty=fullName> namespace are not synchronized.  
  
 Enumerating through a collection is intrinsically not a thread-safe procedure.  To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.  To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> returns an object that can be used to synchronize access to the <xref:System.Collections.ICollection>. Synchronization is effective only if all threads lock this object before accessing the collection. The following code shows the use of the <xref:System.Collections.ICollection.SyncRoot%2A> property for C#, C++, and Visual Basic.  
  
```c#  
ICollection ic = ...;  
lock (ic.SyncRoot)   
{  
    // Access the collection.  
}  
```  
  
```vb#  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
    ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try   
{  
    Monitor::Enter(ic->SyncRoot);  
    // Access the collection.  
}  
finally   
{  
    Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 Retrieving the value of this property is an O(1) operation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an enumerator that iterates through a collection.</summary>
        <returns>An <see cref="T:System.Collections.IEnumerator" /> that can be used to iterate through the collection.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The `foreach` statement of the C# language (`for each` in C++, `For Each` in Visual Basic) hides the complexity of the enumerators. Therefore, using `foreach` is recommended, instead of directly manipulating the enumerator.  
  
 Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.  
  
 Initially, the enumerator is positioned before the first element in the collection. <xref:System.Collections.IEnumerator.Reset%2A> also brings the enumerator back to this position.  At this position, the <xref:System.Collections.IEnumerator.Current%2A> property is undefined. Therefore, you must call the <xref:System.Collections.IEnumerator.MoveNext%2A> method to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.IEnumerator.Current%2A>.  
  
 The <xref:System.Collections.IEnumerator.Current%2A> property returns the same object until either <xref:System.Collections.IEnumerator.MoveNext%2A> or <xref:System.Collections.IEnumerator.Reset%2A> is called. <xref:System.Collections.IEnumerator.MoveNext%2A> sets <xref:System.Collections.IEnumerator.Current%2A> to the next element.  
  
 If <xref:System.Collections.IEnumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.IEnumerator.MoveNext%2A> returns `false`. When the enumerator is at this position, subsequent calls to <xref:System.Collections.IEnumerator.MoveNext%2A> also return `false`. If the last call to <xref:System.Collections.IEnumerator.MoveNext%2A> returned `false`, <xref:System.Collections.IEnumerator.Current%2A> is undefined. To set <xref:System.Collections.IEnumerator.Current%2A> to the first element of the collection again, you can call <xref:System.Collections.IEnumerator.Reset%2A> followed by <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 An enumerator remains valid as long as the collection remains unchanged. If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.  
  
 The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.  To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.  To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.  
  
 Default implementations of collections in the <xref:System.Collections.Generic?displayProperty=fullName> namespace are not synchronized.  
  
 This method is an O(1) operation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object item) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">The <see cref="T:System.Object" /> to add to the <see cref="T:System.Collections.IList" />.</param>
        <summary>Adds an item to the <see cref="T:System.Collections.IList" />.</summary>
        <returns>The position into which the new element was inserted.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If <xref:System.Collections.Generic.List%601.Count%2A> is less than <xref:System.Collections.Generic.List%601.Capacity%2A>, this method is an O(1) operation. If the capacity needs to be increased to accommodate the new element, this method becomes an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> is of a type that is not assignable to the <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object item) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">The <see cref="T:System.Object" /> to locate in the <see cref="T:System.Collections.IList" />.</param>
        <summary>Determines whether the <see cref="T:System.Collections.IList" /> contains a specific value.</summary>
        <returns>
          <see langword="true" /> if <paramref name="item" /> is found in the <see cref="T:System.Collections.IList" />; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method determines equality using the default equality comparer <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=fullName> for `T`, the type of values in the list.  
  
 This method performs a linear search; therefore, this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object item) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">The object to locate in the <see cref="T:System.Collections.IList" />.</param>
        <summary>Determines the index of a specific item in the <see cref="T:System.Collections.IList" />.</summary>
        <returns>The index of <paramref name="item" /> if found in the list; otherwise, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method determines equality using the default equality comparer <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=fullName> for `T`, the type of values in the list.  
  
 This method performs a linear search; therefore, this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> is of a type that is not assignable to the <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object item) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based index at which `item` should be inserted.</param>
        <param name="item">The object to insert into the <see cref="T:System.Collections.IList" />.</param>
        <summary>Inserts an item to the <see cref="T:System.Collections.IList" /> at the specified index.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If `index` equals the number of items in the <xref:System.Collections.IList>, then `item` is appended to the end.  
  
 This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is not a valid index in the <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> is of a type that is not assignable to the <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="T:System.Collections.IList" /> has a fixed size.</summary>
        <value>
          <see langword="true" /> if the <see cref="T:System.Collections.IList" /> has a fixed size; otherwise, <see langword="false" />.  In the default implementation of <see cref="System.Collections.Generic.List%601" />, this property always returns <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A collection with a fixed size does not allow the addition or removal of elements after the collection is created, but it allows the modification of existing elements.  
  
 A collection with a fixed size is simply a collection with a wrapper that prevents adding and removing elements; therefore, if changes are made to the underlying collection, including the addition or removal of elements, the fixed-size collection reflects those changes.  
  
 Retrieving the value of this property is an O(1) operation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="T:System.Collections.IList" /> is read-only.</summary>
        <value>
          <see langword="true" /> if the <see cref="T:System.Collections.IList" /> is read-only; otherwise, <see langword="false" />.  In the default implementation of <see cref="System.Collections.Generic.List%601" />, this property always returns <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A collection that is read-only does not allow the addition, removal, or modification of elements after the collection is created.  
  
 A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection; therefore, if changes are made to the underlying collection, the read-only collection reflects those changes.  
  
 Retrieving the value of this property is an O(1) operation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">The zero-based index of the element to get or set.</param>
        <summary>Gets or sets the element at the specified index.</summary>
        <value>The element at the specified index.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The C# language uses the [this](../Topic/this%20\(C%23%20Reference\).md) keyword to define the indexers instead of implementing the IList.Item property. Visual Basic implements IList.Item as a default property, which provides the same indexing functionality.  
  
 Retrieving the value of this property is an O(1) operation; setting the property is also an O(1) operation.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is not a valid index in the <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.ArgumentException">The property is set and <paramref name="value" /> is of a type that is not assignable to the <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object item) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">The object to remove from the <see cref="T:System.Collections.IList" />.</param>
        <summary>Removes the first occurrence of a specific object from the <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method determines equality using the default equality comparer <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=fullName> for `T`, the type of values in the list.  
  
 This method performs a linear search; therefore, this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> is of a type that is not assignable to the <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copies the elements of the <see cref="System.Collections.Generic.List%601" /> to a new array.</summary>
        <returns>An array containing copies of the elements of the <see cref="System.Collections.Generic.List%601" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The elements are copied using <xref:System.Array.Copy%2A?displayProperty=fullName>, which is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 The following example demonstrates the ToArray method and other methods of the <xref:System.Collections.Generic.List%601> class that act on ranges. At the end of the example, the <xref:System.Collections.Generic.List%601.GetRange%2A> method is used to get three items from the list, beginning with index location 2. The ToArray method is called on the resulting <xref:System.Collections.Generic.List%601>, creating an array of three elements. The elements of the array are displayed.  
  
 [!code-vb[List`1_Ranges#1](~/add/codesnippet/visualbasic/m-system.collections.gen_25_1.vb)]
 [!code-cpp[List`1_Ranges#1](~/add/codesnippet/cpp/m-system.collections.gen_25_1.cpp)]
 [!code-cs[List`1_Ranges#1](~/add/codesnippet/csharp/m-system.collections.gen_25_1.cs)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sets the capacity to the actual number of elements in the <see cref="System.Collections.Generic.List%601" />, if that number is less than a threshold value.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method can be used to minimize a collection's memory overhead if no new elements will be added to the collection. The cost of reallocating and copying a large <xref:System.Collections.Generic.List%601> can be considerable, however, so the TrimExcess method does nothing if the list is at more than 90 percent of capacity. This avoids incurring a large reallocation cost for a relatively small gain.  
  
> [!NOTE]
>  The current threshold of 90 percent might change in future releases.  
  
 This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 To reset a <xref:System.Collections.Generic.List%601> to its initial state, call the <xref:System.Collections.Generic.List%601.Clear%2A> method before calling the TrimExcess method. Trimming an empty <xref:System.Collections.Generic.List%601> sets the capacity of the <xref:System.Collections.Generic.List%601> to the default capacity.  
  
 The capacity can also be set using the <xref:System.Collections.Generic.List%601.Capacity%2A> property.  
  
   
  
## Examples  
 The following example demonstrates how to check the capacity and count of a  <xref:System.Collections.Generic.List%601> that contains a simple business object, and illustrates using the TrimExcess method to remove extra capacity.  
  
 [!code-cs[System.Collections.Generic.List.CapacityCount#1](~/add/codesnippet/csharp/m-system.collections.gen_16_1.cs)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/add/codesnippet/visualbasic/m-system.collections.gen_16_1.vb)]  
  
 The following example demonstrates the TrimExcess method. Several properties and methods of the <xref:System.Collections.Generic.List%601> class are used to add, insert, and remove items from a list of strings. Then the TrimExcess method is used to reduce the capacity to match the count, and the <xref:System.Collections.Generic.List%601.Capacity%2A> and <xref:System.Collections.Generic.List%601.Count%2A> properties are displayed. If the unused capacity had been less than 10 percent of total capacity, the list would not have been resized. Finally, the contents of the list are cleared.  
  
 [!code-cpp[List`1_Class#1](~/add/codesnippet/cpp/m-system.collections.gen_16_2.cpp)]
 [!code-cs[List`1_Class#1](~/add/codesnippet/csharp/m-system.collections.gen_16_2.cs)]
 [!code-fs[List`1_Class#1](~/add/codesnippet/fsharp/m-system.collections.gen_16_2.fs)]
 [!code-vb[List`1_Class#1](~/add/codesnippet/visualbasic/m-system.collections.gen_16_2.vb)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrueForAll">
      <MemberSignature Language="C#" Value="public bool TrueForAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrueForAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">The <see cref="System.Predicate%601" /> delegate that defines the conditions to check against the elements.</param>
        <summary>Determines whether every element in the <see cref="System.Collections.Generic.List%601" /> matches the conditions defined by the specified predicate.</summary>
        <returns>
          <see langword="true" /> if every element in the <see cref="System.Collections.Generic.List%601" /> matches the conditions defined by the specified predicate; otherwise, <see langword="false" />. If the list has no elements, the return value is <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.  The elements of the current <xref:System.Collections.Generic.List%601> are individually passed to the <xref:System.Predicate%601> delegate, and processing is stopped when the delegate returns `false` for any element. The elements are processed in order, and all calls are made on a single thread.  
  
 This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 The following example demonstrates the TrueForAll method and several other methods that use <xref:System.Predicate%601> generic delegate.  
  
 A <xref:System.Collections.Generic.List%601> of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus". The example also defines a search predicate method named `EndsWithSaurus`, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".  
  
 The TrueForAll method traverses the list from the beginning, passing each element in turn to the `EndsWithSaurus` method. The search stops when the `EndsWithSaurus` method returns `false`.  
  
> [!NOTE]
>  In C# and Visual Basic, it is not necessary to create the `Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly. These languages infer the correct delegate from context and create it automatically.  
  
 [!code-cs[List`1_FindEtAl#1](~/add/codesnippet/csharp/m-system.collections.gen_27_1.cs)]
 [!code-cpp[List`1_FindEtAl#1](~/add/codesnippet/cpp/m-system.collections.gen_27_1.cpp)]
 [!code-vb[List`1_FindEtAl#1](~/add/codesnippet/visualbasic/m-system.collections.gen_27_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>