<Type Name="IDisposable" FullName="System.IDisposable">
  <TypeSignature Language="C#" Value="public interface IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IDisposable" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Provides a mechanism for releasing unmanaged resources.  
  
 To browse the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/idisposable.cs#1f55292c3174123d).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/idisposable.cs#1f55292c3174123d). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  
  
 The primary use of this interface is to release unmanaged resources. The garbage collector automatically releases the memory allocated to a managed object when that object is no longer used. However, it is not possible to predict when garbage collection will occur. Furthermore, the garbage collector has no knowledge of unmanaged resources such as window handles, or open files and streams.  
  
 Use the <xref:System.IDisposable.Dispose%2A> method of this interface to explicitly release unmanaged resources in conjunction with the garbage collector. The consumer of an object can call this method when the object is no longer needed.  
  
> [!WARNING]
>  It is a breaking change to add the IDisposable interface to an existing class. Because pre-existing consumers of your type cannot call <xref:System.IDisposable.Dispose%2A>, you cannot be certain that unmanaged resources held by your type will be released.  
  
 Because the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation is called by the consumer of a type when the resources owned by an instance are no longer needed, you should either wrap the managed object in a <xref:System.Runtime.InteropServices.SafeHandle> (the recommended alternative), or you should override <xref:System.Object.Finalize%2A?displayProperty=fullName> to free unmanaged resources in the event that the consumer forgets to call <xref:System.IDisposable.Dispose%2A>.  
  
> [!IMPORTANT]
>  In the .NET Framework, the C++ compiler supports deterministic disposal of resources and does not allow direct implementation of the <xref:System.IDisposable.Dispose%2A> method.  
  
 For a detailed discussion about how this interface and the <xref:System.Object.Finalize%2A?displayProperty=fullName> method are used, see the [Garbage Collection](../Topic/Garbage%20Collection.md) and [Implementing a Dispose Method](../Topic/Implementing%20a%20Dispose%20Method.md) topics.  
  
## Using an object that implements IDisposable  
 Implement IDisposable only if you are using unmanaged resources directly. If your app simply uses an object that implements IDisposable, don't provide an IDisposable implementation. Instead, you should call the object's <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation when you are finished using it. Depending on your programming language, you can do this in one of two ways:  
  
-   By using a language construct such as the `using` statement in C# and Visual Basic.  
  
-   By wrapping the call to the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation in a `try`/`catch` block.  
  
> [!NOTE]
>  Documentation for types that implement IDisposable note that fact and include a reminder to call its <xref:System.IDisposable.Dispose%2A> implementation.  
  
<a name="Using"></a>   
### The C# and Visual Basic Using statement  
 If your language supports a construct such as the [using](../Topic/using%20\(C%23%20Reference\).md) statement in C# and the [Using](../Topic/Using%20Statement%20\(Visual%20Basic\).md) statement in Visual Basic, you can use it instead of explicitly calling <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> yourself. The following example uses this approach in defining a `WordCount` class that preserves information about a file and the number of words in it.  
  
 [!code-cs[System.IDisposable#1](~/add/codesnippet/csharp/t-system.idisposable_1.cs)]
 [!code-vb[System.IDisposable#1](~/add/codesnippet/visualbasic/t-system.idisposable_1.vb)]  
  
 The `using` statement is actually a syntactic convenience. At compile time, the language compiler implements the intermediate language (IL) for a `try`/`catch` block.  
  
 For more information about the `using` statement, see the [Using Statement](../Topic/Using%20Statement%20\(Visual%20Basic\).md) or [using Statement](../Topic/using%20Statement%20\(C%23%20Reference\).md) topics.  
  
### The Try/Catch block  
 If your programming language does not support a construct like the `using` statement in C# or Visual Basic, or if you prefer not to use it, you can call the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation from the `finally` block of a `try`/`catch` statement. The following example replaces the `using` block in the previous example with a `try`/`catch`/`finally` block.  
  
 [!code-vb[System.IDisposable#2](~/add/codesnippet/visualbasic/t-system.idisposable_2.vb)]
 [!code-cs[System.IDisposable#2](~/add/codesnippet/csharp/t-system.idisposable_2.cs)]  
  
 For more information about the `try`/`finally` pattern, see [Try...Catch...Finally Statement](../Topic/Try...Catch...Finally%20Statement%20\(Visual%20Basic\).md), [try-finally](../Topic/try-finally%20\(C%23%20Reference\).md), or [try-finally Statement](../Topic/try-finally%20Statement%20\(C\).md).  
  
## Implementing IDisposable  
 You should implement IDisposable only if your type uses unmanaged resources directly. The consumers of your type can call your <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation to free resources when the instance is no longer needed. To handle cases in which they fail to call <xref:System.IDisposable.Dispose%2A>, you should either use a class derived from <xref:System.Runtime.InteropServices.SafeHandle> to wrap the unmanaged resources, or you should override the <xref:System.Object.Finalize%2A?displayProperty=fullName> method for a reference type. In either case, you use the <xref:System.IDisposable.Dispose%2A> method to perform whatever cleanup is necessary after using the unmanaged resources, such as freeing, releasing, or resetting the unmanaged resources.  
  
> [!IMPORTANT]
>  If you are defining a base class that uses unmanaged resources and that either has, or is likely to have, subclasses that should be disposed, you should implement the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> method and provide a second overload of `Dispose`, as discussed in the next section.  
  
<a name="BaseClasses"></a>   
## IDisposable and the inheritance hierarchy  
 A base class with subclasses that should be disposable must implement IDisposable as follows. You should use this pattern whenever you implement IDisposable on any type that isn't `sealed` (`NotInheritable` in Visual Basic).  
  
-   It should provide one public, non-virtual <xref:System.IDisposable.Dispose> method and a protected virtual `Dispose(Boolean` `disposing``)` method.  
  
-   The <xref:System.IDisposable.Dispose> method must call `Dispose(true)` and should suppress finalization for performance.  
  
-   The base type should not include any finalizers.  
  
 The following code fragment reflects the dispose pattern for base classes. It assumes that your type does not override the <xref:System.Object.Finalize%2A?displayProperty=fullName> method.  
  
 [!code-cs[System.IDisposable#3](~/add/codesnippet/csharp/t-system.idisposable_3.cs)]
 [!code-vb[System.IDisposable#3](~/add/codesnippet/visualbasic/t-system.idisposable_3.vb)]  
  
 If you do override the <xref:System.Object.Finalize%2A?displayProperty=fullName> method, your class should implement the following pattern.  
  
 [!code-cs[System.IDisposable#5](~/add/codesnippet/csharp/t-system.idisposable_4.cs)]
 [!code-vb[System.IDisposable#5](~/add/codesnippet/visualbasic/t-system.idisposable_4.vb)]  
  
 Subclasses should implement the disposable pattern as follows:  
  
-   They must override `Dispose(Boolean)` and call the base class `Dispose(Boolean)` implementation.  
  
-   They can provide a finalizer if needed. The finalizer must call `Dispose(false)`.  
  
 Note that derived classes do not themselves implement the IDisposable interface and do not include a parameterless <xref:System.IDisposable.Dispose%2A> method. They only override the base class `Dispose(Boolean)` method.  
  
 The following code fragment reflects the dispose pattern for derived classes. It assumes that your type does not override the <xref:System.Object.Finalize%2A?displayProperty=fullName> method.  
  
 [!code-vb[System.IDisposable#4](~/add/codesnippet/visualbasic/t-system.idisposable_5.vb)]
 [!code-cs[System.IDisposable#4](~/add/codesnippet/csharp/t-system.idisposable_5.cs)]  
  
   
  
## Examples  
 The following example demonstrates how to create a resource class that implements the IDisposable interface.  
  
 [!code-cpp[System.IDisposable.Dispose Example#1](~/add/codesnippet/cpp/t-system.idisposable_6.cpp)]
 [!code-cs[System.IDisposable.Dispose Example#1](~/add/codesnippet/csharp/t-system.idisposable_6.cs)]
 [!code-vb[System.IDisposable.Dispose Example#1](~/add/codesnippet/visualbasic/t-system.idisposable_6.vb)]  
  
 ]]></format>
    </remarks>
    <threadsafe />
  </Docs>
  <Members>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this method to close or release unmanaged resources such as files, streams, and handles held by an instance of the class that implements this interface. By convention, this method is used for all tasks associated with freeing resources held by an object, or preparing an object for reuse.  
  
> [!WARNING]
>  If you are using a class that implements the <xref:System.IDisposable> interface, you should call its Dispose implementation when you are finished using the class. For more information, see the "Using an object that implements IDisposable" section in the <xref:System.IDisposable> topic.  
  
 When implementing this method, ensure that all held resources are freed by propagating the call through the containment hierarchy. For example, if an object A allocates an object B, and object B allocates an object C, then A's Dispose implementation must call Dispose on B, which must in turn call Dispose on C.  
  
> [!IMPORTANT]
>  The C++ compiler supports deterministic disposal of resources and does not allow direct implementation of the Dispose method.  
  
 An object must also call the Dispose method of its base class if the base class implements <xref:System.IDisposable>. For more information about implementing <xref:System.IDisposable> on a base class and its subclasses, see the "IDisposable and the inheritance hierarchy" section in the <xref:System.IDisposable> topic.  
  
 If an object's Dispose method is called more than once, the object must ignore all calls after the first one. The object must not throw an exception if its Dispose method is called multiple times. Instance methods other than Dispose can throw an <xref:System.ObjectDisposedException> when resources are already disposed.  
  
 Users might expect a resource type to use a particular convention to denote an allocated state versus a freed state. An example of this is stream classes, which are traditionally thought of as open or closed. The implementer of a class that has such a convention might choose to implement a public method with a customized name, such as `Close`, that calls the Dispose method.  
  
 Because the Dispose method must be called explicitly, there is always a danger that the unmanaged resources will not be released, because the consumer of an object fails to call its Dispose method. There are two ways to avoid this:  
  
-   Wrap the managed resource in an object derived from <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName>. Your Dispose implementation then calls the Dispose method of the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName> instances. For more information, see "The SafeHandle alternative" section in the <xref:System.Object.Finalize%2A?displayProperty=fullName> topic.  
  
-   Implement a finalizer to free resources when Dispose is not called. By default, the garbage collector automatically calls an object's finalizer before reclaiming its memory. However, if the Dispose method has been called, it is typically unnecessary for the garbage collector to call the disposed object's finalizer. To prevent automatic finalization, Dispose implementations can call the <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> method.  
  
 When you use an object that accesses unmanaged resources, such as a <xref:System.IO.StreamWriter>, a good practice is to create the instance with a `using` statement. The `using` statement automatically closes the stream and calls Dispose on the object when the code that is using it has completed. For an example, see the <xref:System.IO.StreamWriter> class.  
  
   
  
## Examples  
 The following example shows how you can implement the Dispose method.  
  
 [!code-cpp[System.IDisposable.Dispose Example#1](~/add/codesnippet/cpp/m-system.idisposable.dis_1.cpp)]
 [!code-cs[System.IDisposable.Dispose Example#1](~/add/codesnippet/csharp/m-system.idisposable.dis_1.cs)]
 [!code-vb[System.IDisposable.Dispose Example#1](~/add/codesnippet/visualbasic/m-system.idisposable.dis_1.vb)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
  </Members>
</Type>