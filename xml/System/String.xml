<Type Name="String" FullName="System.String">
  <TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.String&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents text as a sequence of UTF-16 code units.  
  
 To browse the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/string.cs#8281103e6f23cb5c).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/string.cs#8281103e6f23cb5c). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  
  
 A string is a sequential collection of characters that is used to represent text. A String object is a sequential collection of <xref:System.Char?displayProperty=fullName> objects that represent a string; a <xref:System.Char?displayProperty=fullName> object corresponds to a UTF-16 code unit. The value of the String object is the content of the sequential collection of <xref:System.Char?displayProperty=fullName> objects, and that value is immutable (that is, it is read-only). For more information about the immutability of strings, see the [Immutability and the StringBuilder class](#Immutability) section later in this topic. The maximum size of a String object in memory is 2GB, or about 1 billion characters.  
  
 In this section:  
  
 [Instantiating a String object](#Instantiation)   
 [Char objects and Unicode characters](#Characters)   
 [Strings and The Unicode Standard](#Unicode)   
 [Strings and embedded null characters](#EmbeddedNulls)   
 [Strings and indexes](#Indexes)   
 [Null strings and empty strings](#Nulls)   
 [Immutability and the StringBuilder class](#Immutability)   
 [Ordinal vs. culture-sensitive operations](#CultureSensitive)   
 [Normalization](#Normalization)   
 [String operations by category](#ByCategory)  
  
<a name="Instantiation"></a>   
## Instantiating a String object  
 You can instantiate a String object in the following ways:  
  
-   By assigning a string literal to a String variable. This is the most commonly used method for creating a string. The following example uses assignment to create several strings. Note that in C#, because the backslash (\\) is an escape character, literal backslashes in a string must be escaped or the entire string must be @-quoted.  
  
     [!code-vb[System.String.Class.Instantiate#1](~/add/codesnippet/visualbasic/t-system.string_1.vb)]
     [!code-cs[System.String.Class.Instantiate#1](~/add/codesnippet/csharp/instantiate1/program.cs#1)]
     [!code-cpp[System.String.Class.Instantiate#1](~/add/codesnippet/cpp/t-system.string_1.cpp)]  
  
-   By calling a String class constructor. The following example instantiates strings by calling several class constructors. Note that some of the constructors include pointers to character arrays or signed byte arrays as parameters. Visual Basic does not support calls to these constructors. For detailed information about String constructors, see the <xref:System.String.%23ctor%2A> constructor summary.  
  
     [!code-vb[System.String.Class.Instantiate#2](~/add/codesnippet/visualbasic/t-system.string_2.vb)]
     [!code-cpp[System.String.Class.Instantiate#2](~/add/codesnippet/cpp/t-system.string_2.cpp)]
     [!code-cs[System.String.Class.Instantiate#2](~/add/codesnippet/csharp/instantiate1/program.cs#2)]  
  
-   By using the string concatenation operator (+ in C# and & or + in Visual Basic) to create a single string from any combination of String instances and string literals. The following example illustrates the use of the string concatenation operator.  
  
     [!code-vb[System.String.Class.Instantiate#3](~/add/codesnippet/visualbasic/t-system.string_3.vb)]
     [!code-cs[System.String.Class.Instantiate#3](~/add/codesnippet/csharp/instantiate1/program.cs#3)]
     [!code-cpp[System.String.Class.Instantiate#3](~/add/codesnippet/cpp/t-system.string_3.cpp)]  
  
-   By retrieving a property or calling a method that returns a string. The following example uses the methods of the String class to extract a substring from a larger string.  
  
     [!code-vb[System.String.Class.Instantiate#4](~/add/codesnippet/visualbasic/t-system.string_4.vb)]
     [!code-cs[System.String.Class.Instantiate#4](~/add/codesnippet/csharp/instantiate1/program.cs#4)]
     [!code-cpp[System.String.Class.Instantiate#4](~/add/codesnippet/cpp/t-system.string_4.cpp)]  
  
-   By calling a formatting method to convert a value or object to its string representation. The following example uses the                [composite formatting](../Topic/Composite%20Formatting.md) feature to embed the string representation of two objects into a string.  
  
     [!code-vb[System.String.Class.Instantiate#5](~/add/codesnippet/visualbasic/t-system.string_5.vb)]
     [!code-cs[System.String.Class.Instantiate#5](~/add/codesnippet/csharp/instantiate1/program.cs#5)]
     [!code-cpp[System.String.Class.Instantiate#5](~/add/codesnippet/cpp/t-system.string_5.cpp)]  
  
<a name="Characters"></a>   
## Char objects and Unicode characters  
 Each character in a string is defined by a Unicode scalar value, also called a Unicode code point or the ordinal (numeric) value of the Unicode character. Each code point is encoded by using UTF-16 encoding, and the numeric value of each element of the encoding is represented by a <xref:System.Char> object.  
  
> [!NOTE]
>  Note that, because a String instance consists of a sequential collection of UTF-16 code units, it is possible to create a String object that is not a well-formed Unicode string. For example, it is possible to create a string that has a low surrogate without a corresponding high surrogate. Although some methods, such as the methods of encoding and decoding objects in the <xref:System.Text> namespace, may performs checks to ensure that strings are well-formed, String class members do not ensure that a string is well-formed.  
  
 A single <xref:System.Char> object usually represents a single code point; that is, the numeric value of the <xref:System.Char> equals the code point. For example, the code point for the character "a" is U+0061. However, a code point might require more than one encoded element (more than one <xref:System.Char> object). The Unicode standard defines two types of characters that correspond to multiple <xref:System.Char> objects: graphemes, and Unicode supplementary code points that correspond to characters in the Unicode supplementary planes.  
  
-   A grapheme is represented by a base character followed by one or more combining characters. For example, the character Ã¤ is represented by a <xref:System.Char> object whose code point is U+0061 followed by a <xref:System.Char> object whose code point is U+0308. This character can also be defined by a single <xref:System.Char> object that has a code point of U+00E4. As the following example shows, a culture-sensitive comparison for equality indicates that these two representations are equal, although an ordinary ordinal comparison does not. However, if the two strings are normalized, an ordinal comparison also indicates that they are equal. (For more information on normalizing strings, see the [Normalization](#Normalization) section.)  
  
     [!code-cpp[System.String.Class#2](~/add/codesnippet/cpp/t-system.string_6.cpp)]
     [!code-cs[System.String.Class#2](~/add/codesnippet/csharp/t-system.string_6.cs)]
     [!code-vb[System.String.Class#2](~/add/codesnippet/visualbasic/t-system.string_6.vb)]  
  
-   A Unicode supplementary code point (a surrogate pair) is represented by a <xref:System.Char> object whose code point is a high surrogate followed by a <xref:System.Char> object whose code point is a low surrogate. The code units of high surrogates range from U+D800 to U+DBFF. The code units of low surrogates range from U+DC00 to U+DFFF. Surrogate pairs are used to represent characters in the 16 Unicode supplementary planes. The following example creates a surrogate character and passes it to the <xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=fullName> method to determine whether it is a surrogate pair.  
  
     [!code-cpp[System.String.Class#3](~/add/codesnippet/cpp/t-system.string_7.cpp)]
     [!code-cs[System.String.Class#3](~/add/codesnippet/csharp/t-system.string_7.cs)]
     [!code-vb[System.String.Class#3](~/add/codesnippet/visualbasic/t-system.string_7.vb)]  
  
<a name="Unicode"></a>   
## Strings and The Unicode Standard  
 Characters in a string are represented by UTF-16 encoded code units, which correspond to <xref:System.Char> values.  
  
 Each character in a string has an associated Unicode character category, which is represented in the .NET Framework by the <xref:System.Globalization.UnicodeCategory> enumeration. The category of a character or a surrogate pair can be determined by calling the <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=fullName> method.  
  
 The .NET Framework maintains its own table of characters and their corresponding categories, which ensures that a version of the .NET Framework running on different platforms returns identical character category information. The following table lists the versions of the .NET Framework and the versions of the Unicode Standard on which their character categories are based.  
  
|.NET Framework version|Version of the Unicode Standard|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/add/includes/net-v11-long-md.md)]|[The Unicode Standard, Version 4.0.0](http://www.unicode.org/versions/Unicode4.0.0/)|  
|The .NET Framework 2.0|[The Unicode Standard, Version 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/add/includes/net-v35-long-md.md)]|[The Unicode Standard, Version 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]|[The Unicode Standard, Version 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/add/includes/net-v45-md.md)]|[The Unicode Standard, Version 6.3.0](http://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v451](~/add/includes/net-v451-md.md)]|[The Unicode Standard, Version 6.3.0](http://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v452](~/add/includes/net-v452-md.md)]|[The Unicode Standard, Version 6.3.0](http://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v46](~/add/includes/net-v46-md.md)]|[The Unicode Standard, Version 6.3.0](http://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v461](~/add/includes/net-v461-md.md)]|[The Unicode Standard, Version 6.3.0](http://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v462](~/add/includes/net-v462-md.md)]|[The Unicode Standard, Version 8.0.0](http://www.unicode.org/versions/Unicode8.0.0/)|  
  
 In addition, the .NET Framework supports string comparison and sorting based on the Unicode standard. In versions of the .NET Framework through the [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)], the .NET Framework maintains its own table of string data. This is also true of versions of the .NET Framework starting with the [!INCLUDE[net_v45](~/add/includes/net-v45-md.md)] running on Windows 7. Starting with the [!INCLUDE[net_v45](~/add/includes/net-v45-md.md)] running on Window 8 and later versions of the Windows operating system, the runtime delegates string comparison and sorting operations to the operating system. The following table lists the versions of the .NET Framework and the versions of the Unicode Standard on which character comparison and sorting are based.  
  
|.NET Framework version|Version of the Unicode Standard|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/add/includes/net-v11-long-md.md)]|[The Unicode Standard, Version 4.0.0](http://www.unicode.org/versions/Unicode4.0.0/)|  
|The .NET Framework 2.0|[The Unicode Standard, Version 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/add/includes/net-v35-long-md.md)]|[The Unicode Standard, Version 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)]|[The Unicode Standard, Version 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/add/includes/net-v45-md.md)] and later on Windows 7|[The Unicode Standard, Version 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/add/includes/net-v45-md.md)] and later on Windows 8 and later Windows operating systems|[The Unicode Standard, Version 6.3.0](http://www.unicode.org/versions/Unicode6.3.0/)|  
  
<a name="EmbeddedNulls"></a>   
## Strings and embedded null characters  
 In the .NET Framework, a String object can include embedded null characters, which count as a part of the string's length. However, in some languages such as C and C++, a null character indicates the end of a string;it is not considered a part of the string and is not counted as part of the string's length. This means that the following common assumptions that C and C++ programmers or libraries written in C or C++ might make about strings are not necessarily valid when applied to String objects:  
  
-   The value returned by the `strlen` or `wcslen` functions does not necessarily equal <xref:System.String.Length%2A?displayProperty=fullName>.  
  
-   The string created by the `strcpy_s` or `wcscpy_s` functions is not necessarily identical to the string created by the <xref:System.String.Copy%2A?displayProperty=fullName> method.  
  
 You should ensure that native C and C++ code that instantiates String objects, and code that is passed String objects through platform invoke, do not assume that an embedded null character marks the end of the string.  
  
 Embedded null characters in a string are also treated differently when a string is sorted (or compared) and when a string is searched. Null characters are ignored when performing culture-sensitive comparisons between two strings, including comparisons using the invariant culture. They are considered only for ordinal or case-insensitive ordinal comparisons. On the other hand, embedded null characters are always considered when searching a string with methods such as <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A>, and <xref:System.String.IndexOf%2A>.  
  
<a name="Indexes"></a>   
## Strings and indexes  
 An index is the position of a <xref:System.Char> object (not a Unicode character) in a String. An index is a zero-based, nonnegative number that starts from the first position in the string, which is index position zero. A number of search methods, such as <xref:System.String.IndexOf%2A> and <xref:System.String.LastIndexOf%2A>, return the index of a character or substring in the string instance.  
  
 The <xref:System.String.Chars%2A> property lets you access individual <xref:System.Char> objects by their index position in the string. Because the <xref:System.String.Chars%2A> property is the default property (in Visual Basic) or the indexer (in C#), you can access the individual <xref:System.Char> objects in a string by using code such as the following. This code looks for white space or punctuation characters in a string to determine how many words the string contains.  
  
 [!code-cpp[System.String.Class#4](~/add/codesnippet/cpp/t-system.string_8.cpp)]
 [!code-cs[System.String.Class#4](~/add/codesnippet/csharp/t-system.string_8.cs)]
 [!code-vb[System.String.Class#4](~/add/codesnippet/visualbasic/t-system.string_8.vb)]  
  
 Because the String class implements the <xref:System.Collections.IEnumerable> interface, you can also iterate through the <xref:System.Char> objects in a string by using a `foreach` construct, as the following example shows.  
  
 [!code-cpp[System.String.Class#5](~/add/codesnippet/cpp/t-system.string_9.cpp)]
 [!code-cs[System.String.Class#5](~/add/codesnippet/csharp/t-system.string_9.cs)]
 [!code-vb[System.String.Class#5](~/add/codesnippet/visualbasic/t-system.string_9.vb)]  
  
 Consecutive index values might not correspond to consecutive Unicode characters, because a Unicode character might be encoded as more than one <xref:System.Char> object. In particular, a string may contain multi-character units of text that are formed by a base character followed by one or more combining characters or by surrogate pairs. To work with Unicode characters instead of <xref:System.Char> objects, use the <xref:System.Globalization.StringInfo?displayProperty=fullName> and <xref:System.Globalization.TextElementEnumerator> classes. The following example illustrates the difference between code that works with <xref:System.Char> objects and code that works with Unicode characters. It compares the number of characters or text elements in each word of a sentence. The string includes two sequences of a base character followed by a combining character.  
  
 [!code-cpp[System.String.Class#6](~/add/codesnippet/cpp/t-system.string_10.cpp)]
 [!code-cs[System.String.Class#6](~/add/codesnippet/csharp/t-system.string_10.cs)]
 [!code-vb[System.String.Class#6](~/add/codesnippet/visualbasic/t-system.string_10.vb)]  
  
 This example works with text elements by using the <xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=fullName> method and the <xref:System.Globalization.TextElementEnumerator> class to enumerate all the text elements in a string. You can also retrieve an array that contains the starting index of each text element by calling the <xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=fullName> method.  
  
 For more information about working with units of text rather than individual <xref:System.Char> values, see the <xref:System.Globalization.StringInfo> class.  
  
<a name="Nulls"></a>   
## Null strings and empty strings  
 A string that has been declared but has not been assigned a value is `null`. Attempting to call methods on that string throws a <xref:System.NullReferenceException>. A null string is different from an empty string, which is a string whose value is "" or <xref:System.String.Empty?displayProperty=fullName>. In some cases, passing either a null string or an empty string as an argument in a method call throws an exception. For example, passing a null string to the <xref:System.Int32.Parse%2A?displayProperty=fullName> method throws an <xref:System.ArgumentNullException>, and passing an empty string throws a <xref:System.FormatException>. In other cases, a method argument can be either a null string or an empty string. For example, if you are providing an <xref:System.IFormattable> implementation for a class, you want to equate both a null string and an empty string with the general ("G") format specifier.  
  
 The String class includes the following two convenience methods that enable you to test whether a string is `null` or empty:  
  
-   <xref:System.String.IsNullOrEmpty%2A>, which indicates whether a string is either `null` or is equal to  <xref:System.String.Empty?displayProperty=fullName>. This method eliminates the need to use code such as the following:  
  
     [!code-vb[System.String.Class.Null#1](~/add/codesnippet/visualbasic/t-system.string_11.vb)]
     [!code-cs[System.String.Class.Null#1](~/add/codesnippet/csharp/t-system.string_11.cs)]
     [!code-cpp[System.String.Class.Null#1](~/add/codesnippet/cpp/t-system.string_11.cpp)]  
  
-   <xref:System.String.IsNullOrWhiteSpace%2A>, which indicates whether a string is `null`, equals <xref:System.String.Empty?displayProperty=fullName>, or consists exclusively of white-space characters. This method eliminates the need to use code such as the following:  
  
     [!code-vb[System.String.Class.Null#2](~/add/codesnippet/visualbasic/t-system.string_12.vb)]
     [!code-cs[System.String.Class.Null#2](~/add/codesnippet/csharp/t-system.string_12.cs)]
     [!code-cpp[System.String.Class.Null#2](~/add/codesnippet/cpp/t-system.string_12.cpp)]  
  
 The following example uses the <xref:System.String.IsNullOrEmpty%2A> method in the <xref:System.IFormattable.ToString%2A?displayProperty=fullName> implementation of a custom `Temperature` class. The method supports the "G", "C", "F", and "K" format strings. If an empty format string or a format string whose value is `null` is passed to the method, its value is changed to the "G" format string.  
  
 [!code-vb[System.String.Class.Null#3](~/add/codesnippet/visualbasic/t-system.string_13.vb)]
 [!code-cs[System.String.Class.Null#3](~/add/codesnippet/csharp/t-system.string_13.cs)]
 [!code-cpp[System.String.Class.Null#3](~/add/codesnippet/cpp/t-system.string_13.cpp)]  
  
<a name="Immutability"></a>   
## Immutability and the StringBuilder class  
 A String object is called immutable (read-only), because its value cannot be modified after it has been created. Methods that appear to modify a String object actually return a new String object that contains the modification.  
  
 Because strings are immutable, string manipulation routines that perform repeated additions or deletions to what appears to be a single string can exact a significant performance penalty. For example, the following code uses a random number generator to create a string with 1000 characters in the range 0x0001 to 0x052F. Although the code appears to use string concatenation to append a new character to the existing string named `str`, it actually creates a new String object for each concatenation operation.  
  
 [!code-cs[System.String.Class#15](~/add/codesnippet/csharp/t-system.string_14.cs)]
 [!code-cpp[System.String.Class#15](~/add/codesnippet/cpp/t-system.string_14.cpp)]
 [!code-vb[System.String.Class#15](~/add/codesnippet/visualbasic/t-system.string_14.vb)]  
  
 You can use the <xref:System.Text.StringBuilder> class instead of the String class for operations that make multiple changes to the value of a string. Unlike instances of the String class, <xref:System.Text.StringBuilder> objects are mutable; when you concatenate, append, or delete substrings from a string, the operations are performed on a single string. When you have finished modifying the value of a <xref:System.Text.StringBuilder> object, you can call its <xref:System.Text.StringBuilder.ToString%2A?displayProperty=fullName> method to convert it to a string. The following example replaces the String used in the previous example to concatenate 1000 random characters in the range to  0x0001 to 0x052F with a <xref:System.Text.StringBuilder> object.  
  
 [!code-cpp[System.String.Class#16](~/add/codesnippet/cpp/t-system.string_15.cpp)]
 [!code-cs[System.String.Class#16](~/add/codesnippet/csharp/t-system.string_15.cs)]
 [!code-vb[System.String.Class#16](~/add/codesnippet/visualbasic/t-system.string_15.vb)]  
  
<a name="CultureSensitive"></a>   
## Ordinal vs. culture-sensitive operations  
 Members of the String class perform either ordinal or culture-sensitive (linguistic) operations on a String object. An ordinal operation acts on the numeric value of each <xref:System.Char> object. A culture-sensitive operation acts on the value of the Stringobject, and takes culture-specific casing, sorting, formatting, and parsing rules into account. Culture-sensitive operations execute in the context of an explicitly declared culture or the implicit current culture. The two kinds of operations can produce very different results when they are performed on the same string.  
  
 The .NET Framework also supports culture-insensitive linguistic string operations by using the invariant culture (<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=fullName>), which is loosely based on the culture settings of the English language independent of region. Unlike other <xref:System.Globalization.CultureInfo?displayProperty=fullName> settings, the settings of the invariant culture are guaranteed to remain consistent on a single computer, from system to system, and across versions of the .NET Framework. The invariant culture can be seen as a kind of black box that ensures stability of string comparisons and ordering across all cultures.  
  
> [!IMPORTANT]
>  If your application makes a security decision about a symbolic identifier such as a file name or named pipe, or about persisted data such as the text-based data in an XML file, the operation should use an ordinal comparison instead of a culture-sensitive comparison. This is because a culture-sensitive comparison can yield different results depending on the culture in effect, whereas an ordinal comparison depends solely on the binary value of the compared characters.  
  
> [!IMPORTANT]
>  Most methods that perform string operations include an overload that has a parameter of type <xref:System.StringComparison>, which enables you to specify whether the method performs an ordinal or culture-sensitive operation. In general, you should call this overload to make the intent of your method call clear. For best practices and guidance for using ordinal and culture-sensitive operations on strings, see [Best Practices for Using Strings](../Topic/Best%20Practices%20for%20Using%20Strings%20in%20the%20.NET%20Framework.md).  
  
 Operations for [casing](#casing), [parsing and formatting](#parsing), [comparison and sorting](#comparison), and [testing for equality](#equality) can be either ordinal or culture-sensitive. The following sections discuss each category of operation.  
  
> [!TIP]
>  You should always call a method overload that makes the intent of your method call clear. For example, instead of calling the <xref:System.String.Compare%28System.String%2CSystem.String%29> method to perform a culture-sensitive comparison of two strings by using the conventions of the current culture, you should call the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method with a value of <xref:System.StringComparison?displayProperty=fullName> for the `comparisonType` argument. For more information, see [Best Practices for Using Strings](../Topic/Best%20Practices%20for%20Using%20Strings%20in%20the%20.NET%20Framework.md).  
  
<a name="casing"></a>   
### Casing  
 Casing rules determine how to change the capitalization of a Unicode character; for example, from lowercase to uppercase. Often, a casing operation is performed before a string comparison. For example, a string might be converted to uppercase so that it can be compared with another uppercase string. You can convert the characters in a string to lowercase by calling the <xref:System.String.ToLower%2A> or <xref:System.String.ToLowerInvariant%2A> method, and you can convert them to uppercase by calling the <xref:System.String.ToUpper%2A> or <xref:System.String.ToUpperInvariant%2A> method. In addition, you can use the <xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=fullName> method to convert a string to title case.  
  
 Casing operations can be based on the rules of the current culture, a specified culture, or the invariant culture. Because case mappings can vary depending on the culture used, the result of casing operations can vary based on culture. The actual differences in casing are of three kinds:  
  
-   Differences in the case mapping of LATIN CAPITAL LETTER I (U+0049), LATIN SMALL LETTER I (U+0069), LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130), and LATIN SMALL LETTER DOTLESS I (U+0131). In the tr-TR (Turkish (Turkey)) and az-Latn-AZ (Azerbaijan, Latin) cultures, and in the tr, az, and az-Latn neutral cultures, the lowercase equivalent of LATIN CAPITAL LETTER I is LATIN SMALL LETTER DOTLESS I, and the uppercase equivalent of LATIN SMALL LETTER I is LATIN CAPITAL LETTER I WITH DOT ABOVE. In all other cultures, including the invariant culture, LATIN SMALL LETTER I and LATIN CAPITAL LETTER I are lowercase and uppercase equivalents.  
  
     The following example demonstrates how a string comparison designed to prevent file system access can fail if it relies on a culture-sensitive casing comparison. (The casing conventions of the invariant culture should have been used.)  
  
     [!code-cs[System.String.Class#17](~/add/codesnippet/csharp/t-system.string_16.cs)]
     [!code-vb[System.String.Class#17](~/add/codesnippet/visualbasic/t-system.string_16.vb)]  
  
-   Differences in case mappings between the invariant culture and all other cultures. In these cases, using the casing rules of the invariant culture to change a character to uppercase or lowercase returns the same character. For all other cultures, it returns a different character. Some of the affected characters are listed in the following table.  
  
    |Character|If changed to|Returns|  
    |---------------|-------------------|-------------|  
    |MICRON SIGN (U+00B5)|Uppercase|GREEK CAPITAL LETTER MU (U+-39C)|  
    |LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130)|Lowercase|LATIN SMALL LETTER I (U+0069)|  
    |LATIN SMALL LETTER DOTLESS I (U+0131)|Uppercase|LATIN CAPITAL LETTER I (U+0049)|  
    |LATIN SMALL LETTER LONG S (U+017F)|Uppercase|LATIN CAPITAL LETTER S (U+0053)|  
    |LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON (U+01C5)|Lowercase|LATIN SMALL LETTER DZ WITH CARON (U+01C6)|  
    |COMBINING GREEK YPOGEGRAMMENI (U+0345)|Uppercase|GREEK CAPITAL LETTER IOTA (U+0399)|  
  
-   Differences in case mappings of two-letter mixed-case pairs in the ASCII character range. In most cultures, a two-letter mixed-case pair is equal to the equivalent two-letter uppercase or lowercase pair. This is not true for the following two-letter pairs in the following cultures, because in each case they are compared to a digraph:  
  
    -   "lJ" and "nJ" in the hr-HR (Croatian (Croatia)) culture.  
  
    -   "cH" in the cs-CZ (Czech (Czech Republic)) and sk-SK (Slovak (Slovakia)) cultures.  
  
    -   "aA" in the da-DK (Danish (Denmark)) culture.  
  
    -   "cS", "dZ", "dZS", "nY", "sZ", "tY", and "zS" in the hu-HU (Hungarian (Hungary)) culture.  
  
    -   "cH" and "lL" in the es-ES_tradnl (Spanish (Spain, Traditional Sort)) culture.  
  
    -   "cH", "gI", "kH", "nG" "nH", "pH", "qU', "tH", and "tR" in the vi-VN (Vietnamese (Vietnam)) culture.  
  
     However, it is unusual to encounter a situation in which a culture-sensitive comparison of these pairs creates problems, because these pairs are uncommon in fixed strings or identifiers.  
  
 The following example illustrates some of the differences in casing rules between cultures when converting strings to uppercase.  
  
 [!code-cpp[System.String.Class#7](~/add/codesnippet/cpp/t-system.string_17.cpp)]
 [!code-cs[System.String.Class#7](~/add/codesnippet/csharp/t-system.string_17.cs)]
 [!code-vb[System.String.Class#7](~/add/codesnippet/visualbasic/t-system.string_17.vb)]  
  
<a name="parsing"></a>   
### Parsing and formatting  
 Formatting and parsing are inverse operations. Formatting rules determine how to convert a value, such as a date and time or a number, to its string representation, whereas parsing rules determine how to convert a string representation to a value such as a date and time. Both formatting and parsing rules are dependent on cultural conventions. The following example illustrates the ambiguity that can arise when interpreting a culture-specific date string. Without knowing the conventions of the culture that was used to produce a date string, it is not possible to know whether 03/01/2011, 3/1/2011, and 01/03/2011 represent January 3, 2011 or March 1, 2011.  
  
 [!code-cpp[System.String.Class#8](~/add/codesnippet/cpp/t-system.string_18.cpp)]
 [!code-cs[System.String.Class#8](~/add/codesnippet/csharp/t-system.string_18.cs)]
 [!code-vb[System.String.Class#8](~/add/codesnippet/visualbasic/t-system.string_18.vb)]  
  
 Similarly, as the following example shows, a single string can produce different dates depending on the culture whose conventions are used in the parsing operation.  
  
 [!code-vb[System.String.Class#9](~/add/codesnippet/visualbasic/t-system.string_19.vb)]
 [!code-cpp[System.String.Class#9](~/add/codesnippet/cpp/t-system.string_19.cpp)]
 [!code-cs[System.String.Class#9](~/add/codesnippet/csharp/t-system.string_19.cs)]  
  
<a name="comparison"></a>   
### String comparison and sorting  
 Conventions for comparing and sorting strings vary from culture to culture. For example, the sort order may be based on phonetics or on the visual representation of characters. In East Asian languages, characters are sorted by the stroke and radical of ideographs. Sorting also depends on the order languages and cultures use for the alphabet. For example, the Danish language has an "Ã" character that it sorts after "Z" in the alphabet. In addition, comparisons can be case-sensitive or case-insensitive, and in some cases casing rules also differ by culture. Ordinal comparison, on the other hand, uses the Unicode code points of individual characters in a string when comparing and sorting strings.  
  
 Sort rules determine the alphabetic order of Unicode characters and how two strings compare to each other. For example, the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=fullName> method compares two strings based on the <xref:System.StringComparison> parameter. If the parameter value is <xref:System.StringComparison?displayProperty=fullName>, the method performs a linguistic comparison that uses the conventions of the current culture; if the parameter value is <xref:System.StringComparison?displayProperty=fullName>, the method performs an ordinal comparison. Consequently, as the following example shows, if the current culture is U.S. English, the first call to the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=fullName> method (using culture-sensitive comparison) considers "a" less than "A", but the second call to the same method (using ordinal comparison) considers "a" greater than "A".  
  
 [!code-cpp[System.String.Class#10](~/add/codesnippet/cpp/t-system.string_20.cpp)]
 [!code-vb[System.String.Class#10](~/add/codesnippet/visualbasic/t-system.string_20.vb)]
 [!code-cs[System.String.Class#10](~/add/codesnippet/csharp/t-system.string_20.cs)]  
  
 The .NET Framework supports word, string, and ordinal sort rules:  
  
-   A word sort performs a culture-sensitive comparison of strings in which certain nonalphanumeric Unicode characters might have special weights assigned to them. For example, the hyphen (-) might have a very small weight assigned to it so that "coop" and "co-op" appear next to each other in a sorted list. For a list of the Stringmethods that compare two strings using word sort rules, see the [String operations by category](#ByCategory) section.  
  
-   A string sort also performs a culture-sensitive comparison. It is similar to a word sort, except that there are no special cases, and all nonalphanumeric symbols come before all alphanumeric Unicode characters. Two strings can be compared using string sort rules by calling the <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=fullName> method overloads that have an `options` parameter that is supplied a value of <xref:System.Globalization.CompareOptions?displayProperty=fullName>. Note that this is the only method that the .NET Framework provides to compare two strings using string sort rules.  
  
-   An ordinal sort compares strings based on the numeric value of each <xref:System.Char> object in the string. An ordinal comparison is automatically case-sensitive because the lowercase and uppercase versions of a character have different code points. However, if case is not important, you can specify an ordinal comparison that ignores case. This is equivalent to converting the string to uppercase by using the invariant culture and then performing an ordinal comparison on the result. For a list of the String methods that compare two strings using ordinal sort rules, see the [String operations by category](#ByCategory) section.  
  
 A culture-sensitive comparison is any comparison that explicitly or implicitly uses a <xref:System.Globalization.CultureInfo> object, including the invariant culture that is specified by the <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=fullName> property. The implicit culture is the current culture, which is specified by the <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=fullName> and <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=fullName> properties. There is considerable variation in the sort order of alphabetic characters (that is, characters for which the <xref:System.Char.IsLetter%2A?displayProperty=fullName> property returns `true`) across cultures. You can specify a culture-sensitive comparison that uses the conventions of a specific culture by supplying a <xref:System.Globalization.CultureInfo> object to a string comparison method such as <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>. You can specify a culture-sensitive comparison that uses the conventions of the current culture by supplying <xref:System.StringComparison?displayProperty=fullName>, <xref:System.StringComparison?displayProperty=fullName>, or any member of the <xref:System.Globalization.CompareOptions> enumeration other than <xref:System.Globalization.CompareOptions?displayProperty=fullName> or <xref:System.Globalization.CompareOptions?displayProperty=fullName> to an appropriate overload of the <xref:System.String.Compare%2A> method. A culture-sensitive comparison is generally appropriate for sorting whereas an ordinal comparison is not. An ordinal comparison is generally appropriate for determining whether two strings are equal (that is, for determining identity) whereas a culture-sensitive comparison is not.  
  
 The following example illustrates the difference between culture-sensitive and ordinal comparison. The example evaluates three strings, "Apple", "Ãble", and "AEble", using ordinal comparison and the conventions of the da-DK and en-US cultures (each of which is the default culture at the time the <xref:System.String.Compare%2A> method is called). Because the Danish language treats the character "Ã" as an individual letter and sorts it after "Z" in the alphabet, the string "Ãble" is greater than "Apple". However, "Ãble" is not considered equivalent to "AEble", so "Ãble" is also greater than "AEble". The en-US culture doesn't include the letter"Ã" but treats it as equivalent to "AE", which explains why  "Ãble" is less than "Apple" but equal to "AEble". Ordinal comparison, on the other hand, considers "Apple" to be less than "Ãble", and "Ãble" to be greater than "AEble".  
  
 [!code-vb[System.String.Class#21](~/add/codesnippet/visualbasic/t-system.string_21.vb)]
 [!code-cs[System.String.Class#21](~/add/codesnippet/csharp/t-system.string_21.cs)]  
  
 Use the following general guidelines to choose an appropriate sorting or string comparison method:  
  
-   If you want the strings to be ordered based on the user's culture, you should order them based on the conventions of the current culture. If the user's culture changes, the order of sorted strings will also change accordingly. For example, a thesaurus application should always sort words based on the user's culture.  
  
-   If you want the strings to be ordered based on the conventions of a specific culture, you should order them by supplying a <xref:System.Globalization.CultureInfo> object that represents that culture to a comparison method. For example, in an application designed to teach students a particular language, you want strings to be ordered based on the conventions of one of the cultures that speaks that language.  
  
-   If you want the order of strings to remain unchanged across cultures, you should order them based on the conventions of the invariant culture or use an ordinal comparison. For example, you would use an ordinal sort to organize the names of files, processes, mutexes, or named pipes.  
  
-   For a comparison that involves a security decision (such as whether a username is valid), you should always perform an ordinal test for equality by calling an overload of the <xref:System.String.Equals%2A> method.  
  
> [!NOTE]
>  The culture-sensitive sorting and casing rules used in string comparison depend on the version of the .NET Framework. In the [!INCLUDE[net_v45](~/add/includes/net-v45-md.md)] running on the [!INCLUDE[win8](~/add/includes/win8-md.md)] operating system, sorting, casing, normalization, and Unicode character information conforms to the Unicode 6.0 standard. On other operating systems, it conforms to the Unicode 5.0 standard.  
  
 For more information about word, string, and ordinal sort rules, see the <xref:System.Globalization.CompareOptions?displayProperty=fullName> topic. For additional recommendations on when to use each rule, see [Best Practices for Using Strings](../Topic/Best%20Practices%20for%20Using%20Strings%20in%20the%20.NET%20Framework.md).  
  
 Ordinarily, you do not call string comparison methods such as <xref:System.String.Compare%2A> directly to determine the sort order of strings. Instead, comparison methods are called by sorting methods such as <xref:System.Array.Sort%2A?displayProperty=fullName> or <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=fullName>. The following example performs four different sorting operations (word sort using the current culture, word sort using the invariant culture, ordinal sort, and string sort using the invariant culture) without explicitly calling a string comparison method, although they do specify the type of comparison to use. Note that each type of sort produces a unique ordering of strings in its array.  
  
 [!code-cpp[System.String.Class#12](~/add/codesnippet/cpp/t-system.string_22.cpp)]
 [!code-cs[System.String.Class#12](~/add/codesnippet/csharp/t-system.string_22.cs)]
 [!code-vb[System.String.Class#12](~/add/codesnippet/visualbasic/t-system.string_22.vb)]  
  
> [!TIP]
>  Internally, the.NET Framework uses sort keys to support culturallysensitive string comparison. Each character in a string is given several categories of sort weights, including alphabetic, case, and diacritic. A sort key, represented by the <xref:System.Globalization.SortKey> class, provides a repository of these weights for a particular string. If your app performs a large number of searching or sorting operations on the same set of strings, you can improve its performance by generating and storing sort keys for all the strings that it uses. When a sort or comparison operation is required, you use the sort keys instead of the strings. For more information, see the <xref:System.Globalization.SortKey> class.  
  
 If you don't specify a string comparison convention, sorting methods such as <xref:System.Array.Sort%28System.Array%29?displayProperty=fullName> perform a culture-sensitive, case-sensitive sort on strings. The following example illustrates how changing the current culture affects the order of sorted strings in an array. It creates an array of three strings. First, it sets the `System.Threading.Thread.CurrentThread.CurrentCulture` property to en-US and calls the <xref:System.Array.Sort%28System.Array%29?displayProperty=fullName> method. The resulting sort order is based on sorting conventions for the English (United States) culture. Next, the example sets the `System.Threading.Thread.CurrentThread.CurrentCulture` property to da-DK and calls the <xref:System.Array.Sort%2A?displayProperty=fullName> method again. Notice how the resulting sort order differs from the en-US results because it uses the sorting conventions for Danish (Denmark).  
  
 [!code-cs[Conceptual.Strings.Comparing#3](~/add/codesnippet/csharp/t-system.string_23.cs)]
 [!code-vb[Conceptual.Strings.Comparing#3](~/add/codesnippet/visualbasic/t-system.string_23.vb)]  
  
> [!WARNING]
>  If your primary purpose in comparing strings is to determine whether they are equal, you should call the <xref:System.String.Equals%2A?displayProperty=fullName> method. Typically, you should use <xref:System.String.Equals%2A> to perform an ordinal comparison. The <xref:System.String.Compare%2A?displayProperty=fullName> method is intended primarily to sort strings.  
  
 String search methods, such as <xref:System.String.StartsWith%2A?displayProperty=fullName> and <xref:System.String.IndexOf%2A?displayProperty=fullName>, also can perform culture-sensitive or ordinal string comparisons. The following example illustrates the differences between ordinal and culture-sensitive comparisons using the <xref:System.String.IndexOf%2A> method. A culture-sensitive search in which the current culture is English (United States) considers the substring "oe" to match the ligature "Å". Because a soft hyphen (U+00AD) is a zero-width character, the search treats the soft hyphen as equivalent to <xref:System.String.Empty> and finds a match at the beginning of the string. An ordinal search, on the other hand, does not find a match in either case.  
  
 [!code-cpp[System.String.Class#13](~/add/codesnippet/cpp/t-system.string_24.cpp)]
 [!code-vb[System.String.Class#13](~/add/codesnippet/visualbasic/t-system.string_24.vb)]
 [!code-cs[System.String.Class#13](~/add/codesnippet/csharp/t-system.string_24.cs)]  
  
### Searching Strings  
 String search methods, such as <xref:System.String.StartsWith%2A?displayProperty=fullName> and <xref:System.String.IndexOf%2A?displayProperty=fullName>, also can perform culture-sensitive or ordinal string comparisons to determine whether a character or substring is found in a specified string.  
  
 The search methods in the String class that search for an individual character, such as the<xref:System.String.IndexOf%2A> method, or one of a set of characters,   such as the <xref:System.String.IndexOfAny%2A> method, all perform an ordinal search. To perform a culture-sensitive search for a character, you must call a <xref:System.Globalization.CompareInfo> method such as <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=fullName> or <xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=fullName>. Note that the results of searching for a character using ordinal and culture-sensitive comparison can be very different. For example, a search for a precomposed Unicode character such as the ligature "Ã" (U+00C6) might match any occurrence of its components in the correct sequence, such as "AE" (U+041U+0045), depending on the culture. The following example illustrates the difference between the <xref:System.String.IndexOf%28System.Char%29?displayProperty=fullName> and <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=fullName> methods when searching for an individual character. The ligature "Ã¦" (U+00E6) is found in the string "aerial" when using the conventions of the en-US culture, but not when using the conventions of the da-DK culture or when performing an ordinal comparison.  
  
 [!code-cs[System.String.Class#22](~/add/codesnippet/csharp/t-system.string_25.cs)]
 [!code-vb[System.String.Class#22](~/add/codesnippet/visualbasic/t-system.string_25.vb)]  
  
 On the other hand, String class methods that search for a string rather than a character perform a culture-sensitive search if search options are not explicitly specified by a parameter of type <xref:System.StringComparison>. The sole exception is <xref:System.String.Contains%2A>, which performs an ordinal search.  
  
<a name="equality"></a>   
### Testing for equality  
 Use the <xref:System.String.Compare%2A?displayProperty=fullName> method to determine the relationship of two strings in the sort order. Typically, this is a culture-sensitive operation. In contrast, call the <xref:System.String.Equals%2A?displayProperty=fullName> method to test for equality. Because the test for equality usually compares user input with some known string, such as a valid user name, a password, or a file system path, it is typically an ordinal operation.  
  
> [!WARNING]
>  It is possible to test for equality by calling the <xref:System.String.Compare%2A?displayProperty=fullName> method and determining whether the return value is zero. However, this practice is not recommended. To determine whether two strings are equal, you should call one of the overloads of the <xref:System.String.Equals%2A?displayProperty=fullName> method. The preferred overload to call is either the instance <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> method or the static <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, because both methods include a <xref:System.StringComparison?displayProperty=fullName> parameter that explicitly specifies the type of comparison.  
  
 The following example illustrates the danger of performing a culture-sensitive comparison for equality when an ordinal one should be used instead. In this case, the intent of the code is to prohibit file system access from URLs that begin with "FILE://" or "file://" by performing a case-insensitive comparison of the beginning of a URL with the string "FILE://". However, if a culture-sensitive comparison is performed using the Turkish (Turkey) culture on a URL that begins with "file://", the comparison for equality fails, because the Turkish uppercase equivalent of the lowercase "i" is "Ä°" instead of "I". As a result, file system access is inadvertently permitted. On the other hand, if an ordinal comparison is performed, the comparison for equality succeeds, and file system access is denied.  
  
 [!code-cpp[System.String.Class#11](~/add/codesnippet/cpp/t-system.string_26.cpp)]
 [!code-cs[System.String.Class#11](~/add/codesnippet/csharp/t-system.string_26.cs)]
 [!code-vb[System.String.Class#11](~/add/codesnippet/visualbasic/t-system.string_26.vb)]  
  
<a name="Normalization"></a>   
## Normalization  
 Some Unicode characters have multiple representations. For example, any of the following code points can represent the letter "áº¯":  
  
-   U+1EAF  
  
-   U+0103 U+0301  
  
-   U+0061 U+0306 U+0301  
  
 Multiple representations for a single character complicate searching, sorting, matching, and other string operations.  
  
 The Unicode standard defines a process called normalization that returns one binary representation of a Unicode character for any of its equivalent binary representations. Normalization can use several algorithms, called normalization forms, that follow different rules. The .NET Framework supports Unicode normalization forms C, D, KC, and KD. When strings have been normalized to the same normalization form, they can be compared by using ordinal comparison.  
  
 An ordinal comparison is a binary comparison of the Unicode scalar value of corresponding <xref:System.Char> objects in each string. TheString class includes a number of methods that can perform an ordinal comparison, including the following:  
  
-   Any overload of the <xref:System.String.Compare%2A>, <xref:System.String.Equals%2A>, <xref:System.String.StartsWith%2A>,  <xref:System.String.EndsWith%2A>, <xref:System.String.IndexOf%2A>,and <xref:System.String.LastIndexOf%2A> methods that includes a <xref:System.StringComparison> parameter. The method performs an ordinal comparison if you supply a value of <xref:System.StringComparison?displayProperty=fullName> or <xref:System.StringComparison> for this parameter.  
  
-   The overloads of the <xref:System.String.CompareOrdinal%2A> method.  
  
-   Methods that use ordinal comparison by default, such as <xref:System.String.Contains%2A>, <xref:System.String.Replace%2A>, and <xref:System.String.Split%2A>.  
  
-   Methods that search for a <xref:System.Char>value or for the elements in a <xref:System.Char> arrayin a string instance. Such methods include <xref:System.String.IndexOf%28System.Char%29> and [Split(Char\[\])](assetId:///M:System.String.Split(System.Char[])?qualifyHint=False&autoUpgrade=False).  
  
 You can determine whether a string is normalized to normalization form C by calling the <xref:System.String.IsNormalized?displayProperty=fullName> method, or you can call the <xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=fullName> method to determine whether a string is normalized to a specified normalization form. You can also call the <xref:System.String.Normalize?displayProperty=fullName> method to convert a string to normalization form C, or you can call the <xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=fullName> method to convert a string to a specified normalization form. For step-by-step information about normalizing and comparing strings, see the <xref:System.String.Normalize> and <xref:System.String.Normalize%28System.Text.NormalizationForm%29> methods.  
  
 The following simple example illustrates string normalization. It defines the letter "á»" in three different ways in three different strings, and uses an ordinal comparison for equality to determine that each string differs from the other two strings. It then converts each string to the supported normalization forms, and again performs an ordinal comparison of each string in a specified normalization form. In each case, the second test for equality shows that the strings are equal.  
  
 [!code-cpp[System.String.Class#14](~/add/codesnippet/cpp/t-system.string_27.cpp)]
 [!code-cs[System.String.Class#14](~/add/codesnippet/csharp/t-system.string_27.cs)]
 [!code-vb[System.String.Class#14](~/add/codesnippet/visualbasic/t-system.string_27.vb)]  
  
 For more information about normalization and normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=fullName>, as well as [Unicode Standard Annex #15: Unicode Normalization Forms](http://unicode.org/reports/tr15/) and the [Normalization FAQ](http://www.unicode.org/faq/normalization.html) on the unicode.org website.  
  
<a name="ByCategory"></a>   
## String operations by category  
 The String class provides members for comparing strings, testing strings for equality, finding characters or substrings in a string, modifying a string, extracting substrings from a string, combining strings, formatting values, copying a string, and normalizing a string.  
  
### Comparing strings  
 You can compare strings to determine their relative position in the sort order by using the following Stringmethods:  
  
-   <xref:System.String.Compare%2A> returns an integer that indicates the relationship of one string to a second string in the sort order.  
  
-   <xref:System.String.CompareOrdinal%2A> returns an integer that indicates the relationship of one string to a second string based on a comparison of their code points.  
  
-   <xref:System.String.CompareTo%2A> returns an integer that indicates the relationship of the current string instance to a second string in the sort order. The <xref:System.String.CompareTo%28System.String%29> method provides the <xref:System.IComparable> and <xref:System.IComparable%601> implementations for the String class.  
  
### Testing strings for equality  
 You call the <xref:System.String.Equals%2A> method to determine whether two strings are equal. The instance <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> and the static <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> overloads let you specify whether the comparison is culture-sensitive or ordinal, and whether case is considered or ignored. Most tests for equality are ordinal, and comparisons for equality that determine access to a system resource (such as a file system object) should always be ordinal.  
  
### Finding characters in a string  
 The String class includes two kinds of search methods:  
  
-   Methods that return a <xref:System.Boolean> value to indicate whether a particular substring is present in a string instance. These include the <xref:System.String.Contains%2A>, <xref:System.String.EndsWith%2A>, and <xref:System.String.StartsWith%2A> methods.  
  
-   Methods that indicate the starting position of a substring in a string instance. These include the <xref:System.String.IndexOf%2A>, <xref:System.String.IndexOfAny%2A>, <xref:System.String.LastIndexOf%2A>, and <xref:System.String.LastIndexOfAny%2A> methods.  
  
> [!WARNING]
>  If you want to search a string for a particular pattern rather than a specific substring, you should use regular expressions. For more information, see [.NET Framework Regular Expressions](../Topic/.NET%20Framework%20Regular%20Expressions.md).  
  
### Modifying a string  
 The String class includes the following methods that appear to modify the value of a string:  
  
-   <xref:System.String.Insert%2A> inserts a string into the current String instance.  
  
-   <xref:System.String.PadLeft%2A> inserts one or more occurrences of a specified character at the beginning of a string.  
  
-   <xref:System.String.PadRight%2A> inserts one or more occurrences of a specified character at the beginning of a string.  
  
-   <xref:System.String.Remove%2A> deletes a substring from the current String instance.  
  
-   <xref:System.String.Replace%2A> replaces a substring with another substring in the current String instance.  
  
-   <xref:System.String.ToLower%2A> and <xref:System.String.ToLowerInvariant%2A> convert all the characters in a string to lowercase.  
  
-   <xref:System.String.ToUpper%2A> and <xref:System.String.ToUpperInvariant%2A> convert all the characters in a string to uppercase.  
  
-   <xref:System.String.Trim%2A> removes all occurrences of a character from the beginning and end of a string.  
  
-   <xref:System.String.TrimEnd%2A> removes all occurrences of a character from the end of a string.  
  
-   <xref:System.String.TrimStart%2A> removes all occurrences of a character from the beginning of a string.  
  
> [!IMPORTANT]
>  All string modification methods return a new String object. They do not modify the value of the current instance.  
  
### Extracting substrings from a string  
 The <xref:System.String.Split%2A?displayProperty=fullName> method separates a single string into multiple strings. Overloads of the method allow you to specify multiple delimiters, to determine the maximum number of substrings that the method extracts, and to determine whether empty strings (which occur when delimiters are adjacent) are included among the returned strings.  
  
### Combining strings  
 The following String methods can be used for string concatenation:  
  
-   <xref:System.String.Concat%2A> combines one or more substrings into a single string.  
  
-   <xref:System.String.Join%2A> concatenates one or more substrings into a single element and adds a separator between each substring.  
  
### Formatting values  
 The <xref:System.String.Format%2A?displayProperty=fullName> method uses the composite formatting feature to replace one or more placeholders in a string with the string representation of some object or value. The <xref:System.String.Format%2A> method is often used to do the following:  
  
-   To embed the string representation of a numeric value in a string.  
  
-   To embed the string representation of a date and time value in a string.  
  
-   To embed the string representation of an enumeration value in a string.  
  
-   To embed the string representation of some object that supports the <xref:System.IFormattable> interface in a string.  
  
-   To right-justify or left-justify a substring in a field within a larger string.  
  
 For detailed information about formatting operations and examples, see the <xref:System.String.Format%2A> overload summary.  
  
### Copying a string  
 You can call the following String methods to make a copy of a string:  
  
-   <xref:System.String.Clone%2A> returns a reference to an existing String object.  
  
-   <xref:System.String.Copy%2A> creates a copy of an existing string.  
  
-   <xref:System.String.CopyTo%2A> copies a portion of a string to a character array.  
  
### Normalizing a string  
 In Unicode, a single character can have multiple code points. Normalization converts these equivalent characters into the same binary representation. The <xref:System.String.Normalize%2A?displayProperty=fullName> method performs the normalization, and the <xref:System.String.IsNormalized%2A?displayProperty=fullName> method determines whether a string is normalized.  
  
 For more information and an example, see the [Normalization](#Normalization) section earlier in this topic.  
  
 ]]></format>
    </remarks>
    <threadsafe>This type is thread safe.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
      </Parameters>
      <Docs>
        <param name="value">A pointer to a null-terminated array of Unicode characters.</param>
        <summary>Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of Unicode characters.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  For examples and comprehensive usage information about this and other `String`constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The current process does not have read access to all the addressed characters.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> specifies an array that contains an invalid Unicode character, or <paramref name="value" /> specifies an address less than 64000.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">An array of Unicode characters.</param>
        <summary>Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by an array of Unicode characters.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
      </Parameters>
      <Docs>
        <param name="value">A pointer to a null-terminated array of 8-bit signed integers. The integers are interpreted using the current system code page encoding (that is, the encoding specified by &lt;xref:System.Text.Encoding.Default%2A?displayProperty=fullName&gt;).</param>
        <summary>Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a pointer to an array of 8-bit signed integers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A new instance of <see cref="T:System.String" /> could not be initialized using <paramref name="value" />, assuming <paramref name="value" /> is encoded in ANSI.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The length of the new string to initialize, which is determined by the null termination character of <paramref name="value" />, is too large to allocate.</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" /> specifies an invalid address.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char c, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char c, int32 count) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="c">A Unicode character.</param>
        <param name="count">The number of times `c` occurs.</param>
        <summary>Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified Unicode character repeated a specified number of times.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> is less than zero.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 startIndex, int32 length) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">A pointer to an array of Unicode characters.</param>
        <param name="startIndex">The starting position within `value`.</param>
        <param name="length">The number of characters within `value` to use.</param>
        <summary>Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of Unicode characters, a starting character position within that array, and a length.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> or <paramref name="length" /> is less than zero, <paramref name="value" /> + <paramref name="startIndex" /> cause a pointer overflow, or the current process does not have read access to all the addressed characters.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> specifies an array that contains an invalid Unicode character, or <paramref name="value" /> + <paramref name="startIndex" /> specifies an address less than 64000.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value, int32 startIndex, int32 length) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">An array of Unicode characters.</param>
        <param name="startIndex">The starting position within `value`.</param>
        <param name="length">The number of characters within `value` to use.</param>
        <summary>Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by an array of Unicode characters, a starting character position within that array, and a length.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> or <paramref name="length" /> is less than zero.  
  
 -or-  
  
 The sum of <paramref name="startIndex" /> and <paramref name="length" /> is greater than the number of elements in <paramref name="value" />.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">A pointer to an array of 8-bit signed integers. The integers are interpreted using the current system code page encoding (that is, the encoding specified by &lt;xref:System.Text.Encoding.Default%2A?displayProperty=fullName&gt;).</param>
        <param name="startIndex">The starting position within `value`.</param>
        <param name="length">The number of characters within `value` to use.</param>
        <summary>Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of 8-bit signed integers, a starting position within that array, and a length.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> or <paramref name="length" /> is less than zero.  
  
 -or-  
  
 The address specified by <paramref name="value" /> + <paramref name="startIndex" /> is too large for the current platform; that is, the address calculation overflowed.  
  
 -or-  
  
 The length of the new string to initialize is too large to allocate.</exception>
        <exception cref="T:System.ArgumentException">The address specified by <paramref name="value" /> + <paramref name="startIndex" /> is less than 64K.  
  
 -or-  
  
 A new instance of <see cref="T:System.String" /> could not be initialized using <paramref name="value" />, assuming <paramref name="value" /> is encoded in ANSI.</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" />, <paramref name="startIndex" />, and <paramref name="length" /> collectively specify an invalid address.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length, System.Text.Encoding enc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length, class System.Text.Encoding enc) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="enc" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="value">A pointer to an array of 8-bit signed integers.</param>
        <param name="startIndex">The starting position within `value`.</param>
        <param name="length">The number of characters within `value` to use.</param>
        <param name="enc">An object that specifies how the array referenced by `value` is encoded. If `enc` is <see langword="null" />, ANSI encoding is assumed.</param>
        <summary>Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of 8-bit signed integers, a starting position within that array, a length, and an <see cref="T:System.Text.Encoding" /> object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> or <paramref name="length" /> is less than zero.  
  
 -or-  
  
 The address specified by <paramref name="value" /> + <paramref name="startIndex" /> is too large for the current platform; that is, the address calculation overflowed.  
  
 -or-  
  
 The length of the new string to initialize is too large to allocate.</exception>
        <exception cref="T:System.ArgumentException">The address specified by <paramref name="value" /> + <paramref name="startIndex" /> is less than 64K.  
  
 -or-  
  
 A new instance of <see cref="T:System.String" /> could not be initialized using <paramref name="value" />, assuming <paramref name="value" /> is encoded as specified by <paramref name="enc" />.</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" />, <paramref name="startIndex" />, and <paramref name="length" /> collectively specify an invalid address.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">A position in the current string.</param>
        <summary>Gets the <see cref="T:System.Char" /> object at a specified position in the current <see cref="T:System.String" /> object.</summary>
        <value>The object at position <paramref name="index" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The `index` parameter is zero-based.  
  
 This property returns the <xref:System.Char> object at the position specified by the `index` parameter. However, a Unicode character might be represented by more than one <xref:System.Char>. Use the <xref:System.Globalization.StringInfo?displayProperty=fullName> class to work with Unicode characters instead of <xref:System.Char> objects. For more information, see the "Char Objects and Unicode Characters" section in the <xref:System.String> class overview.  
  
 In C#, the Chars property is an indexer. In Visual Basic, it is the default property of the <xref:System.String> class. Each <xref:System.Char> object in the string can be accessed by using code such as the following.  
  
 [!code-cs[System.String.Chars#1](~/add/codesnippet/csharp/p-system.string.chars-sy_1.cs)]
 [!code-vb[System.String.Chars#1](~/add/codesnippet/visualbasic/p-system.string.chars-sy_1.vb)]  
  
   
  
## Examples  
 The following example demonstrates how you can use this indexer in a routine to validate a string.  
  
 [!code-vb[Uri_IsHexDigit#1](~/add/codesnippet/visualbasic/p-system.string.chars-sy_2.vb)]
 [!code-cpp[Uri_IsHexDigit#1](~/add/codesnippet/cpp/p-system.string.chars-sy_2.cpp)]
 [!code-cs[Uri_IsHexDigit#1](~/add/codesnippet/csharp/p-system.string.chars-sy_2.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> is greater than or equal to the length of this object or less than zero.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a reference to this instance of <see cref="T:System.String" />.</summary>
        <returns>This instance of <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The return value is not an independent copy of this instance; it is simply another view of the same data. Use the <xref:System.String.Copy%2A> or <xref:System.String.CopyTo%2A> method to create a separate <xref:System.String> object with the same value as this instance.  
  
 Because the Clone method simply returns the existing string instance, there is little reason to call it directly.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">The first string to compare.</param>
        <param name="strB">The second string to compare.</param>
        <summary>Compares two specified <see cref="T:System.String" /> objects and returns an integer that indicates their relative position in the sort order.</summary>
        <returns>A 32-bit signed integer that indicates the lexical relationship between the two comparands.  
  
 <list type="table">  
<listheader>  
<term> Value  
  
 </term>  
<description> Condition  
  
 </description>  
</listheader>  
<item>  
<term> Less than zero  
  
 </term>  
<description> <paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.  
  
 </description>  
</item>  
<item>  
<term> Zero  
  
 </term>  
<description> <paramref name="strA" /> occurs in the same position as <paramref name="strB" /> in the sort order.  
  
 </description>  
</item>  
<item>  
<term> Greater than zero  
  
 </term>  
<description> <paramref name="strA" /> follows <paramref name="strB" /> in the sort order.  
  
 </description>  
</item>  
</list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters. For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.  
  
 The comparison is performed using word sort rules. For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=fullName>.  
  
> [!WARNING]
>  When comparing strings, you should call the<xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses. For more information, see [Best Practices for Using Strings](../Topic/Best%20Practices%20for%20Using%20Strings%20in%20the%20.NET%20Framework.md).  
  
 One or both comparands can be `null`. By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.  
  
 The comparison terminates when an inequality is discovered or both strings have been compared. However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater. The return value is the result of the last comparison performed.  
  
 Unexpected results can occur when comparisons are affected by culture-specific casing rules. For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".  
  
 [!code-cpp[System.String.Compare#10](~/add/codesnippet/cpp/m-system.string.compare-_1_1.cpp)]
 [!code-cs[System.String.Compare#10](~/add/codesnippet/csharp/m-system.string.compare-_1_1.cs)]
 [!code-vb[System.String.Compare#10](~/add/codesnippet/visualbasic/m-system.string.compare-_1_1.vb)]  
  
 Compare the path name to "file" using an ordinal comparison. The correct code to do this is as follows:  
  
 [!code-cpp[System.String.Compare#11](~/add/codesnippet/cpp/m-system.string.compare-_1_2.cpp)]
 [!code-cs[System.String.Compare#11](~/add/codesnippet/csharp/m-system.string.compare-_1_2.cs)]
 [!code-vb[System.String.Compare#11](~/add/codesnippet/visualbasic/m-system.string.compare-_1_2.vb)]  
  
   
  
## Examples  
 The following example calls the Compare method to compare three sets of strings.  
  
 [!code-cpp[System.String.Compare#18](~/add/codesnippet/cpp/m-system.string.compare-_1_4.cpp)]
 [!code-vb[System.String.Compare#18](~/add/codesnippet/visualbasic/m-system.string.compare-_1_4.vb)]
 [!code-cs[System.String.Compare#18](~/add/codesnippet/csharp/m-system.string.compare-_1_4.cs)]  
  
 In the following example, the `ReverseStringComparer` class demonstrates how you can evaluate two strings with the Compare method.  
  
 [!code-cs[ArrayList#7](~/add/codesnippet/csharp/m-system.string.compare-_1_5.cs)]
 [!code-cpp[ArrayList#7](~/add/codesnippet/cpp/m-system.string.compare-_1_5.cpp)]
 [!code-vb[ArrayList#7](~/add/codesnippet/visualbasic/m-system.string.compare-_1_5.vb)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA">The first string to compare.</param>
        <param name="strB">The second string to compare.</param>
        <param name="ignoreCase">
          <see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</param>
        <summary>Compares two specified <see cref="T:System.String" /> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.</summary>
        <returns>A 32-bit signed integer that indicates the lexical relationship between the two comparands.  
  
 <list type="table">  
<listheader>  
<term> Value  
  
 </term>  
<description> Condition  
  
 </description>  
</listheader>  
<item>  
<term> Less than zero  
  
 </term>  
<description> <paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.  
  
 </description>  
</item>  
<item>  
<term> Zero  
  
 </term>  
<description> <paramref name="strA" /> occurs in the same position as <paramref name="strB" /> in the sort order.  
  
 </description>  
</item>  
<item>  
<term> Greater than zero  
  
 </term>  
<description> <paramref name="strA" /> follows <paramref name="strB" /> in the sort order.  
  
 </description>  
</item>  
</list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters. For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.  
  
 The comparison is performed using word sort rules. For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=fullName>.  
  
> [!WARNING]
>  When comparing strings, you should call the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses. For more information, see [Best Practices for Using Strings](../Topic/Best%20Practices%20for%20Using%20Strings%20in%20the%20.NET%20Framework.md).  
  
 One or both comparands can be `null`. By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.  
  
 The comparison terminates when an inequality is discovered or both strings have been compared. However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater. The return value is the result of the last comparison performed.  
  
 Unexpected results can occur when comparisons are affected by culture-specific casing rules. For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".  
  
 [!code-cpp[System.String.Compare#12](~/add/codesnippet/cpp/m-system.string.compare-_2_1.cpp)]
 [!code-cs[System.String.Compare#12](~/add/codesnippet/csharp/m-system.string.compare-_2_1.cs)]
 [!code-vb[System.String.Compare#12](~/add/codesnippet/visualbasic/m-system.string.compare-_2_1.vb)]  
  
 Compare the path name to "file" using an ordinal comparison. The correct code to do this is as follows:  
  
 [!code-cpp[System.String.Compare#13](~/add/codesnippet/cpp/m-system.string.compare-_2_2.cpp)]
 [!code-cs[System.String.Compare#13](~/add/codesnippet/csharp/m-system.string.compare-_2_2.cs)]
 [!code-vb[System.String.Compare#13](~/add/codesnippet/visualbasic/m-system.string.compare-_2_2.vb)]  
  
   
  
## Examples  
 The following example demonstrates that the Compare method is equivalent to using <xref:System.String.ToUpper%2A> or <xref:System.String.ToLower%2A> when comparing strings.  
  
 [!code-cpp[System.String.Compare#18](~/add/codesnippet/cpp/m-system.string.compare-_2_4.cpp)]
 [!code-vb[System.String.Compare#18](~/add/codesnippet/visualbasic/m-system.string.compare-_2_4.vb)]
 [!code-cs[System.String.Compare#18](~/add/codesnippet/csharp/m-system.string.compare-_2_4.cs)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA">The first string to compare.</param>
        <param name="strB">The second string to compare.</param>
        <param name="comparisonType">One of the enumeration values that specifies the rules to use in the comparison.</param>
        <summary>Compares two specified <see cref="T:System.String" /> objects using the specified rules, and returns an integer that indicates their relative position in the sort order.</summary>
        <returns>A 32-bit signed integer that indicates the lexical relationship between the two comparands.  
  
 <list type="table">  
<listheader>  
<term> Value  
  
 </term>  
<description> Condition  
  
 </description>  
</listheader>  
<item>  
<term> Less than zero  
  
 </term>  
<description> <paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.  
  
 </description>  
</item>  
<item>  
<term> Zero  
  
 </term>  
<description> <paramref name="strA" /> is in the same position as <paramref name="strB" /> in the sort order.  
  
 </description>  
</item>  
<item>  
<term> Greater than zero  
  
 </term>  
<description> <paramref name="strA" /> follows <paramref name="strB" /> in the sort order.  
  
 </description>  
</item>  
</list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the comparands, or use word (culture-sensitive) or ordinal (culture-insensitive) sort rules.  
  
 One or both comparands can be `null`. By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.  
  
 The comparison terminates when an inequality is discovered or both strings have been compared. However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with remaining characters is considered greater. The return value is the result of the last comparison performed.  
  
 Unexpected results can occur when comparisons are affected by culture-specific casing rules. For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".  
  
 [!code-cpp[System.String.Compare#16](~/add/codesnippet/cpp/m-system.string.compare-_0_1.cpp)]
 [!code-cs[System.String.Compare#16](~/add/codesnippet/csharp/m-system.string.compare-_0_1.cs)]
 [!code-vb[System.String.Compare#16](~/add/codesnippet/visualbasic/m-system.string.compare-_0_1.vb)]  
  
 Compare the path name to "file" using an ordinal comparison. The correct code to do this is as follows:  
  
 [!code-cpp[System.String.Compare#17](~/add/codesnippet/cpp/m-system.string.compare-_0_2.cpp)]
 [!code-cs[System.String.Compare#17](~/add/codesnippet/csharp/m-system.string.compare-_0_2.cs)]
 [!code-vb[System.String.Compare#17](~/add/codesnippet/visualbasic/m-system.string.compare-_0_2.vb)]  
  
   
  
## Examples  
 The following example compares three versions of the letter "I". The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.  
  
 [!code-cs[System.String.CompareCmp#1](~/add/codesnippet/csharp/m-system.string.compare-_0_3.cs)]
 [!code-cpp[System.String.CompareCmp#1](~/add/codesnippet/cpp/m-system.string.compare-_0_3.cpp)]
 [!code-vb[System.String.CompareCmp#1](~/add/codesnippet/visualbasic/m-system.string.compare-_0_3.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.StringComparison" /> is not supported.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA">The first string to compare.</param>
        <param name="strB">The second string to compare.</param>
        <param name="ignoreCase">
          <see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</param>
        <param name="culture">An object that supplies culture-specific comparison information.</param>
        <summary>Compares two specified <see cref="T:System.String" /> objects, ignoring or honoring their case, and using culture-specific information to influence the comparison, and returns an integer that indicates their relative position in the sort order.</summary>
        <returns>A 32-bit signed integer that indicates the lexical relationship between the two comparands.  
  
 <list type="table">  
<listheader>  
<term> Value  
  
 </term>  
<description> Condition  
  
 </description>  
</listheader>  
<item>  
<term> Less than zero  
  
 </term>  
<description> <paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.  
  
 </description>  
</item>  
<item>  
<term> Zero  
  
 </term>  
<description> <paramref name="strA" /> occurs in the same position as <paramref name="strB" /> in the sort order.  
  
 </description>  
</item>  
<item>  
<term> Greater than zero  
  
 </term>  
<description> <paramref name="strA" /> follows <paramref name="strB" /> in the sort order.  
  
 </description>  
</item>  
</list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The comparison uses the `culture` parameter to obtain culture-specific information such as casing rules and the alphabetic order of individual characters. For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.  
  
 The comparison is performed using word sort rules. For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=fullName>.  
  
 One or both comparands can be `null`. By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.  
  
 The comparison terminates when an inequality is discovered or both strings have been compared. However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater. The return value is the result of the last comparison performed.  
  
 Unexpected results can occur when comparisons are affected by culture-specific casing rules. For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".  
  
 [!code-cpp[System.String.Compare#14](~/add/codesnippet/cpp/ad8a53ca-9e37-4bd2-aed7-_1.cpp)]
 [!code-cs[System.String.Compare#14](~/add/codesnippet/csharp/ad8a53ca-9e37-4bd2-aed7-_1.cs)]
 [!code-vb[System.String.Compare#14](~/add/codesnippet/visualbasic/ad8a53ca-9e37-4bd2-aed7-_1.vb)]  
  
 Compare the path name to "file" using an ordinal comparison. The correct code to do this is as follows:  
  
 [!code-cpp[System.String.Compare#15](~/add/codesnippet/cpp/ad8a53ca-9e37-4bd2-aed7-_2.cpp)]
 [!code-cs[System.String.Compare#15](~/add/codesnippet/csharp/ad8a53ca-9e37-4bd2-aed7-_2.cs)]
 [!code-vb[System.String.Compare#15](~/add/codesnippet/visualbasic/ad8a53ca-9e37-4bd2-aed7-_2.vb)]  
  
   
  
## Examples  
 The following example demonstrates how culture can affect a comparison. In Czech - Czech Republic culture, "ch" is a single character that is greater than "d". However, in English - United States culture, "ch" consists of two characters, and "c" is less than "d".  
  
 [!code-cs[string.comp4#1](~/add/codesnippet/csharp/ad8a53ca-9e37-4bd2-aed7-_4.cs)]
 [!code-vb[string.comp4#1](~/add/codesnippet/visualbasic/ad8a53ca-9e37-4bd2-aed7-_4.vb)]
 [!code-cpp[string.comp4#1](~/add/codesnippet/cpp/ad8a53ca-9e37-4bd2-aed7-_4.cpp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> is <see langword="null" />.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA">The first string to compare.</param>
        <param name="strB">The second string to compare.</param>
        <param name="culture">The culture that supplies culture-specific comparison information.</param>
        <param name="options">Options to use when performing the comparison (such as ignoring case or symbols).</param>
        <summary>Compares two specified <see cref="T:System.String" /> objects using the specified comparison options and culture-specific information to influence the comparison, and returns an integer that indicates the relationship of the two strings to each other in the sort order.</summary>
        <returns>A 32-bit signed integer that indicates the lexical relationship between <paramref name="strA" /> and <paramref name="strB" />, as shown in the following table  
  
 <list type="table">  
<listheader>  
<term> Value  
  
 </term>  
<description> Condition  
  
 </description>  
</listheader>  
<item>  
<term> Less than zero  
  
 </term>  
<description> <paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.  
  
 </description>  
</item>  
<item>  
<term> Zero  
  
 </term>  
<description> <paramref name="strA" /> occurs in the same position as <paramref name="strB" /> in the sort order.  
  
 </description>  
</item>  
<item>  
<term> Greater than zero  
  
 </term>  
<description> <paramref name="strA" /> follows <paramref name="strB" /> in the sort order.  
  
 </description>  
</item>  
</list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The comparison uses the `culture` parameter to obtain culture-specific information, such as casing rules and the alphabetical order of individual characters. For example, a particular culture could specify that certain combinations of characters be treated as a single character, that uppercase and lowercase characters be compared in a particular way, or that the sort order of a character depends on the characters that precede or follow it.  
  
> [!CAUTION]
>  The Compare method is designed primarily for use in sorting or alphabetizing operations. It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent (that is, when the purpose of the method call is to test for a return value of zero). To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.  
  
 The comparison can be further specified by the `options` parameter, which consists of one or more members of the <xref:System.Globalization.CompareOptions> enumeration. However, because the purpose of this method is to conduct a culture-sensitive string comparison, the <xref:System.Globalization.CompareOptions?displayProperty=fullName> and <xref:System.Globalization.CompareOptions?displayProperty=fullName> values have no effect.  
  
 Either or both comparands can be `null`. By definition, any string, including <xref:System.String.Empty?displayProperty=fullName>, compares greater than a null reference, and two null references compare equal to each other.  
  
 The comparison terminates when an inequality is discovered or both strings have been compared. However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with the remaining characters is considered greater.  
  
   
  
## Examples  
 The following example compares two strings in three different ways: using linguistic comparison for the en-US culture; using linguistic case-sensitive comparison for the en-US culture; and using an ordinal comparison. It illustrates how the three methods of comparison produce three different results.  
  
 [!code-cs[System.String.Compare#1](~/add/codesnippet/csharp/320b2dff-7f26-42ad-8954-_1.cs)]
 [!code-cpp[System.String.Compare#1](~/add/codesnippet/cpp/320b2dff-7f26-42ad-8954-_1.cpp)]
 [!code-vb[System.String.Compare#1](~/add/codesnippet/visualbasic/320b2dff-7f26-42ad-8954-_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> is not a <see cref="T:System.Globalization.CompareOptions" /> value.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> is <see langword="null" />.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">The first string to use in the comparison.</param>
        <param name="indexA">The position of the substring within `strA`.</param>
        <param name="strB">The second string to use in the comparison.</param>
        <param name="indexB">The position of the substring within `strB`.</param>
        <param name="length">The maximum number of characters in the substrings to compare.</param>
        <summary>Compares substrings of two specified <see cref="T:System.String" /> objects and returns an integer that indicates their relative position in the sort order.</summary>
        <returns>A 32-bit signed integer indicating the lexical relationship between the two comparands.  
  
 <list type="table">  
<listheader>  
<term> Value  
  
 </term>  
<description> Condition  
  
 </description>  
</listheader>  
<item>  
<term> Less than zero  
  
 </term>  
<description> The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.  
  
 </description>  
</item>  
<item>  
<term> Zero  
  
 </term>  
<description> The substrings occur in the same position in the sort order, or <paramref name="length" /> is zero.  
  
 </description>  
</item>  
<item>  
<term> Greater than zero  
  
 </term>  
<description> The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.  
  
 </description>  
</item>  
</list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The substrings to compare start in `strA` at `indexA` and in `strB` at `indexB`. Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero. The length of the first substring is equal to the length of `strA` minus `indexA` plus one. The length of the second substring is equal to the length of `strB` minus `indexB` plus one.  
  
 The number of characters to compare is the lesser of the lengths of the two substrings, and `length`. The `indexA`, `indexB`, and `length` parameters must be nonnegative.  
  
 The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters. For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.  
  
 The comparison is performed using word sort rules. For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=fullName>.  
  
> [!WARNING]
>  When comparing strings, you should call the <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses. For more information, see [Best Practices for Using Strings](../Topic/Best%20Practices%20for%20Using%20Strings%20in%20the%20.NET%20Framework.md).  
  
 One or both comparands can be `null`. By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.  
  
 The comparison terminates when an inequality is discovered or both substrings have been compared. However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater. The return value is the result of the last comparison performed.  
  
 Unexpected results can occur when comparisons are affected by culture-specific casing rules. For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".  
  
 [!code-cpp[System.String.Compare#2](~/add/codesnippet/cpp/8c5c93c7-7358-46af-8568-_1.cpp)]
 [!code-cs[System.String.Compare#2](~/add/codesnippet/csharp/8c5c93c7-7358-46af-8568-_1.cs)]
 [!code-vb[System.String.Compare#2](~/add/codesnippet/visualbasic/8c5c93c7-7358-46af-8568-_1.vb)]  
  
 Compare the path name to "file" using an ordinal comparison. The correct code to do this is as follows:  
  
 [!code-cpp[System.String.Compare#3](~/add/codesnippet/cpp/8c5c93c7-7358-46af-8568-_2.cpp)]
 [!code-cs[System.String.Compare#3](~/add/codesnippet/csharp/8c5c93c7-7358-46af-8568-_2.cs)]
 [!code-vb[System.String.Compare#3](~/add/codesnippet/visualbasic/8c5c93c7-7358-46af-8568-_2.vb)]  
  
   
  
## Examples  
 The following example compares two substrings.  
  
 [!code-cs[string.compare3#1](~/add/codesnippet/csharp/8c5c93c7-7358-46af-8568-_3.cs)]
 [!code-vb[string.compare3#1](~/add/codesnippet/visualbasic/8c5c93c7-7358-46af-8568-_3.vb)]
 [!code-cpp[string.compare3#1](~/add/codesnippet/cpp/8c5c93c7-7358-46af-8568-_3.cpp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> is greater than <paramref name="strA" />.&lt;xref:System.String.Length%2A&gt;.  
  
 -or-  
  
 <paramref name="indexB" /> is greater than <paramref name="strB" />.&lt;xref:System.String.Length%2A&gt;.  
  
 -or-  
  
 <paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.  
  
 -or-  
  
 Either <paramref name="indexA" /> or <paramref name="indexB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA">The first string to use in the comparison.</param>
        <param name="indexA">The position of the substring within `strA`.</param>
        <param name="strB">The second string to use in the comparison.</param>
        <param name="indexB">The position of the substring within `strB`.</param>
        <param name="length">The maximum number of characters in the substrings to compare.</param>
        <param name="ignoreCase">
          <see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</param>
        <summary>Compares substrings of two specified <see cref="T:System.String" /> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.</summary>
        <returns>A 32-bit signed integer that indicates the lexical relationship between the two comparands.  
  
 <list type="table">  
<listheader>  
<term> Value  
  
 </term>  
<description> Condition  
  
 </description>  
</listheader>  
<item>  
<term> Less than zero  
  
 </term>  
<description> The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.  
  
 </description>  
</item>  
<item>  
<term> Zero  
  
 </term>  
<description> The substrings occur in the same position in the sort order, or <paramref name="length" /> is zero.  
  
 </description>  
</item>  
<item>  
<term> Greater than zero  
  
 </term>  
<description> The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.  
  
 </description>  
</item>  
</list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The substrings to compare start in `strA` at `indexA`, and in `strB` at `indexB`. Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero. The length of the first substring is equal to the length of `strA` minus `indexA` plus one. The length of the second substring is equal to the length of `strB` minus `indexB` plus one.  
  
 The number of characters to compare is the lesser of the lengths of the two substrings, and `length`. The `indexA`, `indexB`, and `length` parameters must be nonnegative.  
  
 The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters. For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.  
  
 The comparison is performed using word sort rules. For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=fullName>.  
  
> [!WARNING]
>  When comparing strings, you should call the <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses. For more information, see [Best Practices for Using Strings](../Topic/Best%20Practices%20for%20Using%20Strings%20in%20the%20.NET%20Framework.md).  
  
 One or both comparands can be `null`. By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.  
  
 The comparison terminates when an inequality is discovered or both substrings have been compared. However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater. The return value is the result of the last comparison performed.  
  
 Unexpected results can occur when comparisons are affected by culture-specific casing rules. For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".  
  
 [!code-cpp[System.String.Compare#4](~/add/codesnippet/cpp/77bf3f9a-3a96-4da3-94d4-_1.cpp)]
 [!code-cs[System.String.Compare#4](~/add/codesnippet/csharp/77bf3f9a-3a96-4da3-94d4-_1.cs)]
 [!code-vb[System.String.Compare#4](~/add/codesnippet/visualbasic/77bf3f9a-3a96-4da3-94d4-_1.vb)]  
  
 The path name needs to be compared in an invariant manner. The correct code to do this is as follows.  
  
 [!code-cpp[System.String.Compare#5](~/add/codesnippet/cpp/77bf3f9a-3a96-4da3-94d4-_2.cpp)]
 [!code-cs[System.String.Compare#5](~/add/codesnippet/csharp/77bf3f9a-3a96-4da3-94d4-_2.cs)]
 [!code-vb[System.String.Compare#5](~/add/codesnippet/visualbasic/77bf3f9a-3a96-4da3-94d4-_2.vb)]  
  
   
  
## Examples  
 The following example performs two comparisons of two substrings that only differ in case. The first comparison ignores case and the second comparison considers case.  
  
 [!code-cs[string.compare4#1](~/add/codesnippet/csharp/77bf3f9a-3a96-4da3-94d4-_3.cs)]
 [!code-cpp[string.compare4#1](~/add/codesnippet/cpp/77bf3f9a-3a96-4da3-94d4-_3.cpp)]
 [!code-vb[string.compare4#1](~/add/codesnippet/visualbasic/77bf3f9a-3a96-4da3-94d4-_3.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> is greater than <paramref name="strA" />.&lt;xref:System.String.Length%2A&gt;.  
  
 -or-  
  
 <paramref name="indexB" /> is greater than <paramref name="strB" />.&lt;xref:System.String.Length%2A&gt;.  
  
 -or-  
  
 <paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.  
  
 -or-  
  
 Either <paramref name="indexA" /> or <paramref name="indexB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA">The first string to use in the comparison.</param>
        <param name="indexA">The position of the substring within `strA`.</param>
        <param name="strB">The second string to use in the comparison.</param>
        <param name="indexB">The position of the substring within `strB`.</param>
        <param name="length">The maximum number of characters in the substrings to compare.</param>
        <param name="comparisonType">One of the enumeration values that specifies the rules to use in the comparison.</param>
        <summary>Compares substrings of two specified <see cref="T:System.String" /> objects using the specified rules, and returns an integer that indicates their relative position in the sort order.</summary>
        <returns>A 32-bit signed integer that indicates the lexical relationship between the two comparands.  
  
 <list type="table">  
<listheader>  
<term> Value  
  
 </term>  
<description> Condition  
  
 </description>  
</listheader>  
<item>  
<term> Less than zero  
  
 </term>  
<description> The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.  
  
 </description>  
</item>  
<item>  
<term> Zero  
  
 </term>  
<description> The substrings occur in the same position in the sort order, or the <paramref name="length" /> parameter is zero.  
  
 </description>  
</item>  
<item>  
<term> Greater than zero  
  
 </term>  
<description> The substring in <paramref name="strA" /> follllows the substring in <paramref name="strB" /> in the sort order.  
  
 </description>  
</item>  
</list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The substrings to compare start in `strA` at `indexA` and in `strB` at `indexB`. Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero, not position one. The length of the first substring is equal to the length of `strA` minus `indexA` plus one. The length of the second substring is equal to the length of `strB` minus `indexB` plus one.  
  
 The number of characters to compare is the lesser of the lengths of the two substrings, and `length`. The `indexA`, `indexB`, and `length` parameters must be nonnegative.  
  
 The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the comparands, or use word (culture-sensitive) or ordinal (culture-insensitive) sort rules.  
  
 One or both comparands can be `null`. By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.  
  
 The comparison terminates when an inequality is discovered or both substrings have been compared. However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with remaining characters is considered greater. The return value is the result of the last comparison performed.  
  
 Unexpected results can occur when comparisons are affected by culture-specific casing rules. For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".  
  
 [!code-cpp[System.String.Compare#8](~/add/codesnippet/cpp/5ade3071-47e0-44d8-8163-_1.cpp)]
 [!code-cs[System.String.Compare#8](~/add/codesnippet/csharp/5ade3071-47e0-44d8-8163-_1.cs)]
 [!code-vb[System.String.Compare#8](~/add/codesnippet/visualbasic/5ade3071-47e0-44d8-8163-_1.vb)]  
  
 Compare the path name to "file" using an ordinal comparison. The correct code to do this is as follows:  
  
 [!code-cpp[System.String.Compare#9](~/add/codesnippet/cpp/5ade3071-47e0-44d8-8163-_2.cpp)]
 [!code-cs[System.String.Compare#9](~/add/codesnippet/csharp/5ade3071-47e0-44d8-8163-_2.cs)]
 [!code-vb[System.String.Compare#9](~/add/codesnippet/visualbasic/5ade3071-47e0-44d8-8163-_2.vb)]  
  
   
  
## Examples  
 The following example compares two substrings.  
  
 [!code-cs[string.compare3#1](~/add/codesnippet/csharp/5ade3071-47e0-44d8-8163-_3.cs)]
 [!code-vb[string.compare3#1](~/add/codesnippet/visualbasic/5ade3071-47e0-44d8-8163-_3.vb)]
 [!code-cpp[string.compare3#1](~/add/codesnippet/cpp/5ade3071-47e0-44d8-8163-_3.cpp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> is greater than <paramref name="strA" />.&lt;xref:System.String.Length%2A&gt;.  
  
 -or-  
  
 <paramref name="indexB" /> is greater than <paramref name="strB" />.&lt;xref:System.String.Length%2A&gt;.  
  
 -or-  
  
 <paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.  
  
 -or-  
  
 Either <paramref name="indexA" /> or <paramref name="indexB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA">The first string to use in the comparison.</param>
        <param name="indexA">The position of the substring within `strA`.</param>
        <param name="strB">The second string to use in the comparison.</param>
        <param name="indexB">The position of the substring within `strB`.</param>
        <param name="length">The maximum number of characters in the substrings to compare.</param>
        <param name="ignoreCase">
          <see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</param>
        <param name="culture">An object that supplies culture-specific comparison information.</param>
        <summary>Compares substrings of two specified <see cref="T:System.String" /> objects, ignoring or honoring their case and using culture-specific information to influence the comparison, and returns an integer that indicates their relative position in the sort order.</summary>
        <returns>An integer that indicates the lexical relationship between the two comparands.  
  
 <list type="table">  
<listheader>  
<term> Value  
  
 </term>  
<description> Condition  
  
 </description>  
</listheader>  
<item>  
<term> Less than zero  
  
 </term>  
<description> The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.  
  
 </description>  
</item>  
<item>  
<term> Zero  
  
 </term>  
<description> The substrings occur in the same position in the sort order, or <paramref name="length" /> is zero.  
  
 </description>  
</item>  
<item>  
<term> Greater than zero  
  
 </term>  
<description> The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.  
  
 </description>  
</item>  
</list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The substrings to compare start in `strA` at `indexA`, and in `strB` at `indexB`. Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero, not position one. The length of the first substring is equal to the length of `strA` minus `indexA` plus one. The length of the second substring is equal to the length of `strB` minus `indexB` plus one.  
  
 The number of characters to compare is the lesser of the lengths of the two substrings, and `length`. The `indexA`, `indexB`, and `length` parameters must be nonnegative.  
  
 The comparison uses the `culture` parameter to obtain culture-specific information such as casing rules and the alphabetic order of individual characters. For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.  
  
 The comparison is performed using word sort rules. For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=fullName>.  
  
 One or both comparands can be `null`. By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.  
  
 The comparison terminates when an inequality is discovered or both substrings have been compared. However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater. The return value is the result of the last comparison performed.  
  
 Unexpected results can occur when comparisons are affected by culture-specific casing rules. For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".  
  
 [!code-cpp[System.String.Compare#6](~/add/codesnippet/cpp/1eeafd1b-4faf-4e9a-972f-_1.cpp)]
 [!code-cs[System.String.Compare#6](~/add/codesnippet/csharp/1eeafd1b-4faf-4e9a-972f-_1.cs)]
 [!code-vb[System.String.Compare#6](~/add/codesnippet/visualbasic/1eeafd1b-4faf-4e9a-972f-_1.vb)]  
  
 Compare the path name to "file" using an ordinal comparison. The correct code to do this is as follows:  
  
 [!code-cpp[System.String.Compare#7](~/add/codesnippet/cpp/1eeafd1b-4faf-4e9a-972f-_2.cpp)]
 [!code-cs[System.String.Compare#7](~/add/codesnippet/csharp/1eeafd1b-4faf-4e9a-972f-_2.cs)]
 [!code-vb[System.String.Compare#7](~/add/codesnippet/visualbasic/1eeafd1b-4faf-4e9a-972f-_2.vb)]  
  
   
  
## Examples  
 The following example compares two substrings using different cultures and ignoring the case of the substrings. The choice of culture affects how the letter "I" is compared.  
  
 [!code-cs[string.compare5#1](~/add/codesnippet/csharp/1eeafd1b-4faf-4e9a-972f-_3.cs)]
 [!code-cpp[string.compare5#1](~/add/codesnippet/cpp/1eeafd1b-4faf-4e9a-972f-_3.cpp)]
 [!code-vb[string.compare5#1](~/add/codesnippet/visualbasic/1eeafd1b-4faf-4e9a-972f-_3.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> is greater than <paramref name="strA" />.&lt;xref:System.String.Length%2A&gt;.  
  
 -or-  
  
 <paramref name="indexB" /> is greater than <paramref name="strB" />.&lt;xref:System.String.Length%2A&gt;.  
  
 -or-  
  
 <paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.  
  
 -or-  
  
 Either <paramref name="strA" /> or <paramref name="strB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> is <see langword="null" />.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA">The first string to use in the comparison.</param>
        <param name="indexA">The starting position of the substring within `strA`.</param>
        <param name="strB">The second string to use in the comparison.</param>
        <param name="indexB">The starting position of the substring within `strB`.</param>
        <param name="length">The maximum number of characters in the substrings to compare.</param>
        <param name="culture">An object that supplies culture-specific comparison information.</param>
        <param name="options">Options to use when performing the comparison (such as ignoring case or symbols).</param>
        <summary>Compares substrings of two specified <see cref="T:System.String" /> objects using the specified comparison options and culture-specific information to influence the comparison, and returns an integer that indicates the relationship of the two substrings to each other in the sort order.</summary>
        <returns>An integer that indicates the lexical relationship between the two substrings, as shown in the following table.  
  
 <list type="table">  
<listheader>  
<term> Value  
  
 </term>  
<description> Condition  
  
 </description>  
</listheader>  
<item>  
<term> Less than zero  
  
 </term>  
<description> The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.  
  
 </description>  
</item>  
<item>  
<term> Zero  
  
 </term>  
<description> The substrings occur in the same position in the sort order, or <paramref name="length" /> is zero.  
  
 </description>  
</item>  
<item>  
<term> Greater than zero  
  
 </term>  
<description> The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.  
  
 </description>  
</item>  
</list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The substrings to compare start in `strA` at position `indexA` and in `strB` at position `indexB`. The length of the first substring is the length of `strA` minus `indexA`. The length of the second substring is the length of `strB` minus `indexB`.  
  
 The number of characters to compare is the lesser of the lengths of the two substrings, and `length`. The `indexA`, `indexB`, and `length` parameters must be nonnegative.  
  
 The comparison uses the `culture` parameter to obtain culture-specific information, such as casing rules and the alphabetical order of individual characters. For example, a particular culture could specify that certain combinations of characters be treated as a single character, that uppercase and lowercase characters be compared in a particular way, or that the sort order of a character depends on the characters that precede or follow it.  
  
> [!CAUTION]
>  The Compare method is designed primarily for use in sorting or alphabetizing operations. It should not be used when the primary purpose of the method call is to determine whether two substrings are equivalent (that is, when the purpose of the method call is to test for a return value of zero). To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.  
  
 One or both of `strA` and `strB` can be `null`. By definition, any string, including <xref:System.String.Empty?displayProperty=fullName>, compares greater than a null reference, and two null references compare equal to each other.  
  
 The comparison can be further specified by the `options` parameter, which consists of one or more members of the <xref:System.Globalization.CompareOptions?displayProperty=fullName> enumeration. However, because the purpose of this method is to conduct a culture-sensitive string comparison, the <xref:System.Globalization.CompareOptions?displayProperty=fullName> and <xref:System.Globalization.CompareOptions?displayProperty=fullName> values have no effect.  
  
 The comparison terminates when an inequality is discovered or both substrings have been compared. However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with the remaining characters is considered greater. The return value is the result of the last comparison performed.  
  
   
  
## Examples  
 The following example uses the Compare method to compare the last names of two people. It then lists them in alphabetical order.  
  
 [!code-cs[System.String.Compare5#1](~/add/codesnippet/csharp/f9ec89fd-0371-40d1-89b2-_1.cs)]
 [!code-vb[System.String.Compare5#1](~/add/codesnippet/visualbasic/f9ec89fd-0371-40d1-89b2-_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> is not a <see cref="T:System.Globalization.CompareOptions" /> value.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> is greater than <paramref name="strA" /><see langword=".Length" />.  
  
 -or-  
  
 <paramref name="indexB" /> is greater than <paramref name="strB" /><see langword=".Length" />.  
  
 -or-  
  
 <paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.  
  
 -or-  
  
 Either <paramref name="strA" /> or <paramref name="strB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> is <see langword="null" />.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, string strB) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">The first string to compare.</param>
        <param name="strB">The second string to compare.</param>
        <summary>Compares two specified <see cref="T:System.String" /> objects by evaluating the numeric values of the corresponding <see cref="T:System.Char" /> objects in each string.</summary>
        <returns>An integer that indicates the lexical relationship between the two comparands.  
  
 <list type="table">  
<listheader>  
<term> Value  
  
 </term>  
<description> Condition  
  
 </description>  
</listheader>  
<item>  
<term> Less than zero  
  
 </term>  
<description> <paramref name="strA" /> is less than <paramref name="strB" />.  
  
 </description>  
</item>  
<item>  
<term> Zero  
  
 </term>  
<description> <paramref name="strA" /> and <paramref name="strB" /> are equal.  
  
 </description>  
</item>  
<item>  
<term> Greater than zero  
  
 </term>  
<description> <paramref name="strA" /> is greater than <paramref name="strB" />.  
  
 </description>  
</item>  
</list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method performs a case-sensitive comparison using ordinal sort rules. For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=fullName>. To perform a case-insensitive comparison using ordinal sort rules, call the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method with the `comparisonType` argument set to <xref:System.StringComparison?displayProperty=fullName>.  
  
 Because CompareOrdinalis a static method, `strA` and `strB` can be `null`. If both values are `null`, the method returns 0 (zero), which indicates that `strA` and `strB` are equal. If only one of the values is `null`, the method considers the non-null value to be greater.  
  
   
  
## Examples  
 The following example performs and ordinal comparison of two strings that only differ in case.  
  
 [!code-cpp[string.compareordinal#1](~/add/codesnippet/cpp/m-system.string.compareo_1.cpp)]
 [!code-cs[string.compareordinal#1](~/add/codesnippet/csharp/m-system.string.compareo_1.cs)]
 [!code-vb[string.compareordinal#1](~/add/codesnippet/visualbasic/m-system.string.compareo_1.vb)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">The first string to use in the comparison.</param>
        <param name="indexA">The starting index of the substring in `strA`.</param>
        <param name="strB">The second string to use in the comparison.</param>
        <param name="indexB">The starting index of the substring in `strB`.</param>
        <param name="length">The maximum number of characters in the substrings to compare.</param>
        <summary>Compares substrings of two specified <see cref="T:System.String" /> objects by evaluating the numeric values of the corresponding <see cref="T:System.Char" /> objects in each substring.</summary>
        <returns>A 32-bit signed integer that indicates the lexical relationship between the two comparands.  
  
 <list type="table">  
<listheader>  
<term> Value  
  
 </term>  
<description> Condition  
  
 </description>  
</listheader>  
<item>  
<term> Less than zero  
  
 </term>  
<description> The substring in <paramref name="strA" /> is less than the substring in <paramref name="strB" />.  
  
 </description>  
</item>  
<item>  
<term> Zero  
  
 </term>  
<description> The substrings are equal, or <paramref name="length" /> is zero.  
  
 </description>  
</item>  
<item>  
<term> Greater than zero  
  
 </term>  
<description> The substring in <paramref name="strA" /> is greater than the substring in <paramref name="strB" />.  
  
 </description>  
</item>  
</list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The `indexA`, `indexB`, and `length` parameters must be nonnegative.  
  
 The number of characters compared is the lesser of the length of `strA` less `indexA`, the length of `strB` less `indexB`, and `length`.  
  
 This method performs a case-sensitive comparison using ordinal sort rules. For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=fullName>. To perform a case-insensitive comparison using ordinal sort rules, call the<xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29>method with the `comparisonType` argument set to<xref:System.StringComparison?displayProperty=fullName>.  
  
 Because <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> is a static method, `strA` and `strB` can be `null`. If both values are `null`, the method returns 0 (zero), which indicates that `strA` and `strB` are equal. If only one of the values is `null`, the method considers the non-null value to be greater.  
  
   
  
## Examples  
 This following example demonstrates that <xref:System.String.CompareOrdinal%2A> and <xref:System.String.Compare%2A> use different sort orders.  
  
 [!code-cs[StringCompareOrdinal#1](~/add/codesnippet/csharp/37bd9916-be02-4e9b-a383-_1.cs)]
 [!code-vb[StringCompareOrdinal#1](~/add/codesnippet/visualbasic/37bd9916-be02-4e9b-a383-_1.vb)]
 [!code-cpp[StringCompareOrdinal#1](~/add/codesnippet/cpp/37bd9916-be02-4e9b-a383-_1.cpp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="strA" /> is not <see langword="null" /> and <paramref name="indexA" /> is greater than <paramref name="strA" />.&lt;xref:System.String.Length%2A&gt;.  
  
 -or-  
  
 <paramref name="strB" /> is not <see langword="null" /> and<paramref name="indexB" /> is greater than <paramref name="strB" />.&lt;xref:System.String.Length%2A&gt;.  
  
 -or-  
  
 <paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">An object that evaluates to a <see cref="T:System.String" />.</param>
        <summary>Compares this instance with a specified <see cref="T:System.Object" /> and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified <see cref="T:System.Object" />.</summary>
        <returns>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <paramref name="value" /> parameter.  
  
 <list type="table">  
<listheader>  
<term> Value  
  
 </term>  
<description> Condition  
  
 </description>  
</listheader>  
<item>  
<term> Less than zero  
  
 </term>  
<description> This instance precedes <paramref name="value" />.  
  
 </description>  
</item>  
<item>  
<term> Zero  
  
 </term>  
<description> This instance has the same position in the sort order as <paramref name="value" />.  
  
 </description>  
</item>  
<item>  
<term> Greater than zero  
  
 </term>  
<description> This instance follows <paramref name="value" />.  
  
 -or-  
  
 <paramref name="value" /> is <see langword="null" />.  
  
 </description>  
</item>  
</list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` must be a <xref:System.String> object.  
  
> [!CAUTION]
>  The CompareTo method was designed primarily for use in sorting or alphabetizing operations. It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent. To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.  
  
 This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture. For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=fullName>.  
  
 For more information about the behavior of this method, see the Remarks section of the <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=fullName> method.  
  
   
  
## Examples  
 The following example uses the CompareTo method with an <xref:System.Object>. Because it attempts to compare a <xref:System.String> instance to a `TestClass` object, the method throws an <xref:System.ArgumentException>.  
  
 [!code-cpp[ExToString#1](~/add/codesnippet/cpp/m-system.string.comparet_0_2.cpp)]
 [!code-cs[ExToString#1](~/add/codesnippet/csharp/m-system.string.comparet_0_2.cs)]
 [!code-vb[ExToString#1](~/add/codesnippet/visualbasic/m-system.string.comparet_0_2.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> is not a <see cref="T:System.String" />.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(string strB) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strB">The string to compare with this instance.</param>
        <summary>Compares this instance with a specified <see cref="T:System.String" /> object and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified string.</summary>
        <returns>A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <paramref name="strB" /> parameter.  
  
 <list type="table">  
<listheader>  
<term> Value  
  
 </term>  
<description> Condition  
  
 </description>  
</listheader>  
<item>  
<term> Less than zero  
  
 </term>  
<description> This instance precedes <paramref name="strB" />.  
  
 </description>  
</item>  
<item>  
<term> Zero  
  
 </term>  
<description> This instance has the same position in the sort order as <paramref name="strB" />.  
  
 </description>  
</item>  
<item>  
<term> Greater than zero  
  
 </term>  
<description> This instance follows <paramref name="strB" />.  
  
 -or-  
  
 <paramref name="strB" /> is <see langword="null" />.  
  
 </description>  
</item>  
</list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture. For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=fullName>.  
  
> [!CAUTION]
>  The <xref:System.String.CompareTo%2A> method was designed primarily for use in sorting or alphabetizing operations. It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent. To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.  
  
 For more information about the behavior of this method, see the Remarks section of the <xref:System.String.Compare%28System.String%2CSystem.String%29> method.  
  
 This method implements the <xref:System.IComparable%601?displayProperty=fullName> interface and performs slightly better than the <xref:System.String.CompareTo%28System.Object%29?displayProperty=fullName> method, because it does not have to determine whether the `strB` argument is a mutable value type that must be boxed, and it does not have to cast its parameter from an <xref:System.Object>to a<xref:System.String>.  
  
   
  
## Examples  
 The following example uses the <xref:System.String.CompareTo%2A> method to compare the current string instance with another string.  
  
 [!code-cpp[stringcompareto#1](~/add/codesnippet/cpp/m-system.string.comparet_1_2.cpp)]
 [!code-cs[stringcompareto#1](~/add/codesnippet/csharp/m-system.string.comparet_1_2.cs)]
 [!code-vb[stringcompareto#1](~/add/codesnippet/visualbasic/m-system.string.comparet_1_2.vb)]  
  
 The following example demonstrates generic and non-generic versions of the CompareTo method for several value and reference types.  
  
 [!code-vb[T.CompareTo#1](~/add/codesnippet/visualbasic/m-system.string.comparet_1_3.vb)]
 [!code-cpp[T.CompareTo#1](~/add/codesnippet/cpp/m-system.string.comparet_1_3.cpp)]
 [!code-cs[T.CompareTo#1](~/add/codesnippet/csharp/m-system.string.comparet_1_3.cs)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="values">A collection object that implements &lt;xref:System.Collections.Generic.IEnumerable%601&gt; and whose generic type argument is <see cref="T:System.String" />.</param>
        <summary>Concatenates the members of a constructed &lt;xref:System.Collections.Generic.IEnumerable%601&gt; collection of type <see cref="T:System.String" />.</summary>
        <returns>The concatenated strings in <paramref name="values" />, or <see cref="T:System.String" /> if <paramref name="values" /> is an empty <see langword="IEnumerable(Of String)" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The method concatenates each object in `values`; it does not add any delimiters. To specify a delimiter between each member of `values`, call the <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method.  
  
 An <xref:System.String.Empty> string is used in place of any null element in `values`.  
  
 If `values` is an empty `IEnumerable(Of String)`, the method returns <xref:System.String.Empty?displayProperty=fullName>. If `values` is `null`, the method throws an <xref:System.ArgumentNullException> exception.  
  
 Concat is a convenience method that lets you concatenate each element in an `IEnumerable(Of String)` collection without first converting the elements to a string array. It is particularly useful with Language-Integrated Query (LINQ) query expressions. The following example passes a `List(Of String)` object that contains either the uppercase or lowercase letters of the alphabet to a lambda expression that selects letters that are equal to or greater than a particular letter (which, in the example, is "M"). The `IEnumerable(Of String)` collection that is returned by the <xref:System.Linq.Enumerable.Where%2A?displayProperty=fullName> method is passed to the Concat method to display the result as a single string.  
  
 [!code-cs[System.String.Concat#3](~/add/codesnippet/csharp/m-system.string.concat-s_7_1.cs)]
 [!code-vb[System.String.Concat#3](~/add/codesnippet/visualbasic/m-system.string.concat-s_7_1.vb)]  
  
   
  
## Examples  
 The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100. It assigns the result to a <xref:System.Collections.Generic.List%601> object of type <xref:System.String>, which it then passes to the Concat method.  
  
 [!code-cs[System.String.Concat#2](~/add/codesnippet/csharp/m-system.string.concat-s_7_2.cs)]
 [!code-vb[System.String.Concat#2](~/add/codesnippet/visualbasic/m-system.string.concat-s_7_2.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> is <see langword="null" />.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">The object to represent, or <see langword="null" />.</param>
        <summary>Creates the string  representation of a specified object.</summary>
        <returns>The string representation of the value of <paramref name="arg0" />, or <see cref="T:System.String" /> if <paramref name="arg0" /> is <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The Concat method represents `arg0` as a string by calling its parameterless `ToString` method.  
  
   
  
## Examples  
 The following example demonstrates the Concat method.  
  
 [!code-cs[string.concat5#1](~/add/codesnippet/csharp/m-system.string.concat-s_9_1.cs)]
 [!code-vb[string.concat5#1](~/add/codesnippet/visualbasic/m-system.string.concat-s_9_1.vb)]
 [!code-cpp[string.concat5#1](~/add/codesnippet/cpp/m-system.string.concat-s_9_1.cpp)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object[] args) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">An object array that contains the elements to concatenate.</param>
        <summary>Concatenates the string representations of the elements in a specified <see cref="T:System.Object" /> array.</summary>
        <returns>The concatenated string representations of the values of the elements in <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The method concatenates each object in `args` by calling the parameterless `ToString` method of that object; it does not add any delimiters.  
  
 <xref:System.String?displayProperty=fullName> is used in place of any null object in the array.  
  
   
  
## Examples  
 The following example demonstrates the use of the <xref:System.String.Concat%2A> method with an <xref:System.Object> array.  
  
 [!code-cs[stringconcat1#1](~/add/codesnippet/csharp/m-system.string.concat-s_6_1.cs)]
 [!code-vb[stringconcat1#1](~/add/codesnippet/visualbasic/m-system.string.concat-s_6_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="args" /> is <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Out of memory.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string[] values) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="values">An array of string instances.</param>
        <summary>Concatenates the elements of a specified <see cref="T:System.String" /> array.</summary>
        <returns>The concatenated elements of <paramref name="values" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The method concatenates each object in `values`; it does not add any delimiters.  
  
 An <xref:System.String> string is used in place of any null object in the array.  
  
   
  
## Examples  
 The following example demonstrates the use of the <xref:System.String.Concat%2A> method with a <xref:System.String> array.  
  
 [!code-vb[stringconcat3#1](~/add/codesnippet/visualbasic/m-system.string.concat-s_5_1.vb)]
 [!code-cs[stringconcat3#1](~/add/codesnippet/csharp/m-system.string.concat-s_5_1.cs)]
 [!code-cpp[stringconcat3#1](~/add/codesnippet/cpp/m-system.string.concat-s_5_1.cpp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> is <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Out of memory.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">The first object to concatenate.</param>
        <param name="arg1">The second object to concatenate.</param>
        <summary>Concatenates the string representations of two specified objects.</summary>
        <returns>The concatenated string representations of the values of <paramref name="arg0" /> and <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The method concatenates `arg0` and `arg1`by calling the parameterless `ToString` method of `arg0` and `arg1`; it does not add any delimiters.  
  
 <xref:System.String?displayProperty=fullName> is used in place of any null argument.  
  
 If either of the arguments is an array reference, the method concatenates a string representing that array, instead of its members (for example, "System.String[]").  
  
   
  
## Examples  
 The following example demonstrates the <xref:System.String.Concat%2A> method.  
  
 [!code-cs[string.concat5#1](~/add/codesnippet/csharp/m-system.string.concat-s_2_1.cs)]
 [!code-vb[string.concat5#1](~/add/codesnippet/visualbasic/m-system.string.concat-s_2_1.vb)]
 [!code-cpp[string.concat5#1](~/add/codesnippet/cpp/m-system.string.concat-s_2_1.cpp)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">The first string to concatenate.</param>
        <param name="str1">The second string to concatenate.</param>
        <summary>Concatenates two specified instances of <see cref="T:System.String" />.</summary>
        <returns>The concatenation of <paramref name="str0" /> and <paramref name="str1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The method concatenates `str0` and `str1`; it does not add any delimiters.  
  
> [!NOTE]
>  You can also use your language's string concatenation operator, such as `+` in C#, or `&` and `+` in Visual Basic)  
>   
>  , to concatenate strings.  
  
 An <xref:System.String> string is used in place of any null argument.  
  
   
  
## Examples  
 The following example concatenates a person's first, middle, and last name.  
  
 [!code-cpp[stringconcat4#1](~/add/codesnippet/cpp/m-system.string.concat-s_8_1.cpp)]
 [!code-cs[stringconcat4#1](~/add/codesnippet/csharp/m-system.string.concat-s_8_1.cs)]
 [!code-vb[stringconcat4#1](~/add/codesnippet/visualbasic/m-system.string.concat-s_8_1.vb)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">The first object to concatenate.</param>
        <param name="arg1">The second object to concatenate.</param>
        <param name="arg2">The third object to concatenate.</param>
        <summary>Concatenates the string representations of three specified objects.</summary>
        <returns>The concatenated string representations of the values of <paramref name="arg0" />, <paramref name="arg1" />, and <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The method concatenates `arg0`, `arg1`, and `arg2` by calling the parameterless `ToString` method of each object; it does not add any delimiters.  
  
 <xref:System.String?displayProperty=fullName> is used in place of any null argument.  
  
   
  
## Examples  
 The following example demonstrates the <xref:System.String.Concat%2A> method.  
  
 [!code-cs[string.concat5#1](~/add/codesnippet/csharp/m-system.string.concat-s_1_1.cs)]
 [!code-vb[string.concat5#1](~/add/codesnippet/visualbasic/m-system.string.concat-s_1_1.vb)]
 [!code-cpp[string.concat5#1](~/add/codesnippet/cpp/m-system.string.concat-s_1_1.cpp)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">The first string to concatenate.</param>
        <param name="str1">The second string to concatenate.</param>
        <param name="str2">The third string to concatenate.</param>
        <summary>Concatenates three specified instances of <see cref="T:System.String" />.</summary>
        <returns>The concatenation of <paramref name="str0" />, <paramref name="str1" />, and <paramref name="str2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The method concatenates `str0`, `str1`, and `str2`; it does not add any delimiters.  
  
> [!NOTE]
>  You can also use your language's string concatenation operator, such as `+` in C#, or `&` and `+` in Visual Basic)  
>   
>  , to concatenate strings.  
  
 An <xref:System.String> string is used in place of any null argument.  
  
   
  
## Examples  
 The following example uses the Concat method to concatenate three strings and displays the result.  
  
 [!code-cs[System.String.Concat#6](~/add/codesnippet/csharp/m-system.string.concat-s_3_1.cs)]
 [!code-cpp[System.String.Concat#6](~/add/codesnippet/cpp/m-system.string.concat-s_3_1.cpp)]
 [!code-vb[System.String.Concat#6](~/add/codesnippet/visualbasic/m-system.string.concat-s_3_1.vb)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
        <Parameter Name="arg3" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">The first object to concatenate.</param>
        <param name="arg1">The second object to concatenate.</param>
        <param name="arg2">The third object to concatenate.</param>
        <param name="arg3">The fourth object to concatenate.</param>
        <summary>Concatenates the string representations of four specified objects and any objects specified in an optional variable length parameter list.</summary>
        <returns>The concatenated string representation of each value in the parameter list.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  This API is not CLS-compliant. The CLS-compliant alternative is [String.Concat(Object\[\])](assetId:///M:System.String.Concat(System.Object[])?qualifyHint=True&autoUpgrade=False). The C# and Visual Basic compilers automatically resolve a call to this method as a call to [String.Concat(Object\[\])](assetId:///M:System.String.Concat(System.Object[])?qualifyHint=True&autoUpgrade=False).  
  
 The method concatenates each object in the parameter list by calling its parameterless `ToString` method; it does not add any delimiters.  
  
 <xref:System.String.Empty?displayProperty=fullName> is used in place of any null argument.  
  
> [!NOTE]
>  The last parameter of the  Concat method is an optional comma-delimited list of one or more additional objects to concatenate.  
  
   
  
## Examples  
 The following example illustrates the use of the Concat method to concatenate a list of variable parameters. In this case, the method is called with nine parameters.  
  
 [!code-cs[System.String.Concat#1](~/add/codesnippet/csharp/m-system.string.concat-s_0_1.cs)]
 [!code-vb[System.String.Concat#1](~/add/codesnippet/visualbasic/m-system.string.concat-s_0_1.vb)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2, string str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2, string str3) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
        <Parameter Name="str3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">The first string to concatenate.</param>
        <param name="str1">The second string to concatenate.</param>
        <param name="str2">The third string to concatenate.</param>
        <param name="str3">The fourth string to concatenate.</param>
        <summary>Concatenates four specified instances of <see cref="T:System.String" />.</summary>
        <returns>The concatenation of <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" />, and <paramref name="str3" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The method concatenates `str0`, `str1`, `str2`, and `str3`; it does not add any delimiters.  
  
> [!NOTE]
>  You can also use your language's string concatenation operator, such as `+` in C#, or `&` and `+` in Visual Basic)  
>   
>  , to concatenate strings.  
  
 An <xref:System.String> string is used in place of any null object in the array.  
  
   
  
## Examples  
 The following example defines an array of four-letter words and stores their individual letters to a string array in order to scramble them. It then calls the Concat method to reassemble the scrambled words.  
  
 [!code-cs[System.String.Concat#1](~/add/codesnippet/csharp/m-system.string.concat-s_4_1.cs)]
 [!code-vb[System.String.Concat#1](~/add/codesnippet/visualbasic/m-system.string.concat-s_4_1.vb)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">The string to seek.</param>
        <summary>Returns a value indicating whether a specified substring occurs within this string.</summary>
        <returns>
          <see langword="true" /> if the <paramref name="value" /> parameter occurs within this string, or if <paramref name="value" /> is the empty string (""); otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method performs an ordinal (case-sensitive and culture-insensitive) comparison. The search begins at the first character position of this string and continues through the last character position.  
  
 To determine whether a string contains a specified substring by using something other than ordinal comparison (such as culture-sensitive comparison, or ordinal case-insensitive comparison), you can create a custom method. The following example illustrates one such approach. It defines a <xref:System.String> extension method  that includes a <xref:System.StringComparison> parameter and indicates whether a string contains a substring when using the specified form of string comparison.  
  
 [!code-cs[System.String.Contains#1](~/add/codesnippet/csharp/m-system.string.contains_1.cs)]
 [!code-vb[System.String.Contains#1](~/add/codesnippet/visualbasic/m-system.string.contains_1.vb)]  
  
 The following example then calls the `Contains` extension method to determine whether a substring is found in a string when using ordinal comparison and case-insensitive ordinal comparison.  
  
 [!code-cs[System.String.Contains#2](~/add/codesnippet/csharp/m-system.string.contains_2.cs)]
 [!code-vb[System.String.Contains#2](~/add/codesnippet/visualbasic/m-system.string.contains_2.vb)]  
  
 If you are interested in the position of the substring `value` in the current instance, you can call the <xref:System.String.IndexOf%2A> method to get the starting position of its first occurrence, or you can call the <xref:System.String.LastIndexOf%2A> method to get the starting position of its last occurrence. The example includes a call to the <xref:System.String.IndexOf%28System.String%29> method if a substring is found in a string instance.  
  
   
  
## Examples  
 The following example determines whether the string "fox" is a substring of a familiar quotation. If "fox" is found in the string, it also displays its starting position.  
  
 [!code-vb[String.Contains#1](~/add/codesnippet/visualbasic/m-system.string.contains_3.vb)]
 [!code-cs[String.Contains#1](~/add/codesnippet/csharp/m-system.string.contains_3.cs)]
 [!code-cpp[String.Contains#1](~/add/codesnippet/cpp/m-system.string.contains_3.cpp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static string Copy (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Copy(string str) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">The string to copy.</param>
        <summary>Creates a new instance of <see cref="T:System.String" /> with the same value as a specified <see cref="T:System.String" />.</summary>
        <returns>A new string with the same value as <paramref name="str" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 TheCopy method returns a <xref:System.String> object that has the same value as the original string but represents a different object reference. It differs from an assignment operation, which assigns an existing string reference to an additional object variable. The example illustrates the difference.  
  
   
  
## Examples  
 The following example creates two string objects with different values. When it calls the Copy method to assign the first value to the second string, the output indicates that the strings represent different object references although their values are now equal. On the other hand, when the first string is assigned to the second string, the two strings have identical values because they represent the same object reference.  
  
 [!code-vb[System.String.Copy#1](~/add/codesnippet/visualbasic/m-system.string.copy-sys_1.vb)]
 [!code-cs[System.String.Copy#1](~/add/codesnippet/csharp/m-system.string.copy-sys_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> is <see langword="null" />.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">The index of the first character in this instance to copy.</param>
        <param name="destination">An array of Unicode characters to which characters in this instance are copied.</param>
        <param name="destinationIndex">The index in `destination` at which the copy operation begins.</param>
        <param name="count">The number of characters in this instance to copy to `destination`.</param>
        <summary>Copies a specified number of characters from a specified position in this instance to a specified position in an array of Unicode characters.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method copies `count` characters from the `sourceIndex` position of this instance to the `destinationIndex` position of `destination` character array. This method does not resize the `destination` character array; it must have a sufficient number of elements to accommodate the copied characters or the method throws an <xref:System.ArgumentOutOfRangeException>.  
  
 `sourceIndex` and `destinationIndex` are zero-based.  
  
   
  
## Examples  
 The following example demonstrates the CopyTo method.  
  
 [!code-cpp[stringcopyto#1](~/add/codesnippet/cpp/m-system.string.copyto-s_1.cpp)]
 [!code-cs[stringcopyto#1](~/add/codesnippet/csharp/m-system.string.copyto-s_1.cs)]
 [!code-vb[stringcopyto#1](~/add/codesnippet/visualbasic/m-system.string.copyto-s_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" />, <paramref name="destinationIndex" />, or <paramref name="count" /> is negative  
  
 -or-  
  
 <paramref name="sourceIndex" /> does not identify a position in the current instance.  
  
 -or-  
  
 <paramref name="destinationIndex" /> does not identify a valid index in the <paramref name="destination" /> array.  
  
 -or-  
  
 <paramref name="count" /> is greater than the length of the substring from <paramref name="startIndex" /> to the end of this instance  
  
 -or-  
  
 <paramref name="count" /> is greater than the length of the subarray from <paramref name="destinationIndex" /> to the end of the <paramref name="destination" /> array.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly string Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string Empty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents the empty string. This field is read-only.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The value of this field is the zero-length string, "".  
  
 In application code, this field is most commonly used in assignments to initialize a string variable to an empty string. To test whether the value of a string is either `null` or Empty, use the <xref:System.String.IsNullOrEmpty%2A> method.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">The string to compare to the substring at the end of this instance.</param>
        <summary>Determines whether the end of this string instance matches the specified string.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> matches the end of this instance; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method compares `value` to the substring at the end of this instance that is the same length as `value`, and returns an indication whether they are equal. To be equal, `value` must be a reference to this same instance or match the end of this instance.  
  
 This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.  
  
   
  
## Examples  
 The following example indicates whether each string in an array ends with a period (".").  
  
 [!code-vb[System.String.EndsWith#1](~/add/codesnippet/visualbasic/m-system.string.endswith_0_1.vb)]
 [!code-cs[System.String.EndsWith#1](~/add/codesnippet/csharp/m-system.string.endswith_0_1.cs)]  
  
 The following example defines a `StripEndTags` method that uses the EndsWith method to remove HTML end tags from the end of a line. Note that the  `StripEndTags` method is called recursively to ensure that multiple HTML end tags at the end of the line are removed.  
  
 [!code-vb[stringendswith#1](~/add/codesnippet/visualbasic/m-system.string.endswith_0_2.vb)]
 [!code-cpp[stringendswith#1](~/add/codesnippet/cpp/m-system.string.endswith_0_2.cpp)]
 [!code-cs[stringendswith#1](~/add/codesnippet/csharp/m-system.string.endswith_0_2.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">The string to compare to the substring at the end of this instance.</param>
        <param name="comparisonType">One of the enumeration values that determines how this string and `value` are compared.</param>
        <summary>Determines whether the end of this string instance matches the specified string when compared using the specified comparison option.</summary>
        <returns>
          <see langword="true" /> if the <paramref name="value" /> parameter matches the end of this string; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The EndsWith method compares the `value` parameter to the substring at the end of this string and returns a value that indicates whether they are equal. To be equal, `value` must be a reference to this same string, must be the empty string (""), or must match the end of this string. The type of comparison performed by the EndsWith method depends on the value of the `comparisonType`parameter.  
  
   
  
## Examples  
 The following example determines whether a string ends with a particular substring. The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.  
  
 [!code-cpp[System.String.EndsWithCmp#1](~/add/codesnippet/cpp/m-system.string.endswith_1_1.cpp)]
 [!code-vb[System.String.EndsWithCmp#1](~/add/codesnippet/visualbasic/m-system.string.endswith_1_1.vb)]
 [!code-cs[System.String.EndsWithCmp#1](~/add/codesnippet/csharp/m-system.string.endswith_1_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">The string to compare to the substring at the end of this instance.</param>
        <param name="ignoreCase">
          <see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</param>
        <param name="culture">Cultural information that determines how this instance and `value` are compared. If `culture` is <see langword="null" />, the current culture is used.</param>
        <summary>Determines whether the end of this string instance matches the specified string when compared using the specified culture.</summary>
        <returns>
          <see langword="true" /> if the <paramref name="value" /> parameter matches the end of this string; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method compares the `value` parameter to the substring at the end of this string that is the same length as `value`, and returns a value that indicates whether they are equal. To be equal, `value` must be a reference to this same instance or match the end of this string.  
  
 This method performs a word (culture-sensitive) comparison using the specified casing and culture.  
  
   
  
## Examples  
 The following example determines whether a string occurs at the end of another string. The EndsWith method is called several times using case sensitivity, case insensitivity, and different cultures that influence the results of the search.  
  
 [!code-cs[system.string.EndsWithCI#1](~/add/codesnippet/csharp/5ef3fc0c-83c9-48eb-8138-_1.cs)]
 [!code-vb[system.string.EndsWithCI#1](~/add/codesnippet/visualbasic/5ef3fc0c-83c9-48eb-8138-_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">The string to compare to this instance.</param>
        <summary>Determines whether this instance and a specified object, which must also be a <see cref="T:System.String" /> object, have the same value.</summary>
        <returns>
          <see langword="true" /> if <paramref name="obj" /> is a <see cref="T:System.String" /> and its value is the same as this instance; otherwise, <see langword="false" />.  If <paramref name="obj" /> is <see langword="null" />, the method returns <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method performs an ordinal (case-sensitive and culture-insensitive) comparison.  
  
   
  
## Examples  
 The following example demonstrates the Equals method.  
  
 [!code-cpp[string.equals#1](~/add/codesnippet/cpp/m-system.string.equals-s_1_1.cpp)]
 [!code-cs[string.equals#1](~/add/codesnippet/csharp/m-system.string.equals-s_1_1.cs)]
 [!code-vb[string.equals#1](~/add/codesnippet/visualbasic/m-system.string.equals-s_1_1.vb)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(string value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">The string to compare to this instance.</param>
        <summary>Determines whether this instance and another specified <see cref="T:System.String" /> object have the same value.</summary>
        <returns>
          <see langword="true" /> if the value of the <paramref name="value" /> parameter is the same as the value of this instance; otherwise, <see langword="false" />. If <paramref name="value" /> is <see langword="null" />, the method returns <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method performs an ordinal (case-sensitive and culture-insensitive) comparison.  
  
   
  
## Examples  
 The following example demonstrates the <xref:System.String.Equals%2A> method.It compares the title-cased word "File" with an equivalent word, its lowercase equivalent, its uppercase equivalent, and a word that contains LATIN SMALL LETTER DOTLESS I (U+0131) instead of LATIN SMALL LETTER I (U+0069). Because the Equals method performs an ordinal comparison, only the comparison with an identical word returns `true`.  
  
 [!code-vb[System.String.Equals#2](~/add/codesnippet/visualbasic/m-system.string.equals-s_3_1.vb)]
 [!code-cs[System.String.Equals#2](~/add/codesnippet/csharp/m-system.string.equals-s_3_1.cs)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">The first string to compare, or <see langword="null" />.</param>
        <param name="b">The second string to compare, or <see langword="null" />.</param>
        <summary>Determines whether two specified <see cref="T:System.String" /> objects have the same value.</summary>
        <returns>
          <see langword="true" /> if the value of <paramref name="a" /> is the same as the value of <paramref name="b" />; otherwise, <see langword="false" />. If both <paramref name="a" /> and <paramref name="b" /> are <see langword="null" />, the method returns <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method performs an ordinal (case-sensitive and culture-insensitive) comparison.  
  
   
  
## Examples  
 The following example demonstrates the <xref:System.String.Equals%2A> method.  
  
 [!code-cpp[string.equals#1](~/add/codesnippet/cpp/m-system.string.equals-s_4_1.cpp)]
 [!code-cs[string.equals#1](~/add/codesnippet/csharp/m-system.string.equals-s_4_1.cs)]
 [!code-vb[string.equals#1](~/add/codesnippet/visualbasic/m-system.string.equals-s_4_1.vb)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">The string to compare to this instance.</param>
        <param name="comparisonType">One of the enumeration values that specifies how the strings will be compared.</param>
        <summary>Determines whether this string and a specified <see cref="T:System.String" /> object have the same value. A parameter specifies the culture, case, and sort rules used in the comparison.</summary>
        <returns>
          <see langword="true" /> if the value of the <paramref name="value" /> parameter is the same as this string; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the two strings being compared, or use word or ordinal sort rules.  
  
   
  
## Examples  
 The following example creates a string array that consists of an uppercase "I", a lowercase "i", and a dotless "Ä±". It then calls the Equals method to compare them by using each possible <xref:System.StringComparison> enumeration value.  
  
 [!code-cs[System.String.Equals#1](~/add/codesnippet/csharp/m-system.string.equals-s_2_1.cs)]
 [!code-vb[System.String.Equals#1](~/add/codesnippet/visualbasic/m-system.string.equals-s_2_1.vb)]  
  
 The following example compares four sets of words by using each member of the <xref:System.StringComparison> enumeration.  The comparisons use the conventions of the English (United States) and Sami (Upper Sweden) cultures. Note that the strings "encyclopÃ¦dia" and "encyclopedia" are considered equivalent in the en-US culture but not in the Sami (Northern Sweden) culture.  
  
 [!code-cs[System.String.Equals#4](~/add/codesnippet/csharp/m-system.string.equals-s_2_2.cs)]
 [!code-vb[System.String.Equals#4](~/add/codesnippet/visualbasic/m-system.string.equals-s_2_2.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="a">The first string to compare, or <see langword="null" />.</param>
        <param name="b">The second string to compare, or <see langword="null" />.</param>
        <param name="comparisonType">One of the enumeration values that specifies the rules for the comparison.</param>
        <summary>Determines whether two specified <see cref="T:System.String" /> objects have the same value. A parameter specifies the culture, case, and sort rules used in the comparison.</summary>
        <returns>
          <see langword="true" /> if the value of the <paramref name="a" /> parameter is equal to the value of the <paramref name="b" /> parameter; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the two strings being compared, or use word or ordinal sort rules.  
  
   
  
## Examples  
 The following example compares four sets of words by using each member of the <xref:System.StringComparison> enumeration.  The comparisons use the conventions of the English (United States) and Sami (Upper Sweden) cultures. Note that the strings "encyclopÃ¦dia" and "encyclopedia" are considered equivalent in the en-US culture but not in the Sami (Northern Sweden) culture.  
  
 [!code-vb[System.String.Equals#3](~/add/codesnippet/visualbasic/m-system.string.equals-s_0_1.vb)]
 [!code-cs[System.String.Equals#3](~/add/codesnippet/csharp/m-system.string.equals-s_0_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">A [composite format string](../Topic/Composite%20Formatting.md).</param>
        <param name="arg0">The object to format.</param>
        <summary>Replaces one or more format items in a specified string with the string representation of a specified object.</summary>
        <returns>A copy of <paramref name="format" /> in which any format items are replaced by the string representation of <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  For examples and comprehensive usage information about this and other overloads of the `Format` method, see the <xref:System.String.Format%2A> overload summary.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">The format item in <paramref name="format" /> is invalid.  
  
 -or-  
  
 The index of a format item is not zero.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object[] args) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">A [composite format string](../Topic/Composite%20Formatting.md).</param>
        <param name="args">An object array that contains zero or more objects to format.</param>
        <summary>Replaces the format item in a specified string with the string representation of a corresponding object in a specified array.</summary>
        <returns>A copy of <paramref name="format" /> in which the format items have been replaced by the string representation of the corresponding objects in <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  For examples and comprehensive usage information about this and other overloads of the `Format` method, see the <xref:System.String.Format%2A> overload summary.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> or <paramref name="args" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> is invalid.  
  
 -or-  
  
 The index of a format item is less than zero, or greater than or equal to the length of the <paramref name="args" /> array.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">An object that supplies culture-specific formatting information.</param>
        <param name="format">A [composite format string](../Topic/Composite%20Formatting.md).</param>
        <param name="args">An object array that contains zero or more objects to format.</param>
        <summary>Replaces the format items in a specified string with the string representations of corresponding objects in a specified array. A parameter supplies culture-specific formatting information.</summary>
        <returns>A copy of <paramref name="format" /> in which the format items have been replaced by the string representation of the corresponding objects in <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  For examples and comprehensive usage information about this and other overloads of the `Format` method, see the <xref:System.String.Format%2A> overload summary.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> or <paramref name="args" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> is invalid.  
  
 -or-  
  
 The index of a format item is less than zero, or greater than or equal to the length of the <paramref name="args" /> array.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">A [composite format string](../Topic/Composite%20Formatting.md).</param>
        <param name="arg0">The first object to format.</param>
        <param name="arg1">The second object to format.</param>
        <summary>Replaces the format items in a specified string with the string representation of two specified objects.</summary>
        <returns>A copy of <paramref name="format" /> in which format items are replaced by the string representations of <paramref name="arg0" /> and <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  For examples and comprehensive usage information about this and other overloads of the `Format` method, see the <xref:System.String.Format%2A> overload summary.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> is invalid.  
  
 -or-  
  
 The index of a format item is not zero or one.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">A [composite format string](../Topic/Composite%20Formatting.md).</param>
        <param name="arg0">The first object to format.</param>
        <param name="arg1">The second object to format.</param>
        <param name="arg2">The third object to format.</param>
        <summary>Replaces the format items in a specified string with the string representation of three specified objects.</summary>
        <returns>A copy of <paramref name="format" /> in which the format items have been replaced by the string representations of <paramref name="arg0" />, <paramref name="arg1" />, and <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  For examples and comprehensive usage information about this and other overloads of the `Format` method, see the <xref:System.String.Format%2A> overload summary.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> is invalid.  
  
 -or-  
  
 The index of a format item is less than zero, or greater than two.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public CharEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.CharEnumerator GetEnumerator() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CharEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retrieves an object that can iterate through the individual characters in this string.</summary>
        <returns>An enumerator object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  Rather than calling the GetEnumerator method to retrieve a <xref:System.CharEnumerator> object that you then use to enumerate a string, you should instead use your language's iteration construct ( in C#,  in C++/CLR, and  in Visual Basic).                  [foreach](../Topic/foreach,%20in%20\(C%23%20Reference\).md) in C#,                  [for each](../Topic/for%20each,%20in.md) in C++/CLR, and                  [For Each](../Topic/For%20Each...Next%20Statement%20\(Visual%20Basic\).md) in Visual Basic).  
  
 This method enables you to iterate the individual characters in a string. For example, the Visual Basic `For Each` and C# `foreach` statements invoke this method to return a <xref:System.CharEnumerator> object that can provide read-only access to the characters in this string instance.  
  
   
  
## Examples  
 The following example iterates the characters in several strings and displays information about their individual characters. It uses the language iteration construct rather than a call to the GetEnumerator method.  
  
 [!code-cs[system.string.getenumerator#1](~/add/codesnippet/csharp/m-system.string.getenume_1.cs)]
 [!code-cpp[system.string.getenumerator#1](~/add/codesnippet/cpp/m-system.string.getenume_1.cpp)]
 [!code-vb[system.string.getenumerator#1](~/add/codesnippet/visualbasic/m-system.string.getenume_1.vb)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the hash code for this string.</summary>
        <returns>A 32-bit signed integer hash code.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The behavior of GetHashCode is dependent on its implementation, which might change from one version of the common language runtime to another. A reason why this might happen is to improve the performance of GetHashCode.  
  
> [!IMPORTANT]
>  If two string objects are equal, the GetHashCode method returns identical values. However, there is not a unique hash code value for each unique string value. Different strings can return the same hash code.  
>   
>  The hash code itself is not guaranteed to be stable. Hash codes for identical strings can differ across versions of the .NET Framework and across platforms (such as 32-bit and 64-bit) for a single version of the .NET Framework. In some cases, they can even differ by application domain.  
>   
>  As a result, hash codes should never be used outside of the application domain in which they were created, they should never be used as key fields in a collection, and they should never be persisted.  
>   
>  Finally, do not use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash. For cryptographic hashes, use a class derived from the <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=fullName> or <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=fullName> class.  
>   
>  For more information about hash codes, see <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.  
  
 In desktop apps, you can use the             [\<UseRandomizedStringHashAlgorithm> element](../Topic/%3CUseRandomizedStringHashAlgorithm%3E%20Element.md) to generate unique hash codes on a per application domain basis. This can reduce the number of collisions and improve the overall performance of insertions and lookups that use hash tables. The following example shows how to use the                [\<UseRandomizedStringHashAlgorithm> element](../Topic/%3CUseRandomizedStringHashAlgorithm%3E%20Element.md). It defines a  to generate unique hash codes on a per application domain basis. This can reduce the number of collisions and improve the overall performance of insertions and lookups that use hash tables. The following example shows how to use the . It defines a `DisplayString` class that includes a private string constant, `s`, whose value is "This is a string." It also includes a `ShowStringHashCode` method that displays the string value and its hash code along with the name of the application domain in which the method is executing.  
  
 [!code-cs[System.String.GetHashCode#2](~/add/codesnippet/csharp/m-system.string.gethashc_1.cs)]
 [!code-vb[System.String.GetHashCode#2](~/add/codesnippet/visualbasic/m-system.string.gethashc_1.vb)]  
  
 When you run the example without supplying a configuration file, it displays output similar to the following. Note that the hash codes for the string are identical in the two application domains.  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 941BCEAC  
String 'This is a string.' in domain 'NewDomain': 941BCEAC  
  
```  
  
 However, if you add the following configuration file to the example's directory and then run the example, the hash codes for the same string will differ by application domain.  
  
```  
  
<?xml version ="1.0"?>  
<configuration>  
   <runtime>  
      <UseRandomizedStringHashAlgorithm enabled="1" />  
   </runtime>  
</configuration>  
  
```  
  
 When the configuration file is present, the example displays the following output:  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 5435776D  
String 'This is a string.' in domain 'NewDomain': 75CC8236  
  
```  
  
> [!IMPORTANT]
>  Hash codes are used to insert and retrieve keyed objects from hash tables efficiently. However, hash codes do not uniquely identify strings. Identical strings have  equal hash codes, but the common language runtime can also assign the same hash code to different strings. In addition, hash codes can vary by version of the .NET Framework, by platform within a single version, and by application domain. Because of this, you should not serialize or persist hash code values, nor should you use them as keys in a hash table or dictionary.  
  
 For additional information about the use of hash codes and the `GetHashCode` method, see <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.  
  
   
  
## Examples  
 The following example demonstrates the GetHashCode method using various input strings.  
  
 [!code-cpp[system.string.gethashcode#1](~/add/codesnippet/cpp/m-system.string.gethashc_2.cpp)]
 [!code-vb[system.string.gethashcode#1](~/add/codesnippet/visualbasic/m-system.string.gethashc_2.vb)]
 [!code-cs[system.string.gethashcode#1](~/add/codesnippet/csharp/m-system.string.gethashc_2.cs)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the <see cref="T:System.TypeCode" /> for class <see cref="T:System.String" />.</summary>
        <returns>The enumerated constant, <see cref="T:System.TypeCode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example displays the <xref:System.TypeCode> enumerated constant for the <xref:System.String> type.  
  
 [!code-cs[string.gettypecode#1](~/add/codesnippet/csharp/m-system.string.gettypec_1.cs)]
 [!code-vb[string.gettypecode#1](~/add/codesnippet/visualbasic/m-system.string.gettypec_1.vb)]
 [!code-cpp[string.gettypecode#1](~/add/codesnippet/cpp/m-system.string.gettypec_1.cpp)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">A Unicode character to seek.</param>
        <summary>Reports the zero-based index of the first occurrence of the specified Unicode character in this string.</summary>
        <returns>The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Index numbering starts from zero.  
  
 This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same. To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=fullName> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Ã" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.  
  
   
  
## Examples  
 The following example demonstrates how you can search a <xref:System.String> for a character using the IndexOf method.  
  
 [!code-cpp[System.String.IndexOf#5](~/add/codesnippet/cpp/m-system.string.indexof-_2_1.cpp)]
 [!code-vb[System.String.IndexOf#5](~/add/codesnippet/visualbasic/m-system.string.indexof-_2_1.vb)]
 [!code-cs[System.String.IndexOf#5](~/add/codesnippet/csharp/m-system.string.indexof-_2_1.cs)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">The string to seek.</param>
        <summary>Reports the zero-based index of the first occurrence of the specified string in this instance.</summary>
        <returns>The zero-based index position of <paramref name="value" /> if that string is found, or -1 if it is not. If <paramref name="value" /> is <see cref="T:System.String" />, the return value is 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Index numbering starts from zero.  
  
 This method performs a word (case-sensitive and culture-sensitive) search using the current culture. The search begins at the first character position of this instance and continues until the last character position.  
  
 Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison. In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed. If `value` consists only of one or more ignorable characters, theIndexOf method always returns 0 (zero) to indicate that the match is found at the beginning of the current instance. In the following example, the IndexOf method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings. Only one of the strings contains a soft hyphen. If the example is run on the [!INCLUDE[netfx40_short](~/add/includes/netfx40-short-md.md)] or later, in each case, because the soft hyphen is an ignorable character, the result is the same as if the soft hyphen had not been included in `value`. When searching for a soft hyphen only, the method returns 0 (zero) to indicate that it has found a match at the beginning of the string.  
  
 [!code-vb[System.String.IndexOf#21](~/add/codesnippet/visualbasic/m-system.string.indexof-_3_1.vb)]
 [!code-cs[System.String.IndexOf#21](~/add/codesnippet/csharp/m-system.string.indexof-_3_1.cs)]  
  
   
  
## Examples  
 The following example searches for the "n" in "animal". Because string indexes begin at zero rather than one, the IndexOf method indicates that the "n" is at position 1.  
  
 [!code-cpp[System.String.IndexOf#12](~/add/codesnippet/cpp/m-system.string.indexof-_3_2.cpp)]
 [!code-vb[System.String.IndexOf#12](~/add/codesnippet/visualbasic/m-system.string.indexof-_3_2.vb)]
 [!code-cs[System.String.IndexOf#12](~/add/codesnippet/csharp/m-system.string.indexof-_3_2.cs)]  
  
 The following example uses the <xref:System.String.IndexOf%2A> method to determine the starting position of an animal name in a sentence. It then uses this position to insert an adjective that describes the animal into the sentence.  
  
 [!code-cpp[stringinsert#1](~/add/codesnippet/cpp/m-system.string.indexof-_3_3.cpp)]
 [!code-vb[stringinsert#1](~/add/codesnippet/visualbasic/m-system.string.indexof-_3_3.vb)]
 [!code-cs[stringinsert#1](~/add/codesnippet/csharp/m-system.string.indexof-_3_3.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">A Unicode character to seek.</param>
        <param name="startIndex">The search starting position.</param>
        <summary>Reports the zero-based index of the first occurrence of the specified Unicode character in this string. The search starts at a specified character position.</summary>
        <returns>The zero-based index position of <paramref name="value" /> from the start of the string if that character is found, or -1 if it is not.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Index numbering starts from 0. The `startIndex` parameter can range from 0 to the length of the string instance. If `startIndex` equals the length of the string instance, the method returns -1.  
  
 The search ranges from `startIndex` to the end of the string.  
  
 This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same. To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=fullName> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Ã" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.  
  
   
  
## Examples  
 The following example demonstrates the <xref:System.String.IndexOf%2A> method.  
  
 [!code-cpp[string.indexof1#1](~/add/codesnippet/cpp/m-system.string.indexof-_1_1.cpp)]
 [!code-cs[string.indexof1#1](~/add/codesnippet/csharp/m-system.string.indexof-_1_1.cs)]
 [!code-vb[string.indexof1#1](~/add/codesnippet/visualbasic/m-system.string.indexof-_1_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is less than 0 (zero) or greater than the length of the string.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">The string to seek.</param>
        <param name="startIndex">The search starting position.</param>
        <summary>Reports the zero-based index of the first occurrence of the specified string in this instance. The search starts at a specified character position.</summary>
        <returns>The zero-based index position of <paramref name="value" /> from the start of the current instance if that string is found, or -1 if it is not. If <paramref name="value" /> is <see cref="T:System.String" />, the return value is <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Index numbering starts from 0. The `startIndex` parameter can range from 0 to the length of the string instance. If `startIndex` equals the length of the string instance, the method returns -1.  
  
 This method performs a word (case-sensitive and culture-sensitive) search using the current culture. The search begins at the `startIndex` character position of this instance and continues until the last character position.  
  
 Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison. In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed. If `value` consists only of one or more ignorable characters, the IndexOf method always returns `startIndex`, which is the character position at which the search begins. In the following example, the IndexOf method is used to find the position of a soft hyphen (U+00AD) followed by an "m" in two strings. Only one of the strings contains the required substring. If the example is run on the [!INCLUDE[netfx40_short](~/add/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string. Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".  
  
 [!code-vb[System.String.IndexOf#22](~/add/codesnippet/visualbasic/m-system.string.indexof-_5_1.vb)]
 [!code-cs[System.String.IndexOf#22](~/add/codesnippet/csharp/m-system.string.indexof-_5_1.cs)]  
  
   
  
## Examples  
 The following example searches for all occurrences of a specified string within a target string.  
  
 [!code-cs[stringindexof4#1](~/add/codesnippet/csharp/m-system.string.indexof-_5_2.cs)]
 [!code-cpp[stringindexof4#1](~/add/codesnippet/cpp/m-system.string.indexof-_5_2.cpp)]
 [!code-vb[stringindexof4#1](~/add/codesnippet/visualbasic/m-system.string.indexof-_5_2.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is less than 0 (zero) or greater than the length of this string.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">The string to seek.</param>
        <param name="comparisonType">One of the enumeration values that specifies the rules for the search.</param>
        <summary>Reports the zero-based index of the first occurrence of the specified string in the current <see cref="T:System.String" /> object. A parameter specifies the type of search to use for the specified string.</summary>
        <returns>The index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not. If <paramref name="value" /> is <see cref="T:System.String" />, the return value is 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Index numbering starts from zero.  
  
 The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.  
  
   
  
## Examples  
 The following exampledemonstrates three overloads of the <xref:System.String.IndexOf%2A> method that find the first occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.  
  
 [!code-vb[system.string.IndexOfCmp#1](~/add/codesnippet/visualbasic/m-system.string.indexof-_7_2.vb)]
 [!code-cs[system.string.IndexOfCmp#1](~/add/codesnippet/csharp/m-system.string.indexof-_7_2.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">A Unicode character to seek.</param>
        <param name="startIndex">The search starting position.</param>
        <param name="count">The number of character positions to examine.</param>
        <summary>Reports the zero-based index of the first occurrence of the specified character in this instance. The search starts at a specified character position and examines a specified number of character positions.</summary>
        <returns>The zero-based index position of <paramref name="value" /> from the start of the string if that character is found, or -1 if it is not.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The search begins at `startIndex` and continues to `startIndex` + `count` -1. The character at `startIndex` + `count` is not included in the search.  
  
 Index numbering starts from 0 (zero). The `startIndex` parameter can range from 0 to the length of the string instance.  
  
 This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same. To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=fullName> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Ã" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.  
  
   
  
## Examples  
 The following example demonstrates the <xref:System.String.IndexOf%2A> method.  
  
 [!code-cpp[system.string.indexof#1](~/add/codesnippet/cpp/m-system.string.indexof-_6_1.cpp)]
 [!code-cs[system.string.indexof#1](~/add/codesnippet/csharp/m-system.string.indexof-_6_1.cs)]
 [!code-vb[system.string.indexof#1](~/add/codesnippet/visualbasic/m-system.string.indexof-_6_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> or <paramref name="startIndex" /> is negative.  
  
 -or-  
  
 <paramref name="startIndex" /> is greater than the length of this string.  
  
 -or-  
  
 <paramref name="count" /> is greater than the length of this string minus <paramref name="startIndex" />.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">The string to seek.</param>
        <param name="startIndex">The search starting position.</param>
        <param name="count">The number of character positions to examine.</param>
        <summary>Reports the zero-based index of the first occurrence of the specified string in this instance. The search starts at a specified character position and examines a specified number of character positions.</summary>
        <returns>The zero-based index position of <paramref name="value" /> from the start of the current instance if that string is found, or -1 if it is not. If <paramref name="value" /> is <see cref="T:System.String" />, the return value is <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Index numbering starts from 0 (zero). The `startIndex` parameter can range from 0 to the length of the string instance.  
  
 This method performs a word (case-sensitive and culture-sensitive) search using the current culture. The search begins at `startIndex` and continues to `startIndex` + `count` -1. The character at `startIndex` + `count` is not included in the search.  
  
 Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison. In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed. If `value` consists only of one or more ignorable characters, the IndexOf method always returns `startIndex`, which is the character position at which the search begins. In the following example, the IndexOf method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting in the third through sixth character positions in two strings. Only one of the strings contains the required substring. If the example is run on the [!INCLUDE[netfx40_short](~/add/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison. Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".  
  
 [!code-cs[System.String.IndexOf#23](~/add/codesnippet/csharp/m-system.string.indexof-_0_1.cs)]
 [!code-vb[System.String.IndexOf#23](~/add/codesnippet/visualbasic/m-system.string.indexof-_0_1.vb)]  
  
   
  
## Examples  
 The following example finds the index of all occurrences of the string "he" within a substring of another string. Note that the number of characters to be searched must be recalculated for each search iteration.  
  
 [!code-cs[string.indexof8#1](~/add/codesnippet/csharp/m-system.string.indexof-_0_2.cs)]
 [!code-cpp[string.indexof8#1](~/add/codesnippet/cpp/m-system.string.indexof-_0_2.cpp)]
 [!code-vb[string.indexof8#1](~/add/codesnippet/visualbasic/m-system.string.indexof-_0_2.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> or <paramref name="startIndex" /> is negative.  
  
 -or-  
  
 <paramref name="startIndex" /> is greater than the length of this string.  
  
 -or-  
  
 <paramref name="count" /> is greater than the length of this string minus <paramref name="startIndex" />.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">The string to seek.</param>
        <param name="startIndex">The search starting position.</param>
        <param name="comparisonType">One of the enumeration values that specifies the rules for the search.</param>
        <summary>Reports the zero-based index of the first occurrence of the specified string in the current <see cref="T:System.String" /> object. Parameters specify the starting search position in the current string and the type of search to use for the specified string.</summary>
        <returns>The zero-based index position of the <paramref name="value" /> parameter from the start of the current instance if that string is found, or -1 if it is not. If <paramref name="value" /> is <see cref="T:System.String" />, the return value is <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Index numbering starts from 0. The `startIndex` parameter can range from 0 to the length of the string instance. If `startIndex` equals the length of the string instance, the method returns -1.  
  
 The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.  
  
   
  
## Examples  
 The following exampledemonstrates three overloads of the <xref:System.String.IndexOf%2A> method that find the first occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.  
  
 [!code-vb[system.string.IndexOfCmp#1](~/add/codesnippet/visualbasic/m-system.string.indexof-_4_2.vb)]
 [!code-cs[system.string.IndexOfCmp#1](~/add/codesnippet/csharp/m-system.string.indexof-_4_2.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is less than 0 (zero) or greater than the length of this string.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">The string to seek.</param>
        <param name="startIndex">The search starting position.</param>
        <param name="count">The number of character positions to examine.</param>
        <param name="comparisonType">One of the enumeration values that specifies the rules for the search.</param>
        <summary>Reports the zero-based index of the first occurrence of the specified string in the current <see cref="T:System.String" /> object. Parameters specify the starting search position in the current string, the number of characters in the current string to search, and the type of search to use for the specified string.</summary>
        <returns>The zero-based index position of the <paramref name="value" /> parameter from the start of the current instance if that string is found, or -1 if it is not. If <paramref name="value" /> is <see cref="T:System.String" />, the return value is <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Index numbering starts from 0 (zero). The `startIndex` parameter can range from 0 to the length of the string instance.  
  
 The search begins at `startIndex` and continues to `startIndex` + `count` -1. The character at `startIndex` + `count` is not included in the search.  
  
 The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.  
  
   
  
## Examples  
 The following exampledemonstrates three overloads of the <xref:System.String.IndexOf%2A> method that find the first occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.  
  
 [!code-vb[system.string.IndexOfCmp#1](~/add/codesnippet/visualbasic/fca1aed1-8a88-406c-8a0a-_2.vb)]
 [!code-cs[system.string.IndexOfCmp#1](~/add/codesnippet/csharp/fca1aed1-8a88-406c-8a0a-_2.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> or <paramref name="startIndex" /> is negative.  
  
 -or-  
  
 <paramref name="startIndex" /> is greater than the length of this instance.  
  
 -or-  
  
 <paramref name="count" /> is greater than the length of this string minus <paramref name="startIndex" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">A Unicode character array containing one or more characters to seek.</param>
        <summary>Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</summary>
        <returns>The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Index numbering starts from zero.  
  
 The search for `anyOf` is case-sensitive. If `anyOf` is an empty array, the method finds a match at the beginning of the string (that  is, at index zero).  
  
 This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same. To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=fullName> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Ã" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.  
  
   
  
## Examples  
 The following example finds the first vowel in a string.  
  
 [!code-cs[System.String.IndexOfAny#1](~/add/codesnippet/csharp/m-system.string.indexofa_0_1.cs)]
 [!code-vb[System.String.IndexOfAny#1](~/add/codesnippet/visualbasic/m-system.string.indexofa_0_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> is <see langword="null" />.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">A Unicode character array containing one or more characters to seek.</param>
        <param name="startIndex">The search starting position.</param>
        <summary>Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters. The search starts at a specified character position.</summary>
        <returns>The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Index numbering starts from zero. The `startIndex` parameter can range from 0 to one less than the length of the string instance.  
  
 The search ranges from `startIndex` to the end of the string.  
  
 The search for `anyOf` is case-sensitive.  
  
 This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same. To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=fullName> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Ã" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.  
  
   
  
## Examples  
 The following example finds the index of the occurrence of any character of the string "is" within a substring of another string.  
  
 [!code-cpp[string.indexofany2#1](~/add/codesnippet/cpp/m-system.string.indexofa_1_1.cpp)]
 [!code-vb[string.indexofany2#1](~/add/codesnippet/visualbasic/m-system.string.indexofa_1_1.vb)]
 [!code-cs[string.indexofany2#1](~/add/codesnippet/csharp/m-system.string.indexofa_1_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is negative.  
  
 -or-  
  
 <paramref name="startIndex" /> is greater than the number of characters in this instance.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">A Unicode character array containing one or more characters to seek.</param>
        <param name="startIndex">The search starting position.</param>
        <param name="count">The number of character positions to examine.</param>
        <summary>Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters. The search starts at a specified character position and examines a specified number of character positions.</summary>
        <returns>The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The search begins at `startIndex` and continues to `startIndex` + `count` -1. The character at `startIndex` + `count` is not included in the search.  
  
 Index numbering starts from zero. The `startIndex` parameter can range from 0 to one less than the length of the string instance.  
  
 The search for `anyOf` is case-sensitive.  
  
 This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same. To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=fullName> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Ã" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.  
  
   
  
## Examples  
 The following example finds the index of the occurrence of any character of the string "aid" within a substring of another string.  
  
 [!code-cpp[string.indexofany3#1](~/add/codesnippet/cpp/m-system.string.indexofa_2_1.cpp)]
 [!code-cs[string.indexofany3#1](~/add/codesnippet/csharp/m-system.string.indexofa_2_1.cs)]
 [!code-vb[string.indexofany3#1](~/add/codesnippet/visualbasic/m-system.string.indexofa_2_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> or <paramref name="startIndex" /> is negative.  
  
 -or-  
  
 <paramref name="count" /> + <paramref name="startIndex" /> is greater than the number of characters in this instance.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public string Insert (int startIndex, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Insert(int32 startIndex, string value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="startIndex">The zero-based index position of the insertion.</param>
        <param name="value">The string to insert.</param>
        <summary>Returns a new string in which a specified string is inserted at a specified index position in this instance.</summary>
        <returns>A new string that is equivalent to this instance, but with <paramref name="value" /> inserted at position <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If `startIndex` is equal to the length of this instance, `value` is appended to the end of this instance.  
  
> [!NOTE]
>  This method does not modify the value of the current instance. Instead, it returns a new string in which `value` is inserted into the current instance.  
  
 For example, the return value of `"abc".Insert(2, "XYZ")` is "abXYZc".  
  
   
  
## Examples  
 The following example inserts a space character in the fourth character position (the character at index 3) of a string.  
  
 [!code-cs[System.String.Insert#1](~/add/codesnippet/csharp/m-system.string.insert-s_1.cs)]
 [!code-vb[System.String.Insert#1](~/add/codesnippet/visualbasic/m-system.string.insert-s_1.vb)]  
  
 The following console application prompts the users to enter one or more adjectives to describe two animals. It then calls the Insert method to insert the text entered by the user into a string.  
  
 [!code-cpp[stringinsert#1](~/add/codesnippet/cpp/m-system.string.insert-s_2.cpp)]
 [!code-vb[stringinsert#1](~/add/codesnippet/visualbasic/m-system.string.insert-s_2.vb)]
 [!code-cs[stringinsert#1](~/add/codesnippet/csharp/m-system.string.insert-s_2.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is negative or greater than the length of this instance.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Intern">
      <MemberSignature Language="C#" Value="public static string Intern (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Intern(string str) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">A string to search for in the intern pool.</param>
        <summary>Retrieves the system's reference to the specified <see cref="T:System.String" />.</summary>
        <returns>The system's reference to <paramref name="str" />, if it is interned; otherwise, a new reference to a string with the value of <paramref name="str" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The common language runtime conserves string storage by maintaining a table, called the intern pool, that contains a single reference to each unique literal string declared or created programmatically in your program. Consequently, an instance of a literal string with a particular value only exists once in the system.  
  
 For example, if you assign the same literal string to several variables, the runtime retrieves the same reference to the literal string from the intern pool and assigns it to each variable.  
  
 The Intern method uses the intern pool to search for a string equal to the value of `str`. If such a string exists, its reference in the intern pool is returned. If the string does not exist, a reference to `str` is added to the intern pool, then that reference is returned.  
  
 In the following example, the string s1, which has a value of "MyTest", is already interned because it is a literal in the program. The <xref:System.Text.StringBuilder?displayProperty=fullName> class generates a new string object that has the same value as s1. A reference to that string is assigned to s2. The Intern method searches for a string that has the same value as s2. Because such a string exists, the method returns the same reference that is assigned to s1. That reference is then assigned to s3. References s1 and s2 compare unequal because they refer to different objects; references s1 and s3 compare equal because they refer to the same string.  
  
 [!code-cs[System.String.Intern#1](~/add/codesnippet/csharp/m-system.string.intern-s_1.cs)]
 [!code-vb[System.String.Intern#1](~/add/codesnippet/visualbasic/m-system.string.intern-s_1.vb)]  
  
 Compare this method to the <xref:System.String.IsInterned%2A> method.  
  
## Version Considerations  
 In the [!INCLUDE[net_v35SP1_long](~/add/includes/net-v35sp1-long-md.md)], the Intern method reverts to its behavior in the .NET Framework 1.0 and 1.1 with regard to interning the empty string. In the following example, the variable `str1` is assigned a reference to <xref:System.String.Empty>, and the variable `str2` is assigned the reference to <xref:System.String.Empty> that is returned by calling the Intern method after converting a <xref:System.Text.StringBuilder> object whose value is <xref:System.String.Empty> to a string. Then the references contained in `str1` and `str2` are compared for equality.  
  
 [!code-cs[System.String.Intern#2](~/add/codesnippet/csharp/m-system.string.intern-s_2.cs)]
 [!code-vb[System.String.Intern#2](~/add/codesnippet/visualbasic/m-system.string.intern-s_2.vb)]  
  
 In the [!INCLUDE[net_v10_short](~/add/includes/net-v10-short-md.md)], [!INCLUDE[net_v11_short](~/add/includes/net-v11-short-md.md)], and [!INCLUDE[net_v35SP1_short](~/add/includes/net-v35sp1-short-md.md)], `str1` and `str2` are equal. In the [!INCLUDE[net_v20sp1_long](~/add/includes/net-v20sp1-long-md.md)] and [!INCLUDE[net_v30_long](~/add/includes/net-v30-long-md.md)], `str1` and `str2` are not equal.  
  
## Performance Considerations  
 If you are trying to reduce the total amount of memory your application allocates, keep in mind that interning a string has two unwanted side effects. First, the memory allocated for interned <xref:System.String> objects is not likely be released until the common language runtime (CLR) terminates. The reason is that the CLR's reference to the interned <xref:System.String> object can persist after your application, or even your application domain, terminates. Second, to intern a string, you must first create the string. The memory used by the <xref:System.String> object must still be allocated, even though the memory will eventually be garbage collected.  
  
 The .NET Framework version 2.0 introduces the <xref:System.Runtime.CompilerServices.CompilationRelaxations?displayProperty=fullName>enumeration member. The <xref:System.Runtime.CompilerServices.CompilationRelaxations> member marks an assembly as not requiring string-literal interning. You can apply <xref:System.Runtime.CompilerServices.CompilationRelaxations> to an assembly using the <xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute> attribute. Also, when you use the [Ngen.exe (Native Image Generator)](../Topic/Ngen.exe%20\(Native%20Image%20Generator\).md) to compile an assembly in advance of run time, strings are not interned across modules.  
  
   
  
## Examples  
 The following example uses three strings that are equal in value to determine whether a newly created string and an interned string are equal.  
  
 [!code-cpp[string.intern#1](~/add/codesnippet/cpp/m-system.string.intern-s_3.cpp)]
 [!code-cs[string.intern#1](~/add/codesnippet/csharp/m-system.string.intern-s_3.cs)]
 [!code-vb[string.intern#1](~/add/codesnippet/visualbasic/m-system.string.intern-s_3.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> is <see langword="null" />.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IsInterned">
      <MemberSignature Language="C#" Value="public static string IsInterned (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string IsInterned(string str) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">The string to search for in the intern pool.</param>
        <summary>Retrieves a reference to a specified <see cref="T:System.String" />.</summary>
        <returns>A reference to <paramref name="str" /> if it is in the common language runtime intern pool; otherwise, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The common language runtime automatically maintains a table, called the intern pool, which contains a single instance of each unique literal string constant declared in a program, as well as any unique instance of <xref:System.String> you add programmatically by calling the <xref:System.String.Intern%2A> method.  
  
 The intern pool conserves string storage. If you assign a literal string constant to several variables, each variable is set to reference the same constant in the intern pool instead of referencing several different instances of <xref:System.String> that have identical values.  
  
 This method looks up `str` in the intern pool. If `str` has already been interned, a reference to that instance is returned; otherwise, `null` is returned.  
  
 Compare this method to the <xref:System.String.Intern%2A> method.  
  
 This method does not return a Boolean value. If you call the method because you want a Boolean value that indicates whether a particular string is interned, you can use code such as the following.  
  
 [!code-vb[System.String.IsInterned#1](~/add/codesnippet/visualbasic/m-system.string.isintern_1.vb)]
 [!code-cs[System.String.IsInterned#1](~/add/codesnippet/csharp/m-system.string.isintern_1.cs)]  
  
> [!NOTE]
>  Starting with the .NET Framework version 2.0, you can override the use of the intern pool when you use the [Ngen.exe (Native Image Generator)](../Topic/Ngen.exe%20\(Native%20Image%20Generator\).md) to install an assembly to the native image cache on a local computer. For more information, see Performance Considerations in the Remarks section for the <xref:System.String.Intern%2A> property.  
  
   
  
## Examples  
 The following example demonstrates that literal strings are interned automatically by the compiler.  
  
 [!code-cs[string.isinterned#1](~/add/codesnippet/csharp/m-system.string.isintern_2.cs)]
 [!code-vb[string.isinterned#1](~/add/codesnippet/visualbasic/m-system.string.isintern_2.vb)]
 [!code-cpp[string.isinterned#1](~/add/codesnippet/cpp/m-system.string.isintern_2.cpp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> is <see langword="null" />.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indicates whether this string is in Unicode normalization form C.</summary>
        <returns>
          <see langword="true" /> if this string is in normalization form C; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters. The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.  
  
 The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character. Normalization can be performed with several algorithms, called normalization forms, that obey different rules. The .NET Framework currently supports normalization forms C, D, KC, and KD.  
  
 For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=fullName>.  
  
   
  
## Examples  
 The following example determines whether a string is successfully normalized to various normalization forms.  
  
 [!code-vb[string.normalize#1](~/add/codesnippet/visualbasic/m-system.string.isnormal_0_1.vb)]
 [!code-cpp[string.normalize#1](~/add/codesnippet/cpp/m-system.string.isnormal_0_1.cpp)]
 [!code-cs[string.normalize#1](~/add/codesnippet/csharp/m-system.string.isnormal_0_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The current instance contains invalid Unicode characters.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">A Unicode normalization form.</param>
        <summary>Indicates whether this string is in the specified Unicode normalization form.</summary>
        <returns>
          <see langword="true" /> if this string is in the normalization form specified by the <paramref name="normalizationForm" /> parameter; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters. The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.  
  
 The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character. Normalization can be performed with several algorithms, called normalization forms, that obey different rules. The .NET Framework currently supports normalization forms C, D, KC, and KD.  
  
 For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=fullName>.  
  
   
  
## Examples  
 The following example demonstrates the <xref:System.String.IsNormalized%2A> and <xref:System.String.Normalize%2A> methods.  
  
 [!code-vb[string.normalize#1](~/add/codesnippet/visualbasic/m-system.string.isnormal_1_1.vb)]
 [!code-cpp[string.normalize#1](~/add/codesnippet/cpp/m-system.string.isnormal_1_1.cpp)]
 [!code-cs[string.normalize#1](~/add/codesnippet/csharp/m-system.string.isnormal_1_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The current instance contains invalid Unicode characters.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrEmpty">
      <MemberSignature Language="C#" Value="public static bool IsNullOrEmpty (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrEmpty(string value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">The string to test.</param>
        <summary>Indicates whether the specified string is <see langword="null" /> or an <see cref="F:System.String.Empty" /> string.</summary>
        <returns>
          <see langword="true" /> if the <paramref name="value" /> parameter is <see langword="null" /> or an empty string (""); otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 IsNullOrEmpty is a convenience method that enables you to simultaneously test whether a <xref:System.String> is `null` or its value is <xref:System.String>. It is equivalent to the following code:  
  
 [!code-cpp[System.String.IsNullOrEmpty#1](~/add/codesnippet/cpp/m-system.string.isnullor_0_1.cpp)]
 [!code-cs[System.String.IsNullOrEmpty#1](~/add/codesnippet/csharp/m-system.string.isnullor_0_1.cs)]
 [!code-vb[System.String.IsNullOrEmpty#1](~/add/codesnippet/visualbasic/m-system.string.isnullor_0_1.vb)]  
  
 You can use the <xref:System.String.IsNullOrWhiteSpace%2A> method to test whether a string is `null`, its value is <xref:System.String.Empty?displayProperty=fullName>,  or it consists only of white-space characters.  
  
## What is a null string?  
 A string is `null` if it has not been assigned a value (in C++ and Visual Basic) or if has explicitly been assigned a value of `null`. Although the [composite formatting](../Topic/Composite%20Formatting.md) feature can gracefully handle a null string, as the following example shows, attempting to call one if its members throws a <xref:System.NullReferenceException>.  
  
 [!code-cpp[System.String.IsNullOrEmpty#2](~/add/codesnippet/cpp/m-system.string.isnullor_0_2.cpp)]
 [!code-cs[System.String.IsNullOrEmpty#2](~/add/codesnippet/csharp/m-system.string.isnullor_0_2.cs)]
 [!code-vb[System.String.IsNullOrEmpty#2](~/add/codesnippet/visualbasic/m-system.string.isnullor_0_2.vb)]  
  
## What is an empty string?  
 A string is empty if it  is explicitly assigned an empty string ("") or <xref:System.String.Empty?displayProperty=fullName>. An empty string has a <xref:System.String.Length%2A> of 0.  The following example creates an empty string and displays its value and its length.  
  
 [!code-cpp[System.String.IsNullOrEmpty#3](~/add/codesnippet/cpp/m-system.string.isnullor_0_3.cpp)]
 [!code-cs[System.String.IsNullOrEmpty#3](~/add/codesnippet/csharp/m-system.string.isnullor_0_3.cs)]
 [!code-vb[System.String.IsNullOrEmpty#3](~/add/codesnippet/visualbasic/m-system.string.isnullor_0_3.vb)]  
  
   
  
## Examples  
 The following example examines three strings and determines whether each string has a value, is an empty string, or is `null`.  
  
 [!code-cs[String.IsNullOrEmpty#1](~/add/codesnippet/csharp/m-system.string.isnullor_0_4.cs)]
 [!code-cpp[String.IsNullOrEmpty#1](~/add/codesnippet/cpp/m-system.string.isnullor_0_4.cpp)]
 [!code-vb[String.IsNullOrEmpty#1](~/add/codesnippet/visualbasic/m-system.string.isnullor_0_4.vb)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsNullOrWhiteSpace (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrWhiteSpace(string value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">The string to test.</param>
        <summary>Indicates whether a specified string is <see langword="null" />, empty, or consists only of white-space characters.</summary>
        <returns>
          <see langword="true" /> if the <paramref name="value" /> parameter is <see langword="null" /> or <see cref="T:System.String" />, or if <paramref name="value" /> consists exclusively of white-space characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 IsNullOrWhiteSpace is a convenience method that is similar to the following  code, except that it offers superior performance:  
  
 [!code-cs[System.String.IsNullOrWhitespace#2](~/add/codesnippet/csharp/m-system.string.isnullor_1_1.cs)]
 [!code-vb[System.String.IsNullOrWhitespace#2](~/add/codesnippet/visualbasic/m-system.string.isnullor_1_1.vb)]  
  
 White-space characters are defined by the Unicode standard. The IsNullOrWhiteSpace method interprets any character that returns a value of `true` when it is passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName> method as a white-space character.  
  
   
  
## Examples  
 The following example creates a string array, and then passes each element of the array to the IsNullOrWhiteSpace method.  
  
 [!code-vb[System.String.IsNullOrWhiteSpace#1](~/add/codesnippet/visualbasic/m-system.string.isnullor_1_2.vb)]
 [!code-cs[System.String.IsNullOrWhiteSpace#1](~/add/codesnippet/csharp/m-system.string.isnullor_1_2.cs)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="separator">The string to use as a separator.`separator` is included in the returned string only if `values` has more than one element.</param>
        <param name="values">A collection that contains the strings to concatenate.</param>
        <summary>Concatenates the members of a constructed &lt;xref:System.Collections.Generic.IEnumerable%601&gt; collection of type <see cref="T:System.String" />, using the specified separator between each member.</summary>
        <returns>A string that consists of the members of <paramref name="values" /> delimited by the <paramref name="separator" /> string. If <paramref name="values" /> has no members, the method returns <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If `separator` is `null`, an empty string (<xref:System.String?displayProperty=fullName>) is used instead. If any member of `values` is `null`, an empty string is used instead.  
  
 Join is a convenience method that lets you concatenate each element in an `IEnumerable(Of String)` collection without first converting the elements to a string array. It is particularly useful with Language-Integrated Query (LINQ) query expressions. The following example passes a `List(Of String)` object that contains either the uppercase or lowercase letters of the alphabet to a lambda expression that selects letters that are equal to or greater than a particular letter (which, in the example, is "M"). The `IEnumerable(Of String)` collection returned by the <xref:System.Linq.Enumerable.Where%2A?displayProperty=fullName> method is passed to the Join method to display the result as a single string.  
  
 [!code-cs[System.String.Join#4](~/add/codesnippet/csharp/b02d03ba-30d8-4b66-9fc1-_1.cs)]
 [!code-vb[System.String.Join#4](~/add/codesnippet/visualbasic/b02d03ba-30d8-4b66-9fc1-_1.vb)]  
  
   
  
## Examples  
 The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100. It assigns the result to a <xref:System.Collections.Generic.List%601> object of type <xref:System.String>, which it then passes to the Join method.  
  
 [!code-cs[System.String.Join#3](~/add/codesnippet/csharp/b02d03ba-30d8-4b66-9fc1-_2.cs)]
 [!code-vb[System.String.Join#3](~/add/codesnippet/visualbasic/b02d03ba-30d8-4b66-9fc1-_2.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> is <see langword="null" />.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, object[] values) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">The string to use as a separator. `separator` is included in the returned string only if `values` has more than one element.</param>
        <param name="values">An array that contains the elements to concatenate.</param>
        <summary>Concatenates the elements of an object array, using the specified separator between each element.</summary>
        <returns>A string that consists of the elements of <paramref name="values" /> delimited by the <paramref name="separator" /> string. If <paramref name="values" /> is an empty array, the method returns <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If `separator` is `null` or if any element of `values` other than the first element is `null`, an empty string (<xref:System.String?displayProperty=fullName>) is used instead. See the Notes for Callers section if the first element of `values` is `null`.  
  
 Join is a convenience method that lets you concatenate each element in an object array without explicitly converting its elements to strings. The string representation of each object in the array is derived by calling that object's `ToString` method.  
  
   
  
## Examples  
 The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100. It assigns the result to a integer array, which it then passes to the Join method.  
  
 [!code-cs[System.String.Join#1](~/add/codesnippet/csharp/m-system.string.join-sys_2_2.cs)]
 [!code-vb[System.String.Join#1](~/add/codesnippet/visualbasic/m-system.string.join-sys_2_2.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> is <see langword="null" />.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="separator">The string to use as a separator. `separator` is included in the returned string only if `value` has more than one element.</param>
        <param name="value">An array that contains the elements to concatenate.</param>
        <summary>Concatenates all the elements of a string array, using the specified separator between each element.</summary>
        <returns>A string that consists of the elements in <paramref name="value" /> delimited by the <paramref name="separator" /> string. If <paramref name="value" /> is an empty array, the method returns <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 For example, if `separator` is ", " and the elements of `value` are "apple", "orange", "grape", and "pear", `Join(separator, value)` returns "apple, orange, grape, pear".  
  
 If `separator` is `null`, an empty string (<xref:System.String?displayProperty=fullName>) is used instead. If any element in `value` is `null`, an empty string is used instead.  
  
   
  
## Examples  
 The following example demonstrates the Join method.  
  
 [!code-vb[stringjoin#1](~/add/codesnippet/visualbasic/m-system.string.join-sys_1_1.vb)]
 [!code-cs[stringjoin#1](~/add/codesnippet/csharp/m-system.string.join-sys_1_1.cs)]
 [!code-cpp[stringjoin#1](~/add/codesnippet/cpp/m-system.string.join-sys_1_1.cpp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">The string to use as a separator. `separator` is included in the returned string only if `value` has more than one element.</param>
        <param name="value">An array that contains the elements to concatenate.</param>
        <param name="startIndex">The first element in `value` to use.</param>
        <param name="count">The number of elements of `value` to use.</param>
        <summary>Concatenates the specified elements of a string array, using the specified separator between each element.</summary>
        <returns>A string that consists of the strings in <paramref name="value" /> delimited by the <paramref name="separator" /> string.  
  
 -or-  
  
 <see cref="T:System.String" /> if <paramref name="count" /> is zero, <paramref name="value" /> has no elements, or <paramref name="separator" /> and all the elements of <paramref name="value" /> are <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 For example, if `separator` is ", " and the elements of `value` are "apple", "orange", "grape", and "pear", `Join(separator, value, 1, 2)` returns "orange, grape".  
  
 If `separator` is `null`, an empty string (<xref:System.String?displayProperty=fullName>) is used instead. If any element in `value` is `null`, an empty string is used instead.  
  
   
  
## Examples  
 The following example concatenates two elements from an array of names of fruit.  
  
 [!code-cs[string.join2#1](~/add/codesnippet/csharp/m-system.string.join-sys_0_1.cs)]
 [!code-vb[string.join2#1](~/add/codesnippet/visualbasic/m-system.string.join-sys_0_1.vb)]
 [!code-cpp[string.join2#1](~/add/codesnippet/cpp/m-system.string.join-sys_0_1.cpp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> or <paramref name="count" /> is less than 0.  
  
 -or-  
  
 <paramref name="startIndex" /> plus <paramref name="count" /> is greater than the number of elements in <paramref name="value" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Out of memory.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">The Unicode character to seek.</param>
        <summary>Reports the zero-based index position of the last occurrence of a specified Unicode character within this instance.</summary>
        <returns>The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Index numbering starts from zero. That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.  
  
 This method begins searching at the last character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined. The search is case-sensitive.  
  
 This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same. To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=fullName> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Ã" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.  
  
   
  
## Examples  
 The following example defines an `ExtractFilename` method that uses the LastIndexOf method to find the last directory separator character in a string and to extract the string's file name. If the file exists, the method returns the file name without its path.  
  
 [!code-cs[System.String.LastIndexOf#1](~/add/codesnippet/csharp/m-system.string.lastinde_8_1.cs)]
 [!code-vb[System.String.LastIndexOf#1](~/add/codesnippet/visualbasic/m-system.string.lastinde_8_1.vb)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">The string to seek.</param>
        <summary>Reports the zero-based index position of the last occurrence of a specified string within this instance.</summary>
        <returns>The zero-based starting index position of <paramref name="value" /> if that string is found, or -1 if it is not. If <paramref name="value" /> is <see cref="T:System.String" />, the return value is the last index position in this instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Index numbering starts from zero. That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.  
  
 The search begins at the last character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined.  
  
 This method performs a word (case-sensitive and culture-sensitive) search using the current culture.  
  
 Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison. In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed. If `value` consists only of one or more ignorable characters, the LastIndexOf method always returns <xref:System.String.Length%2A?displayProperty=fullName> â 1, which represents the last index position in the current instance. In the following example, the LastIndexOf method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings. Only one of the strings contains a soft hyphen. If the example is run on the [!INCLUDE[netfx40_short](~/add/includes/netfx40-short-md.md)] or later, in each case, because the soft hyphen is an ignorable character, the result is the same as if the soft hyphen had not been included in `value`. When searching for a soft hyphen only, the method returns 6 and 5. These values correspond to the index of the last character in the two strings.  
  
 [!code-cs[System.String.LastIndexOf#21](~/add/codesnippet/csharp/m-system.string.lastinde_10_1.cs)]
 [!code-vb[System.String.LastIndexOf#21](~/add/codesnippet/visualbasic/m-system.string.lastinde_10_1.vb)]  
  
   
  
## Examples  
 The following example removes opening and closing HTML tags from a string if the tags begin and end the string. If a string ends with a closing bracket character (">"), the example uses the LastIndexOf method to locate the start of the end tag.  
  
 [!code-cs[System.String.LastIndexOf#2](~/add/codesnippet/csharp/m-system.string.lastinde_10_2.cs)]
 [!code-vb[System.String.LastIndexOf#2](~/add/codesnippet/visualbasic/m-system.string.lastinde_10_2.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">The Unicode character to seek.</param>
        <param name="startIndex">The starting position of the search. The search proceeds from `startIndex` toward the beginning of this instance.</param>
        <summary>Reports the zero-based index position of the last occurrence of a specified Unicode character within this instance. The search starts at a specified character position and proceeds backward toward the beginning of the string.</summary>
        <returns>The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Index numbering starts from zero. That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.This method begins searching at the `startIndex` character position of this instance and proceeds backward toward the beginning of the current instance until either `value` is found or the first character position has been examined. For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches every character from the last character in the string to the beginning. The search is case-sensitive.  
  
 This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same. To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=fullName> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Ã" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.  
  
   
  
## Examples  
 The following example finds the index of all occurrences of a character in a string, working from the end of the string to the start of the string.  
  
 [!code-cs[string.lastindexof1#1](~/add/codesnippet/csharp/m-system.string.lastinde_4_1.cs)]
 [!code-cpp[string.lastindexof1#1](~/add/codesnippet/cpp/m-system.string.lastinde_4_1.cpp)]
 [!code-vb[string.lastindexof1#1](~/add/codesnippet/visualbasic/m-system.string.lastinde_4_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than zero or greater than or equal to the length of this instance.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">The string to seek.</param>
        <param name="startIndex">The search starting position. The search proceeds from `startIndex` toward the beginning of this instance.</param>
        <summary>Reports the zero-based index position of the last occurrence of a specified string within this instance. The search starts at a specified character position and proceeds backward toward the beginning of the string.</summary>
        <returns>The zero-based starting index position of <paramref name="value" /> if that string is found, or -1 if it is not found or if the current instance equals <see cref="T:System.String" />. If <paramref name="value" /> is <see cref="T:System.String" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Index numbering starts from zero. That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.  
  
 The search begins at the `startIndex` character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined. For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches every character from the last character in the string to the beginning.  
  
 This method performs a word (case-sensitive and culture-sensitive) search using the current culture.  
  
 Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison. In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed. If `value` consists only of one or more ignorable characters, the LastIndexOf method always returns `startIndex`, which is the character position at which the search begins. In the following example, the LastIndexOf method is used to find a substring that includes a soft hyphen (U+00AD) and that precedes or includes the final "m" in a string. If the example is run on the [!INCLUDE[netfx40_short](~/add/includes/netfx40-short-md.md)] or later, because the soft hyphen in the search string is ignored, calling the method to find a substring that consists of the soft hyphen and "m" returns the position of the "m" in the string, whereas calling it to find a substring that consists of the soft hyphen and "n" returns the position of the "n". When the search string contains only the soft hyphen, the method returns the index of the "m", which represents the value of `startIndex`.  
  
 [!code-cs[System.String.LastIndexOf#22](~/add/codesnippet/csharp/m-system.string.lastinde_0_1.cs)]
 [!code-vb[System.String.LastIndexOf#22](~/add/codesnippet/visualbasic/m-system.string.lastinde_0_1.vb)]  
  
   
  
## Examples  
 The following example finds the index of all occurrences of a string in target string, working from the end of the target string to the start of the target string.  
  
 [!code-cpp[string.lastindexof7#1](~/add/codesnippet/cpp/m-system.string.lastinde_0_2.cpp)]
 [!code-vb[string.lastindexof7#1](~/add/codesnippet/visualbasic/m-system.string.lastinde_0_2.vb)]
 [!code-cs[string.lastindexof7#1](~/add/codesnippet/csharp/m-system.string.lastinde_0_2.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The current instance does not equal <see cref="T:System.String" />, and <paramref name="startIndex" /> is less than zero or greater than the length of the current instance.  
  
 -or-  
  
 The current instance equals <see cref="T:System.String" />, and <paramref name="startIndex" /> is less than -1 or greater than zero.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">The string to seek.</param>
        <param name="comparisonType">One of the enumeration values that specifies the rules for the search.</param>
        <summary>Reports the zero-based index of the last occurrence of a specified string within the current <see cref="T:System.String" /> object. A parameter specifies the type of search to use for the specified string.</summary>
        <returns>The zero-based starting index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not. If <paramref name="value" /> is <see cref="T:System.String" />, the return value is the last index position in this instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Index numbering starts from zero. That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.  
  
 The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.  
  
 The search begins at the last character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined.  
  
   
  
## Examples  
 The following exampledemonstrates three overloads of the <xref:System.String.LastIndexOf%2A> method that find the last occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.  
  
 [!code-cs[system.string.LastIndexOfCmp#1](~/add/codesnippet/csharp/m-system.string.lastinde_6_2.cs)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/add/codesnippet/visualbasic/m-system.string.lastinde_6_2.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">The Unicode character to seek.</param>
        <param name="startIndex">The starting position of the search. The search proceeds from `startIndex` toward the beginning of this instance.</param>
        <param name="count">The number of character positions to examine.</param>
        <summary>Reports the zero-based index position of the last occurrence of the specified Unicode character in a substring within this instance. The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</summary>
        <returns>The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Index numbering starts from zero. That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.  
  
 This method begins searching at the `startIndex` character position and proceeds backward toward the beginning of this instance until either `value` is found or `count` character positions have been examined. For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches backward `count` characters from the last character in the string. The search is case-sensitive.  
  
 This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same. To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=fullName> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Ã" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.  
  
   
  
## Examples  
 The following example finds the index of all occurrences of a character in a substring, working from the end of the substring to the start of the substring.  
  
 [!code-cs[string.lastindexof2#1](~/add/codesnippet/csharp/m-system.string.lastinde_9_1.cs)]
 [!code-vb[string.lastindexof2#1](~/add/codesnippet/visualbasic/m-system.string.lastinde_9_1.vb)]
 [!code-cpp[string.lastindexof2#1](~/add/codesnippet/cpp/m-system.string.lastinde_9_1.cpp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than zero or greater than or equal to the length of this instance.  
  
 -or-  
  
 The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> - <paramref name="count" /> + 1 is less than zero.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">The string to seek.</param>
        <param name="startIndex">The search starting position. The search proceeds from `startIndex` toward the beginning of this instance.</param>
        <param name="count">The number of character positions to examine.</param>
        <summary>Reports the zero-based index position of the last occurrence of a specified string within this instance. The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</summary>
        <returns>The zero-based starting index position of <paramref name="value" /> if that string is found, or -1 if it is not found or if the current instance equals <see cref="T:System.String" />. If <paramref name="value" /> is <see cref="T:System.String" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Index numbering starts from zero. That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.  
  
 The search begins at the `startIndex` character position of this instance and proceeds backward toward the beginning until either `value` is found or `count` character positions have been examined. For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches backward `count` characters from the last character in the string.  
  
 This method performs a word (case-sensitive and culture-sensitive) search using the current culture.  
  
 Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison. In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed. If `value` consists only of one or more ignorable characters, the LastIndexOf method always returns `startIndex`, which is the character position at which the search begins. In the following example, the LastIndexOf method is used to find the position of a soft hyphen (U+00AD) in the two characters that precede the final "m" of two strings. Only one of the strings contains the required substring. If the example is run on the [!INCLUDE[netfx40_short](~/add/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison. Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".  
  
 [!code-cs[System.String.LastIndexOf#23](~/add/codesnippet/csharp/m-system.string.lastinde_5_1.cs)]
 [!code-vb[System.String.LastIndexOf#23](~/add/codesnippet/visualbasic/m-system.string.lastinde_5_1.vb)]  
  
   
  
## Examples  
 The following example finds the index of all occurrences of a string in substring, working from the end of the substring to the start of the substring.  
  
 [!code-cpp[string.lastindexof8#1](~/add/codesnippet/cpp/m-system.string.lastinde_5_2.cpp)]
 [!code-vb[string.lastindexof8#1](~/add/codesnippet/visualbasic/m-system.string.lastinde_5_2.vb)]
 [!code-cs[string.lastindexof8#1](~/add/codesnippet/csharp/m-system.string.lastinde_5_2.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> is negative.  
  
 -or-  
  
 The current instance does not equal <see cref="T:System.String" />, and <paramref name="startIndex" /> is negative.  
  
 -or-  
  
 The current instance does not equal <see cref="T:System.String" />, and <paramref name="startIndex" /> is greater than the length of this instance.  
  
 -or-  
  
 The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> - <paramref name="count" />+ 1 specifies a position that is not within this instance.  
  
 -or-  
  
 The current instance equals <see cref="F:System.String.Empty" /> and <paramref name="start" /> is less than -1 or greater than zero.  
  
 -or-  
  
 The current instance equals <see cref="F:System.String.Empty" /> and <paramref name="count" /> is greater than 1.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">The string to seek.</param>
        <param name="startIndex">The search starting position. The search proceeds from `startIndex` toward the beginning of this instance.</param>
        <param name="comparisonType">One of the enumeration values that specifies the rules for the search.</param>
        <summary>Reports the zero-based index of the last occurrence of a specified string within the current <see cref="T:System.String" /> object. The search starts at a specified character position and proceeds backward toward the beginning of the string. A parameter specifies the type of comparison to perform when searching for the specified string.</summary>
        <returns>The zero-based starting index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not found or if the current instance equals <see cref="T:System.String" />. If <paramref name="value" /> is <see cref="T:System.String" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Index numbering starts from zero. That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.  
  
 The search begins at the `startIndex` character position and proceeds backward until either `value` is found or the first character position has been examined. For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches every character from the last character in the string to the beginning.  
  
 The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.  
  
   
  
## Examples  
 The following exampledemonstrates three overloads of the <xref:System.String.LastIndexOf%2A> method that find the last occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.  
  
 [!code-cs[system.string.LastIndexOfCmp#1](~/add/codesnippet/csharp/m-system.string.lastinde_2_2.cs)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/add/codesnippet/visualbasic/m-system.string.lastinde_2_2.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The current instance does not equal <see cref="T:System.String" />, and <paramref name="startIndex" /> is less than zero or greater than the length of the current instance.  
  
 -or-  
  
 The current instance equals <see cref="T:System.String" />, and <paramref name="startIndex" /> is less than -1 or greater than zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">The string to seek.</param>
        <param name="startIndex">The search starting position. The search proceeds from `startIndex` toward the beginning of this instance.</param>
        <param name="count">The number of character positions to examine.</param>
        <param name="comparisonType">One of the enumeration values that specifies the rules for the search.</param>
        <summary>Reports the zero-based index position of the last occurrence of a specified string within this instance. The search starts at a specified character position and proceeds backward toward the beginning of the string for the specified number of character positions. A parameter specifies the type of comparison to perform when searching for the specified string.</summary>
        <returns>The zero-based starting index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not found or if the current instance equals <see cref="T:System.String" />. If <paramref name="value" /> is <see cref="T:System.String" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Index numbering starts from zero. That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.  
  
 The search begins at the `startIndex` character position and proceeds backward until either `value` is found or `count` character positions have been examined. For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches backward `count` characters from the last character in the string.  
  
 The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.  
  
   
  
## Examples  
 The following exampledemonstrates three overloads of the <xref:System.String.LastIndexOf%2A> method that find the last occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.  
  
 [!code-cs[system.string.LastIndexOfCmp#1](~/add/codesnippet/csharp/ebc12778-1ccc-4a21-b937-_2.cs)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/add/codesnippet/visualbasic/ebc12778-1ccc-4a21-b937-_2.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> is negative.  
  
 -or-  
  
 The current instance does not equal <see cref="T:System.String" />, and <paramref name="startIndex" /> is negative.  
  
 -or-  
  
 The current instance does not equal <see cref="T:System.String" />, and <paramref name="startIndex" /> is greater than the length of this instance.  
  
 -or-  
  
 The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> + 1 - <paramref name="count" /> specifies a position that is not within this instance.  
  
 -or-  
  
 The current instance equals <see cref="F:System.String.Empty" /> and <paramref name="start" /> is less than -1 or greater than zero.  
  
 -or-  
  
 The current instance equals <see cref="F:System.String.Empty" /> and <paramref name="count" /> is greater than 1.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">A Unicode character array containing one or more characters to seek.</param>
        <summary>Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</summary>
        <returns>The index position of the last occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Index numbering starts from zero.  
  
 This method begins searching at the last character position of this instance and proceeds backward toward the beginning until either a character in `anyOf` is found or the first character position has been examined. The search is case-sensitive.  
  
 This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same. To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=fullName> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Ã" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.  
  
   
  
## Examples  
 The following example finds the index of the last occurrence of any character in the string "is" within another string.  
  
 [!code-cpp[string.lastindexofany1#1](~/add/codesnippet/cpp/m-system.string.lastinde_3_1.cpp)]
 [!code-cs[string.lastindexofany1#1](~/add/codesnippet/csharp/m-system.string.lastinde_3_1.cs)]
 [!code-vb[string.lastindexofany1#1](~/add/codesnippet/visualbasic/m-system.string.lastinde_3_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> is <see langword="null" />.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">A Unicode character array containing one or more characters to seek.</param>
        <param name="startIndex">The search starting position. The search proceeds from `startIndex` toward the beginning of this instance.</param>
        <summary>Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array. The search starts at a specified character position and proceeds backward toward the beginning of the string.</summary>
        <returns>The index position of the last occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found or if the current instance equals <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Index numbering starts from zero.  
  
 This method begins searching at the `startIndex` character position of this instance and proceeds backward toward the beginning until either a character in `anyOf` is found or the first character position has been examined. The search is case-sensitive.  
  
 This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same. To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=fullName> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Ã" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.  
  
   
  
## Examples  
 The following example finds the index of the last occurrence of any character in the string "is" within a substring of another string.  
  
 [!code-cpp[string.lastindexofany2#1](~/add/codesnippet/cpp/m-system.string.lastinde_7_1.cpp)]
 [!code-cs[string.lastindexofany2#1](~/add/codesnippet/csharp/m-system.string.lastinde_7_1.cs)]
 [!code-vb[string.lastindexofany2#1](~/add/codesnippet/visualbasic/m-system.string.lastinde_7_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> specifies a position that is not within this instance.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">A Unicode character array containing one or more characters to seek.</param>
        <param name="startIndex">The search starting position. The search proceeds from `startIndex` toward the beginning of this instance.</param>
        <param name="count">The number of character positions to examine.</param>
        <summary>Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array. The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</summary>
        <returns>The index position of the last occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found or if the current instance equals <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Index numbering starts from zero.  
  
 This method begins searching at the `startIndex` character position of this instance and proceeds backward toward the beginning until either a character in `anyOf` is found or `count` character positions have been examined. The search is case-sensitive.  
  
 This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same. To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=fullName> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Ã" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.  
  
   
  
## Examples  
 The following example finds the index of the last occurrence of any character in the string "aid" within a substring of another string.  
  
 [!code-cs[string.lastindexofany3#1](~/add/codesnippet/csharp/m-system.string.lastinde_1_1.cs)]
 [!code-cpp[string.lastindexofany3#1](~/add/codesnippet/cpp/m-system.string.lastinde_1_1.cpp)]
 [!code-vb[string.lastindexofany3#1](~/add/codesnippet/visualbasic/m-system.string.lastinde_1_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="count" /> or <paramref name="startIndex" /> is negative.  
  
 -or-  
  
 The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> minus <paramref name="count" /> + 1 is less than zero.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of characters in the current <see cref="T:System.String" /> object.</summary>
        <value>The number of characters in the current string.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The Length property returns the number of <xref:System.Char> objects in this instance, not the number of Unicode characters. The reason is that a Unicode character might be represented by more than one <xref:System.Char>. Use the <xref:System.Globalization.StringInfo?displayProperty=fullName> class to work with each Unicode character instead of each <xref:System.Char>.  
  
 In some languages, such as C and C++, a null character indicates the end of a string. In the .NET Framework, a null character can be embedded in a string. When a string includes one or more null characters, they are included in the length of the total string. For example, in the following string, the substrings "abc" and "def" are separated by a null character. The Length property returns 7, which indicates that it includes the six alphabetic characters as well as the null character.  
  
 [!code-vb[System.String.Class#1](~/add/codesnippet/visualbasic/p-system.string.length_1.vb)]
 [!code-cs[System.String.Class#1](~/add/codesnippet/csharp/p-system.string.length_1.cs)]
 [!code-cpp[System.String.Class#1](~/add/codesnippet/cpp/p-system.string.length_1.cpp)]  
  
   
  
## Examples  
 The following example demonstrates the Length property.  
  
 [!code-cpp[string.length#1](~/add/codesnippet/cpp/p-system.string.length_2.cpp)]
 [!code-cs[string.length#1](~/add/codesnippet/csharp/p-system.string.length_2.cs)]
 [!code-vb[string.length#1](~/add/codesnippet/visualbasic/p-system.string.length_2.vb)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a new string whose textual value is the same as this string, but whose binary representation is in Unicode normalization form C.</summary>
        <returns>A new, normalized string whose textual value is the same as this string, but whose binary representation is in normalization form C.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters. For example, any of the following code points can represent the letter "áº¯":  
  
-   U+1EAF  
  
-   U+0103 U+0301  
  
-   U+0061 U+0306 U+0301  
  
 The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.  
  
 The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character. Normalization can be performed with several algorithms, called normalization forms, that obey different rules. The .NET Framework supports the four normalization forms (C, D, KC, and KD)that are defined by the Unicode standard.When two strings are represented in the same normalization form, theycan be compared by using ordinal comparison.  
  
 To normalize and compare two strings, do the following:  
  
1.  Obtain the strings to be compared from an input source, such as a file or a user input device.  
  
2.  Call the Normalize method to normalize the strings to normalization form C.  
  
3.  To compare two strings, call a method that supports ordinal string comparison, such as the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, and supply a value of <xref:System.StringComparison?displayProperty=fullName> or <xref:System.StringComparison?displayProperty=fullName>as the <xref:System.StringComparison> argument. To sort an array of normalized strings, pass a `comparer` value of <xref:System.StringComparer.Ordinal%2A?displayProperty=fullName> or <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=fullName> to an appropriate overload of <xref:System.Array.Sort%2A?displayProperty=fullName>.  
  
4.  Emit the strings in the sorted output based on the order indicated by the previous step.  
  
 For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=fullName>.  
  
   
  
## Examples  
 The following example normalizes a string to each of four normalization forms, confirms the string was normalized to the specified normalization form, then lists the code points in the normalized string.  
  
 [!code-vb[string.normalize#1](~/add/codesnippet/visualbasic/m-system.string.normalize_1.vb)]
 [!code-cpp[string.normalize#1](~/add/codesnippet/cpp/m-system.string.normalize_1.cpp)]
 [!code-cs[string.normalize#1](~/add/codesnippet/csharp/m-system.string.normalize_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The current instance contains invalid Unicode characters.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">A Unicode normalization form.</param>
        <summary>Returns a new string whose textual value is the same as this string, but whose binary representation is in the specified Unicode normalization form.</summary>
        <returns>A new string whose textual value is the same as this string, but whose binary representation is in the normalization form specified by the <paramref name="normalizationForm" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters. The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.  
  
 The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character. Normalization can be performed with several algorithms, called normalization forms, that obey different rules. The .NET Framework supports the four normalization forms (C, D, KC, and KD)that are defined by the Unicode standard.When two strings are represented in the same normalization form, they can be compared by using ordinal comparison.  
  
 To normalize and compare two strings, do the following:  
  
1.  Obtain the strings to be compared from an input source, such as a file or a user input device.  
  
2.  Call the Normalize method to normalize the strings to a specified normalization form.  
  
3.  To compare two strings, call a method that supports ordinal string comparison, such as the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, and supply a value of <xref:System.StringComparison?displayProperty=fullName> or <xref:System.StringComparison?displayProperty=fullName> as the <xref:System.StringComparison> argument. To sort an array of normalized strings, pass a `comparer` value of <xref:System.StringComparer.Ordinal%2A?displayProperty=fullName> or <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=fullName> to an appropriate overload of <xref:System.Array.Sort%2A?displayProperty=fullName>.  
  
4.  Emit the strings in the sorted output based on the order indicated by the previous step.  
  
 For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=fullName>.  
  
   
  
## Examples  
 The following example normalizes a string to each of four normalization forms, confirms the string was normalized to the specified normalization form, then lists the code points in the normalized string.  
  
 [!code-vb[string.normalize#1](~/add/codesnippet/visualbasic/m-system.string.normaliz_1.vb)]
 [!code-cpp[string.normalize#1](~/add/codesnippet/cpp/m-system.string.normaliz_1.cpp)]
 [!code-cs[string.normalize#1](~/add/codesnippet/csharp/m-system.string.normaliz_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The current instance contains invalid Unicode characters.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool op_Equality (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(string a, string b) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">The first string to compare, or <see langword="null" />.</param>
        <param name="b">The second string to compare, or <see langword="null" />.</param>
        <summary>Determines whether two specified strings have the same value.</summary>
        <returns>
          <see langword="true" /> if the value of <paramref name="a" /> is the same as the value of <paramref name="b" />; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The Equality method defines the operation of the equality operator for the <xref:System.String> class. It enables code such as that shown in the Example section. The operator, in turn, calls the static <xref:System.String.Equals%28System.String%2CSystem.String%29> method, which performs an ordinal (case-sensitive and culture-insensitive) comparison.  
  
> [!NOTE]
>  The Visual Basic compiler does not resolve the equality operator as a call to the Equality method. Instead, the equality operator wraps a call to the <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=fullName> method.  
  
   
  
## Examples  
 The following example demonstrates the equality operator.  
  
 [!code-cs[system.string.equality#1](~/add/codesnippet/csharp/m-system.string.op-equal_1.cs)]
 [!code-cpp[system.string.equality#1](~/add/codesnippet/cpp/m-system.string.op-equal_1.cpp)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool op_Inequality (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(string a, string b) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">The first string to compare, or <see langword="null" />.</param>
        <param name="b">The second string to compare, or <see langword="null" />.</param>
        <summary>Determines whether two specified strings have different values.</summary>
        <returns>
          <see langword="true" /> if the value of <paramref name="a" /> is different from the value of <paramref name="b" />; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The Inequality method defines the operation of the inequality operator for the <xref:System.String> class.   It enables code such as that shown in the Examples section.  
  
 The Inequality operator in turn calls the static <xref:System.String.Equals%28System.String%2CSystem.String%29> method, which  performs an ordinal (case-sensitive and culture-insensitive) comparison.  
  
> [!NOTE]
>  The Visual Basic compiler does not resolve the inequality operator as a call to the Inequality method. Instead, the inequality operator wraps a call to the <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=fullName> method.  
  
   
  
## Examples  
 The following example demonstrates the inequality operator.  
  
 [!code-cpp[system.string.inequality#1](~/add/codesnippet/cpp/m-system.string.op-inequ_1.cpp)]
 [!code-cs[system.string.inequality#1](~/add/codesnippet/csharp/m-system.string.op-inequ_1.cs)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</param>
        <summary>Returns a new string that right-aligns the characters in this instance by padding them with spaces on the left, for a specified total length.</summary>
        <returns>A new string that is equivalent to this instance, but right-aligned and padded on the left with as many spaces as needed to create a length of <paramref name="totalWidth" />. However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance. If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A Unicode space is defined as hexadecimal 0x0020.  
  
 The PadLeft method pads the beginning of the returned string. This means that, when used with right-to-left languages, it pads the right portion of the string.  
  
> [!NOTE]
>  If the PadLeftmethod pads the current instance with whitespace characters, this method does not modify the value of the current instance. Instead, it returns a new string that is padded with leading white space so that its total length is `totalWidth` characters.  
  
   
  
## Examples  
 The following example demonstrates the PadLeft method.  
  
 [!code-cs[Classic String.PadLeft Example#1](~/add/codesnippet/csharp/m-system.string.padleft-_0_1.cs)]
 [!code-vb[Classic String.PadLeft Example#1](~/add/codesnippet/visualbasic/m-system.string.padleft-_0_1.vb)]
 [!code-cpp[Classic String.PadLeft Example#1](~/add/codesnippet/cpp/m-system.string.padleft-_0_1.cpp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> is less than zero.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth, char paddingChar) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</param>
        <param name="paddingChar">A Unicode padding character.</param>
        <summary>Returns a new string that right-aligns the characters in this instance by padding them on the left with a specified Unicode character, for a specified total length.</summary>
        <returns>A new string that is equivalent to this instance, but right-aligned and padded on the left with as many <paramref name="paddingChar" /> characters as needed to create a length of <paramref name="totalWidth" />. However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance. If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The PadLeft method pads the beginning of the returned string. This means that, when used with right-to-left languages, it pads the right portion of the string.  
  
> [!NOTE]
>  If the <xref:System.String.PadLeft%2A> method pads the current instance with whitespace characters, this method does not modify the value of the current instance. Instead, it returns a new string that is padded with leading `paddingChar` characters so that its total length is `totalWidth` characters.  
  
   
  
## Examples  
 The following example demonstrates the <xref:System.String.PadLeft%2A> method.  
  
 [!code-cpp[Classic String.PadLeft1 Example#1](~/add/codesnippet/cpp/m-system.string.padleft-_1_1.cpp)]
 [!code-cs[Classic String.PadLeft1 Example#1](~/add/codesnippet/csharp/m-system.string.padleft-_1_1.cs)]
 [!code-vb[Classic String.PadLeft1 Example#1](~/add/codesnippet/visualbasic/m-system.string.padleft-_1_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> is less than zero.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</param>
        <summary>Returns a new string that left-aligns the characters in this string by padding them with spaces on the right, for a specified total length.</summary>
        <returns>A new string that is equivalent to this instance, but left-aligned and padded on the right with as many spaces as needed to create a length of <paramref name="totalWidth" />. However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance. If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A Unicode space is defined as hexadecimal 0x0020.  
  
 The PadRight method pads the end of the returned string. This means that, when used with right-to-left languages, it pads the left portion of the string.  
  
> [!NOTE]
>  If thePadRight method pads the current instance with whitespace characters, this method does not modify the value of the current instance. Instead, it returns a new string that is padded with trailing white space so that its total length is `totalWidth` characters.  
  
   
  
## Examples  
 The following example demonstrates the PadRight method.  
  
 [!code-cpp[Classic String.PadRight Example#1](~/add/codesnippet/cpp/m-system.string.padright_0_1.cpp)]
 [!code-vb[Classic String.PadRight Example#1](~/add/codesnippet/visualbasic/m-system.string.padright_0_1.vb)]
 [!code-cs[Classic String.PadRight Example#1](~/add/codesnippet/csharp/m-system.string.padright_0_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> is less than zero.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth, char paddingChar) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</param>
        <param name="paddingChar">A Unicode padding character.</param>
        <summary>Returns a new string that left-aligns the characters in this string by padding them on the right with a specified Unicode character, for a specified total length.</summary>
        <returns>A new string that is equivalent to this instance, but left-aligned and padded on the right with as many <paramref name="paddingChar" /> characters as needed to create a length of <paramref name="totalWidth" />. However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance. If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The PadRight method pads the end of the returned string. This means that, when used with right-to-left languages, it pads the left portion of the string.  
  
> [!NOTE]
>  If the <xref:System.String.PadRight%2A> method pads the current instance with whitespace characters, this method does not modify the value of the current instance. Instead, it returns a new string that is padded with trailing `paddingChar` characters so that its total length is `totalWidth` characters.  
  
   
  
## Examples  
 The following example demonstrates the <xref:System.String.PadRight%2A> method.  
  
 [!code-vb[Classic String.PadRight1 Example#1](~/add/codesnippet/visualbasic/m-system.string.padright_1_1.vb)]
 [!code-cs[Classic String.PadRight1 Example#1](~/add/codesnippet/csharp/m-system.string.padright_1_1.cs)]
 [!code-cpp[Classic String.PadRight1 Example#1](~/add/codesnippet/cpp/m-system.string.padright_1_1.cpp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> is less than zero.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">The zero-based position to begin deleting characters.</param>
        <summary>Returns a new string in which all the characters in the current instance, beginning at a specified position and continuing through the last position, have been deleted.</summary>
        <returns>A new string that is equivalent to this string except for the removed characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In the [!INCLUDE[dnprdnshort](~/add/includes/dnprdnshort-md.md)], strings are zero-based. The value of the `startIndex` parameter can range from zero to one less than the length of the string instance.  
  
> [!NOTE]
>  This method does not modify the value of the current instance. Instead, it returns a new string in which all characters from position `startIndex` to the end of the original string have been removed.  
  
   
  
## Examples  
 The following example demonstrates the <xref:System.String.Remove%2A> method. The next-to-last case removes all text starting from the specified index through the end of the string. The last case removes three characters starting from the specified index.  
  
 [!code-cs[string.remove#1](~/add/codesnippet/csharp/m-system.string.remove-s_0_1.cs)]
 [!code-vb[string.remove#1](~/add/codesnippet/visualbasic/m-system.string.remove-s_0_1.vb)]
 [!code-cpp[string.remove#1](~/add/codesnippet/cpp/m-system.string.remove-s_0_1.cpp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is less than zero.  
  
 -or-  
  
 <paramref name="startIndex" /> specifies a position that is not within this string.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">The zero-based position to begin deleting characters.</param>
        <param name="count">The number of characters to delete.</param>
        <summary>Returns a new string in which a specified number of characters in the current instance beginning at a specified position have been deleted.</summary>
        <returns>A new string that is equivalent to this instance except for the removed characters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In the [!INCLUDE[dnprdnshort](~/add/includes/dnprdnshort-md.md)], strings are zero-based. The value of the `startIndex` parameter can range from zero to one less than the length of the string instance.  
  
> [!NOTE]
>  This method does not modify the value of the current instance. Instead, it returns a new string in which the number of characters specified by the `count` parameter have been removed. The characters are removed at the position specified by `startIndex`.  
  
   
  
## Examples  
 The following example demonstrates how you can remove the middle name from a complete name.  
  
 [!code-cpp[stringremove#1](~/add/codesnippet/cpp/m-system.string.remove-s_1_1.cpp)]
 [!code-cs[stringremove#1](~/add/codesnippet/csharp/m-system.string.remove-s_1_1.cs)]
 [!code-vb[stringremove#1](~/add/codesnippet/visualbasic/m-system.string.remove-s_1_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Either <paramref name="startIndex" /> or <paramref name="count" /> is less than zero.  
  
 -or-  
  
 <paramref name="startIndex" /> plus <paramref name="count" /> specify a position outside this instance.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(char oldChar, char newChar) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">The Unicode character to be replaced.</param>
        <param name="newChar">The Unicode character to replace all occurrences of `oldChar`.</param>
        <summary>Returns a new string in which all occurrences of a specified Unicode character in this instance are replaced with another specified Unicode character.</summary>
        <returns>A string that is equivalent to this instance except that all instances of <paramref name="oldChar" /> are replaced with <paramref name="newChar" />. If <paramref name="oldChar" /> is not found in the current instance, the method returns the current instance unchanged.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method performs an ordinal (case-sensitive and culture-insensitive) search to find `oldChar`.  
  
> [!NOTE]
>  This method does not modify the value of the current instance. Instead, it returns a new string in which all occurrences of `oldChar` are replaced by `newChar`.  
  
 Because this method returns the modified string, you can chain together successive calls to the Replace method to perform multiple replacements on the original string. Method calls are executed from left to right. The following example provides an illustration.  
  
 [!code-cs[System.String.Replace#2](~/add/codesnippet/csharp/m-system.string.replace-_1_1.cs)]
 [!code-vb[System.String.Replace#2](~/add/codesnippet/visualbasic/m-system.string.replace-_1_1.vb)]  
  
   
  
## Examples  
 The following example creates a comma separated value list by substituting commas for the blanks between a series of numbers.  
  
 [!code-cpp[string.replace1#1](~/add/codesnippet/cpp/m-system.string.replace-_1_2.cpp)]
 [!code-cs[string.replace1#1](~/add/codesnippet/csharp/m-system.string.replace-_1_2.cs)]
 [!code-vb[string.replace1#1](~/add/codesnippet/visualbasic/m-system.string.replace-_1_2.vb)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">The string to be replaced.</param>
        <param name="newValue">The string to replace all occurrences of `oldValue`.</param>
        <summary>Returns a new string in which all occurrences of a specified string in the current instance are replaced with another specified string.</summary>
        <returns>A string that is equivalent to the current string except that all instances of <paramref name="oldValue" /> are replaced with <paramref name="newValue" />. If <paramref name="oldValue" /> is not found in the current instance, the method returns the current instance unchanged.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If `newValue` is `null`, all occurrences of `oldValue` are removed.  
  
> [!NOTE]
>  This method does not modify the value of the current instance. Instead, it returns a new string in which all occurrences of `oldValue` are replaced by `newValue`.  
  
 This method performs an ordinal (case-sensitive and culture-insensitive) search to find `oldValue`.  
  
 Because this method returns the modified string, you can chain together successive calls to the <xref:System.String.Replace%2A> method to perform multiple replacements on the original string. Method calls are executed from left to right. The following example provides an illustration.  
  
 [!code-cs[System.String.Replace#1](~/add/codesnippet/csharp/m-system.string.replace-_0_1.cs)]
 [!code-vb[System.String.Replace#1](~/add/codesnippet/visualbasic/m-system.string.replace-_0_1.vb)]  
  
   
  
## Examples  
 The following example demonstrates how you can use the <xref:System.String.Replace%2A> method to correct a spelling error.  
  
 [!code-cpp[stringreplace#1](~/add/codesnippet/cpp/m-system.string.replace-_0_2.cpp)]
 [!code-cs[stringreplace#1](~/add/codesnippet/csharp/m-system.string.replace-_0_2.cs)]
 [!code-vb[stringreplace#1](~/add/codesnippet/visualbasic/m-system.string.replace-_0_2.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="oldValue" /> is the empty string ("").</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</param>
        <summary>Splits a string into substrings that are based on the characters in an array.</summary>
        <returns>An array whose elements contain the substrings from this instance that are delimited by one or more characters in <paramref name="separator" />. For more information, see the Remarks section.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 When a string is delimited by a known set of characters, you can use the Split method to separate it into substrings. For other ways to extract substrings from a string, see the [Alternatives to String.Split](#Alternatives) section.  
  
## Return value details  
 Delimiter characters are not included in the elements of the returned array. For example, if the separator array includes the character "-" and the value of the current string instance is "aa-bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".  
  
 If this instance does not contain any of the characters in `separator`, the returned array consists of a single element that contains this instance.  
  
 Each element of `separator` defines a separate delimiter character. If two delimiters are adjacent, or a delimiter is found at the beginning or end of this instance, the corresponding element in the returned array contains <xref:System.String>. Here are some examples:  
  
|String value|Separator|Returned array|  
|------------------|---------------|--------------------|  
|"42, 12, 19"|new Char[] {',', ' '} (C#)<br /><br /> Char() = {","c, " "c}) (Visual Basic)|{"42", "", "12", "", "19"}|  
|"42..12..19"|new Char[] {'.'} (C#)<br /><br /> Char() = {"."c} (Visual Basic)|{"42", "", "12", "", "19"}|  
|"Banana"|new Char[] {'.'} (C#)<br /><br /> Char() = {"."c} (Visual Basic)|{"Banana"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|new Char[] {} (C#)<br /><br /> Char() = {} (Visual Basic)|{"Darb", "Smarba"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|null (C#)<br /><br /> Nothing (Visual Basic)|{"Darb", "Smarba"}|  
  
## The separator array  
 Each element of separator defines a separate delimiter that consists of a single character. If the `separator` argument is `null` or contains no characters, the method treats white-space characters as the delimiters. White-space characters are defined by the Unicode standard; they return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName> method.  
  
## String.Split(Char[]) and compiler overload resolution  
 Although the single parameter for this overload of <xref:System.String.Split%2A?displayProperty=fullName> is a character array, you can call it with a single character, as the following example shows.  
  
 [!code-cs[System.String.Split#12](~/add/codesnippet/csharp/m-system.string.split-sy_3_1.cs)]
 [!code-vb[System.String.Split#12](~/add/codesnippet/visualbasic/m-system.string.split-sy_3_1.vb)]  
  
 Because the `separator` parameter is decorated  with the <xref:System.ParamArrayAttribute> attribute, compilers will interpret a single character as a single-element character array. This is not the case for other <xref:System.String.Split%2A?displayProperty=fullName> overloads that include a `separator` parameter; you must explicitly pass these overloads a character array as the `separator` argument.  
  
## Comparison details  
 The Split method extracts the substrings in this string that are delimited by one or more of the characters in the `separator` array, and returns those substrings as elements of an array.  
  
 The Split method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules. For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=fullName> enumeration.  
  
<a name="Alternatives"></a>   
## Alternatives to String.Split  
 The Split method is not always the best way to break a delimited string into substrings. If you don't want to extract all of the substrings of a delimited string, or if you want to parse a string based on a pattern instead of a set of delimiter characters, consider the following alternatives.  
  
### Regular expressions  
 If your strings conform to a fixed pattern, you can use a regular expression to extract and handle their elements. For example, if strings take the form "*number* *operand* *number*" you can use a [regular expression](../Topic/.NET%20Framework%20Regular%20Expressions.md) to extract and handle the string's elements. Here's an example:  
  
 [!code-cs[System.String.Split#8](~/add/codesnippet/csharp/m-system.string.split-sy_3_2.cs)]
 [!code-vb[System.String.Split#8](~/add/codesnippet/visualbasic/m-system.string.split-sy_3_2.vb)]  
  
 The regular expression pattern `(\d+)\s+([-+*/])\s+(\d+)` is defined like this:  
  
|Pattern|Description|  
|-------------|-----------------|  
|`(\d+)`|Match one or more decimal digits. This is the first capturing group.|  
|`\s+`|Match one or more whitespace characters.|  
|`([-+*/])`|Match an arithmetic operator sign (+, -, *, or /). This is the second capturing group.|  
|`\s+`|Match one or more whitespace characters.|  
|`(\d+)`|Match one or more decimal digits. This is the third capturing group.|  
  
 You can also use a regular expression to extract substrings from a string based on a pattern rather than a fixed set of characters. This is a common scenario when either of these conditions occurs:  
  
-   One or more of the delimiter characters does not always serve as a delimiter in the <xref:System.String> instance.  
  
-   The sequence and number of delimiter characters is variable or unknown.  
  
 For example, the Split method cannot be used to split the following string, because the number of `\n` (in C#) or `vbCrLf` (in Visual Basic) characters is variable, and they do not always serve as delimiters.  
  
```  
  
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
  
```  
  
 A regular expression can split this string easily, as the following example shows.  
  
 [!code-cs[System.String.Split#9](~/add/codesnippet/csharp/m-system.string.split-sy_3_3.cs)]
 [!code-vb[System.String.Split#9](~/add/codesnippet/visualbasic/m-system.string.split-sy_3_3.vb)]  
  
 The regular expression pattern `\[([^\[\]]+)\]` is defined like this:  
  
|Pattern|Description|  
|-------------|-----------------|  
|`\[`|Match an opening bracket.|  
|`([^\[\]]+)`|Match any character that is not an opening or a closing bracket one or more times. This is the first capturing group.|  
|`\]`|Match a closing bracket.|  
  
 The <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=fullName> method is almost identical to Split, except that it splits a string based on a regular expression pattern instead of a fixed character set. For example, the following example uses the <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=fullName>method to split a string that contains substrings delimited by various combinations of hyphens and other characters.  
  
 [!code-vb[System.String.Split#10](~/add/codesnippet/visualbasic/m-system.string.split-sy_3_4.vb)]
 [!code-cs[System.String.Split#10](~/add/codesnippet/csharp/m-system.string.split-sy_3_4.cs)]  
  
 The regular expression pattern `\s-\s?[+*]?\s?-\s` is defined like this:  
  
|Pattern|Description|  
|-------------|-----------------|  
|`\s-`|Match a whitespace character followed by a hyphen.|  
|`\s?`|Match zero or one whitespace character.|  
|`[+*]?`|Match zero or one occurrence of either the + or * character.|  
|`\s?`|Match zero or one whitespace character.|  
|`-\s`|Match a hyphen followed by a whitespace character.|  
  
### Search methods and the Substring method  
 If you aren't interested in all of the substrings in a string, you might prefer to work with one of the string comparison methods that returns the index at which the match begins. You can then call the <xref:System.String.Substring%2A> method to extract the substring that you want. The string comparison methods include:  
  
-   <xref:System.String.IndexOf%2A>, which returns the zero-based index of the first occurrence of a character or string in a string instance.  
  
-   <xref:System.String.IndexOfAny%2A>, which returns the zero-based index in the current string instance of the first occurrence of any character in a character array.  
  
-   <xref:System.String.LastIndexOf%2A>, which returns the zero-based index of the last occurrence of a character or string in a string instance.  
  
-   <xref:System.String.LastIndexOfAny%2A>, which returns a zero-based index in the current string instance of the last occurrence of any character in a character array.  
  
 The following example uses the <xref:System.String.IndexOf%2A> method to find the periods in a string. It then uses the <xref:System.String.Substring%2A> method to return full sentences.  
  
 [!code-cs[System.String.Split#11](~/add/codesnippet/csharp/m-system.string.split-sy_3_5.cs)]
 [!code-vb[System.String.Split#11](~/add/codesnippet/visualbasic/m-system.string.split-sy_3_5.vb)]  
  
## Performance Considerations  
 The<xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element. If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method. You also have the option of using the <xref:System.String.Compare%2A> method to locate a substring within a string.  
  
 To split a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string. To split a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string. Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.  
  
 In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call. This significantly reduces the additional overhead of each method call.  
  
   
  
## Examples  
 The following example demonstrates how to extract individual words from a block of text by treating white space and punctuation marks as delimiters. The character array passed to the `separator` parameter of the Split method consists of a space character and a tab character, together with some common punctuation symbols.  
  
 [!code-cs[System.String.Split#2](~/add/codesnippet/csharp/m-system.string.split-sy_3_6.cs)]
 [!code-vb[System.String.Split#2](~/add/codesnippet/visualbasic/m-system.string.split-sy_3_6.vb)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</param>
        <param name="count">The maximum number of substrings to return.</param>
        <summary>Splits a string into a maximum number of substrings based on the characters in an array. You also specify the maximum number of substrings to return.</summary>
        <returns>An array whose elements contain the substrings in this instance that are delimited by one or more characters in <paramref name="separator" />. For more information, see the Remarks section.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Delimiter characters are not included in the elements of the returned array.  
  
 If this instance does not contain any of the characters in `separator`, the returned array consists of a single element that contains this instance. If `count` is zero, an empty array is returned.  
  
 If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters. White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName> method.  
  
 Each element of `separator` defines a separate delimiter character. If two delimiters are adjacent, or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty>.  
  
 If there are more than `count` substrings in this instance, the first `count` minus 1 substrings are returned in the first `count` minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.  
  
 If `count` is greater than the number of substrings, the available substrings are returned and no exception is thrown.  
  
 The following table provides examples.  
  
|String value|Separator|Count|Returned array|  
|------------------|---------------|-----------|--------------------|  
|"42, 12, 19"|new Char[] {',', ' '} (C#)<br /><br /> Char() = {","c, " "c} (Visual Basic)|2|{"42", " 12, 19"}|  
|"42..12..19"|new Char[] {'.'} (C#)<br /><br /> Char() = {"."c} (Visual Basic)|4|{"42", "", "12", ".19"}|  
|"Banana"|new Char[] {'.'} (C#)<br /><br /> Char() = {"."c} (Visual Basic)|2|{"Banana"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|new Char[] {} (C#)<br /><br /> Char() = {} (Visual Basic)|1|{"Darb\nSmarba"} (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|new Char[] null (C#)<br /><br /> Char() = Nothing|2|{"Darb", "Smarba"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|new Char[] null (C#)<br /><br /> Char() = Nothing|100|{"Darb", "Smarba"}|  
  
## Performance Considerations  
 The<xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element. If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.  
  
 If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string. If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string. Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.  
  
 In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call. This significantly reduces the additional overhead of each method call.  
  
   
  
## Examples  
 The following example demonstrates how `count` affects the number of strings returned by <xref:System.String.Split%2A>.  
  
 [!code-cs[StringSplit2#10](~/add/codesnippet/csharp/m-system.string.split-sy_2_1.cs)]
 [!code-vb[StringSplit2#10](~/add/codesnippet/visualbasic/m-system.string.split-sy_2_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> is negative.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</param>
        <param name="options">
          <see cref="T:System.StringSplitOptions" /> to omit empty array elements from the array returned; or <see cref="T:System.StringSplitOptions" /> to include empty array elements in the array returned.</param>
        <summary>Splits a string into substrings based on the characters in an array. You can specify whether the substrings include empty array elements.</summary>
        <returns>An array whose elements contain the substrings in this string that are delimited by one or more characters in <paramref name="separator" />. For more information, see the Remarks section.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## Return value details  
 Delimiter characters (the characters in the `separator` array) are not included in the elements of the returned array. For example, if the `separator` array includes the character "-" and the value of the current string instance is "aa-bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".  
  
 If this instance does not contain any of the characters in `separator`, the returned array consists of a single element that contains this instance.  
  
 If the `options` parameter is <xref:System.StringSplitOptions> and the length of this instance is zero, the method returns an empty array.  
  
 Each element of `separator` defines a separate delimiter that consists of a single character. If the `options` argument is <xref:System.StringSplitOptions>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String?displayProperty=fullName>. For example, if `separator` includes  two elements, "-" and "_", the value of the string instance is "-_aa-\_", and the value of   the `options` argument is <xref:System.StringSplitOptions>, the method returns a string array with the following five elements:  
  
1.  <xref:System.String.Empty?displayProperty=fullName>, which represents the empty string that precedes the "-" character at index 0.  
  
2.  <xref:System.String.Empty?displayProperty=fullName>, which represents the empty string between the "-" character at index 0 and the "_" character at index 1.  
  
3.  "aa",  
  
4.  <xref:System.String.Empty?displayProperty=fullName>, which represents the empty string that follows the "_" character at index 4.  
  
5.  <xref:System.String.Empty?displayProperty=fullName>, which represents the empty string that follows the "-" character at index 5.  
  
## The separator array  
 If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters. White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName> method.  
  
 If the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails. To unambiguously identify the called method, your code must indicate the type of the `null`. The following example shows several ways to unambiguously identify this overload.  
  
 [!code-vb[System.String.Split#5](~/add/codesnippet/visualbasic/m-system.string.split-sy_5_1.vb)]
 [!code-cs[System.String.Split#5](~/add/codesnippet/csharp/m-system.string.split-sy_5_1.cs)]  
  
## Comparison details  
 The Split method extracts the substrings in this string that are delimited by one or more of the characters in the `separator` parameter, and returns those substrings as elements of an array.  
  
 The <xref:System.String.Split%2A> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules. For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=fullName> enumeration.  
  
## Performance Considerations  
 The<xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element. If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.  
  
 If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string. If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string. Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.  
  
 In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call. This significantly reduces the additional overhead of each method call.  
  
   
  
## Examples  
 The following example uses the <xref:System.StringSplitOptions> enumeration to include or exclude substrings generated by the <xref:System.String.Split%2A> method.  
  
 [!code-cs[string.split3#1](~/add/codesnippet/csharp/m-system.string.split-sy_5_2.cs)]
 [!code-vb[string.split3#1](~/add/codesnippet/visualbasic/m-system.string.split-sy_5_2.vb)]
 [!code-cpp[string.split3#1](~/add/codesnippet/cpp/m-system.string.split-sy_5_2.cpp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> is not one of the <see cref="T:System.StringSplitOptions" /> values.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">A string array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</param>
        <param name="options">
          <see cref="T:System.StringSplitOptions" /> to omit empty array elements from the array returned; or <see cref="T:System.StringSplitOptions" /> to include empty array elements in the array returned.</param>
        <summary>Splits a string into substrings based on the strings in an array. You can specify whether the substrings include empty array elements.</summary>
        <returns>An array whose elements contain the substrings in this string that are delimited by one or more strings in <paramref name="separator" />. For more information, see the Remarks section.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 When a string is delimited by a known set of strings, you can use the Split method to separate it into substrings.  
  
## Return value details  
 Delimiter strings are not included in the elements of the returned array. For example, if the `separator` array includes the string "--" and the value of the current string instance is "aa--bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".  
  
 If this instance does not contain any of the strings in `separator`, the returned array consists of a single element that contains this instance.  
  
 If the `options` parameter is <xref:System.StringSplitOptions> and the length of this instance is zero, the method returns an empty array.  
  
 Each element of `separator` defines a separate delimiter that consists of one or more characters. If the `options` argument is <xref:System.StringSplitOptions>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String?displayProperty=fullName>. For example, if `separator` includes  two elements, "-" and "_", the value of the string instance is "-_aa-\_", and the value of   the `options` argument is <xref:System.StringSplitOptions>, the method returns a sting array with the following five elements:  
  
1.  <xref:System.String.Empty?displayProperty=fullName>, which represents the empty string that precedes the "-" substring at index 0.  
  
2.  <xref:System.String.Empty?displayProperty=fullName>, which represents the empty string between the "-" substring at index 0 and the "_" substring at index 1.  
  
3.  "aa",  
  
4.  <xref:System.String.Empty?displayProperty=fullName>, which represents the empty string that follows the "_" substring at index 4.  
  
5.  <xref:System.String.Empty?displayProperty=fullName>, which represents the empty string that follows the "-" substring at index 5.  
  
## The separator array  
 If any of the elements in `separator` consists of multiple characters, the entire substring is considered a delimiter. For example, if one of the elements in `separator` is "10", attempting to split the string "This10is10a10string." returns the following four-element array: { "This", "is", "a", "string." }.  
  
 If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters. White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName> method.  
  
 If the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails. To unambiguously identify the called method, your code must indicate the type of the `null`. The following example shows several ways to unambiguously identify this overload.  
  
 [!code-vb[System.String.Split#6](~/add/codesnippet/visualbasic/m-system.string.split-sy_4_1.vb)]
 [!code-cs[System.String.Split#6](~/add/codesnippet/csharp/m-system.string.split-sy_4_1.cs)]  
  
## Comparison details  
 The Split method extracts the substrings in this string that are delimited by one or more of the strings in the `separator` parameter, and returns those substrings as elements of an array.  
  
 The <xref:System.String.Split%2A> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules. For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=fullName> enumeration.  
  
 The Split method ignores any element of `separator` whose value is `null` or the empty string ("").  
  
 To avoid ambiguous results when strings in `separator` have characters in common, the <xref:System.String.Split%2A> operation proceeds from the beginning to the end of the value of the instance, and matches the first element in `separator` that is equal to a delimiter in the instance. The order in which substrings are encountered in the instance takes precedence over the order of elements in `separator`.  
  
 For example, consider an instance whose value is "abcdef". If the first element in `separator` was "ef" and the second element was "bcde", the result of the split operation would be a string array that contains two elements, "a" and "f". This is because the substring in the instance, "bcde", is encountered and matches an element in `separator` before the substring "f" is encountered.  
  
 However, if the first element of `separator` was "bcd" and the second element was "bc", the result of the split operation would be a string array that contains two elements, "a" and "ef". This is because "bcd" is the first delimiter in `separator` that matches a delimiter in the instance. If the order of the separators was reversed so the first element was "bc" and the second element was "bcd", the result would be a string array that contains two elements,  "a" and "def".  
  
## Performance considerations  
 The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element. If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.  
  
 If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string. If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string. Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.  
  
 In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call. This significantly reduces the additional overhead of each method call.  
  
   
  
## Examples  
 The following example illustrates the difference in the arrays returned by calling a string's Split method with its `options` parameter equal to <xref:System.StringSplitOptions?displayProperty=fullName> and <xref:System.StringSplitOptions?displayProperty=fullName>.  
  
 [!code-cs[System.String.Split#1](~/add/codesnippet/csharp/m-system.string.split-sy_4_2.cs)]
 [!code-vb[System.String.Split#1](~/add/codesnippet/visualbasic/m-system.string.split-sy_4_2.vb)]  
  
 The following example defines an array of separators that include punctuation and white-space characters. Passing this array along with a value of <xref:System.StringSplitOptions?displayProperty=fullName> to the Split method returns an array that consists of the individual words from the string.  
  
 [!code-vb[System.String.Split#7](~/add/codesnippet/visualbasic/m-system.string.split-sy_4_3.vb)]
 [!code-cs[System.String.Split#7](~/add/codesnippet/csharp/m-system.string.split-sy_4_3.cs)]  
  
 Note that the method is called with the `options` argument set to <xref:System.StringSplitOptions?displayProperty=fullName>. This prevents the returned array from including<xref:System.String.Empty?displayProperty=fullName> values that represent empty substring matches between punctuation marks and white-space characters.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> is not one of the <see cref="T:System.StringSplitOptions" /> values.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</param>
        <param name="count">The maximum number of substrings to return.</param>
        <param name="options">
          <see cref="T:System.StringSplitOptions" /> to omit empty array elements from the array returned; or <see cref="T:System.StringSplitOptions" /> to include empty array elements in the array returned.</param>
        <summary>Splits a string into a maximum number of substrings based on the characters in an array.</summary>
        <returns>An array whose elements contain the substrings in this string that are delimited by one or more characters in <paramref name="separator" />. For more information, see the Remarks section.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Delimiter characters are not included in the elements of the returned array.  
  
 If this instance does not contain any of the characters in `separator`, or the `count` parameter is 1, the returned array consists of a single element that contains this instance. If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters. White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName> method. However, if the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails. To unambiguously identify the called method, your code must indicate the type of the null. The following example shows several ways to unambiguously identify this overload.  
  
 [!code-vb[System.String.Split#3](~/add/codesnippet/visualbasic/m-system.string.split-sy_0_1.vb)]
 [!code-cs[System.String.Split#3](~/add/codesnippet/csharp/m-system.string.split-sy_0_1.cs)]  
  
 If the `count` parameter is zero, or the `options` parameter is <xref:System.StringSplitOptions> and the length of this instance is zero, an empty array is returned.  
  
 Each element of `separator` defines a separate delimiter character. If the `options` parameter is <xref:System.StringSplitOptions>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty>.  
  
 If there are more than `count` substrings in this instance, the first `count` minus 1 substrings are returned in the first `count` minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.  
  
 If `count` is greater than the number of substrings, the available substrings are returned and no exception is thrown.  
  
## Performance Considerations  
 The<xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element. If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.  
  
 If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string. If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string. Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.  
  
 In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call. This significantly reduces the additional overhead of each method call.  
  
   
  
## Examples  
 The following example uses the <xref:System.StringSplitOptions> enumeration to include or exclude substrings generated by the <xref:System.String.Split%2A> method.  
  
 [!code-cs[string.split3#1](~/add/codesnippet/csharp/m-system.string.split-sy_0_2.cs)]
 [!code-vb[string.split3#1](~/add/codesnippet/visualbasic/m-system.string.split-sy_0_2.vb)]
 [!code-cpp[string.split3#1](~/add/codesnippet/cpp/m-system.string.split-sy_0_2.cpp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> is negative.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> is not one of the <see cref="T:System.StringSplitOptions" /> values.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">A string array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</param>
        <param name="count">The maximum number of substrings to return.</param>
        <param name="options">
          <see cref="T:System.StringSplitOptions" /> to omit empty array elements from the array returned; or <see cref="T:System.StringSplitOptions" /> to include empty array elements in the array returned.</param>
        <summary>Splits a string into a maximum number of substrings based on the strings in an array. You can specify whether the substrings include empty array elements.</summary>
        <returns>An array whose elements contain the substrings in this string that are delimited by one or more strings in <paramref name="separator" />. For more information, see the Remarks section.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## Return value details  
 Delimiter strings are not included in the elements of the returned array.  
  
 If this instance does not contain any of the strings in `separator`, or the `count` parameter is 1, the returned array consists of a single element that contains this instance. If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters. White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName> method. However, if the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails. To unambiguously identify the called method, your code must indicate the type of the `null`. The following example shows several ways to unambiguously identify this overload.  
  
 [!code-vb[System.String.Split#4](~/add/codesnippet/visualbasic/m-system.string.split-sy_1_1.vb)]
 [!code-cs[System.String.Split#4](~/add/codesnippet/csharp/m-system.string.split-sy_1_1.cs)]  
  
 If the `count` parameter is zero, or the `options` parameter is <xref:System.StringSplitOptions> and the length of this instance is zero, an empty array is returned.  
  
 Each element of `separator` defines a separate delimiter that consists of one or more characters. If the `options` parameter is <xref:System.StringSplitOptions>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty>.  
  
 If there are more than `count` substrings in this instance, the first `count` minus 1 substrings are returned in the first `count` minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.  
  
 If `count` is greater than the number of substrings, the available substrings are returned and no exception is thrown.  
  
## The separator array  
 If any of the elements in `separator` consists of multiple characters, the entire substring is considered a delimiter. For example, if one of the elements in `separator` is "10", attempting to split the string "This10is10a10string." returns this four-element array: { "This", "is", "a", "string." }.  
  
## Comparison details  
 The Split method extracts the substrings in this string that are delimited by one or more of the strings in the `separator` parameter, and returns those substrings as elements of an array.  
  
 The <xref:System.String.Split%2A> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules. For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=fullName> enumeration.  
  
 The Split method ignores any element of `separator` whose value is `null` or the empty string ("").  
  
 To avoid ambiguous results when strings in `separator` have characters in common, the <xref:System.String.Split%2A> method proceeds from the beginning to the end of the value of the instance, and matches the first element in `separator` that is equal to a delimiter in the instance. The order in which substrings are encountered in the instance takes precedence over the order of elements in `separator`.  
  
 For example, consider an instance whose value is "abcdef". If the first element in `separator` was "ef" and the second element was "bcde", the result of the split operation would be "a" and "f". This is because the substring in the instance, "bcde", is encountered and matches an element in `separator` before the substring "f" is encountered.  
  
 However, if the first element of `separator` was "bcd" and the second element was "bc", the result of the split operation would be "a" and "ef". This is because "bcd" is the first delimiter in `separator` that matches a delimiter in the instance. If the order of the separators was reversed so the first element was "bc" and the second element was "bcd", the result would be "a" and "def".  
  
## Performance considerations  
 The<xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element. If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.  
  
 If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string. If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string. Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.  
  
 In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call. This significantly reduces the additional overhead of each method call.  
  
   
  
## Examples  
 The following example uses the <xref:System.StringSplitOptions> enumeration to include or exclude substrings generated by the <xref:System.String.Split%2A> method.  
  
 [!code-cs[string.split3#1](~/add/codesnippet/csharp/m-system.string.split-sy_1_2.cs)]
 [!code-vb[string.split3#1](~/add/codesnippet/visualbasic/m-system.string.split-sy_1_2.vb)]
 [!code-cpp[string.split3#1](~/add/codesnippet/cpp/m-system.string.split-sy_1_2.cpp)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> is negative.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> is not one of the <see cref="T:System.StringSplitOptions" /> values.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">The string to compare.</param>
        <summary>Determines whether the beginning of this string instance matches the specified string.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> matches the beginning of this string; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method compares `value` to the substring at the beginning of this instance that is the same length as `value`, and returns an indication whether they are equal. To be equal, `value` must be an empty string (<xref:System.String?displayProperty=fullName>), must be a reference to this same instance, or must match the beginning of this instance.  
  
 This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.  
  
   
  
## Examples  
 The following example defines a `StripStartTags` method that uses the StartsWith method to remove HTML start tags from the beginning of a string. Note that the `StripStartTags` method is called recursively to ensure that multiple HTML start tags at the beginning of the line are removed. The example does not remove HTML tags embedded in a string.  
  
 [!code-cpp[stringstartswith#1](~/add/codesnippet/cpp/m-system.string.startswi_1_1.cpp)]
 [!code-vb[stringstartswith#1](~/add/codesnippet/visualbasic/m-system.string.startswi_1_1.vb)]
 [!code-cs[stringstartswith#1](~/add/codesnippet/csharp/m-system.string.startswi_1_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">The string to compare.</param>
        <param name="comparisonType">One of the enumeration values that determines how this string and `value` are compared.</param>
        <summary>Determines whether the beginning of this string instance matches the specified string when compared using the specified comparison option.</summary>
        <returns>
          <see langword="true" /> if this instance begins with <paramref name="value" />; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The StartsWith method compares the `value` parameter to the substring at the beginning of this string and returns a value that indicates whether they are equal. To be equal, `value` must be a reference to this same string, must be the empty string (""), or must match the beginning of this string. The type of comparison performed by the StartsWith method depends on the value of the `comparisonType` parameter. The comparison can use the conventions of the current culture (<xref:System.StringComparison?displayProperty=fullName> and <xref:System.StringComparison?displayProperty=fullName>) or the invariant culture (<xref:System.StringComparison?displayProperty=fullName> and <xref:System.StringComparison?displayProperty=fullName>), or it can consist of a character-by-character comparison of code points (<xref:System.StringComparison?displayProperty=fullName> or <xref:System.StringComparison?displayProperty=fullName>). The comparison can also be case-sensitive (<xref:System.StringComparison?displayProperty=fullName>, <xref:System.StringComparison?displayProperty=fullName>, or <xref:System.StringComparison?displayProperty=fullName>), or it can ignore case (<xref:System.StringComparison?displayProperty=fullName>, <xref:System.StringComparison?displayProperty=fullName>, <xref:System.StringComparison?displayProperty=fullName>).  
  
   
  
## Examples  
 The following example searches for the string "the" at the beginning of a longer string that begins with the word "The". As the output from the example shows, a call to the StartsWith method that performs a culture-insensitive but case-sensitive comparison fails to match the string, while a call that performs a culture- and case-insensitive comparison matches the string.  
  
 [!code-cs[System.String.StartsWith#2](~/add/codesnippet/csharp/m-system.string.startswi_0_1.cs)]
 [!code-cpp[System.String.StartsWith#2](~/add/codesnippet/cpp/m-system.string.startswi_0_1.cpp)]
 [!code-vb[System.String.StartsWith#2](~/add/codesnippet/visualbasic/m-system.string.startswi_0_1.vb)]  
  
 The following example determines whether a string starts with a particular substring. It initializes a two-dimensional string array. The first element in the second dimension contains a string, and the second element contains the string to search for at the start of the first string. The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed. Note that when the string instance contains a ligature, culture-sensitive comparisons with its consecutive characters successfully match.  
  
 [!code-cs[System.String.StartsWith#1](~/add/codesnippet/csharp/m-system.string.startswi_0_2.cs)]
 [!code-cpp[System.String.StartsWith#1](~/add/codesnippet/cpp/m-system.string.startswi_0_2.cpp)]
 [!code-vb[System.String.StartsWith#1](~/add/codesnippet/visualbasic/m-system.string.startswi_0_2.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">The string to compare.</param>
        <param name="ignoreCase">
          <see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</param>
        <param name="culture">Cultural information that determines how this string and `value` are compared. If `culture` is <see langword="null" />, the current culture is used.</param>
        <summary>Determines whether the beginning of this string instance matches the specified string when compared using the specified culture.</summary>
        <returns>
          <see langword="true" /> if the <paramref name="value" /> parameter matches the beginning of this string; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method compares the `value` parameter to the substring at the beginning of this string that is the same length as `value`, and returns a value that indicates whether they are equal. To be equal, `value` must be an empty string (<xref:System.String?displayProperty=fullName>), must be a reference to this same instance, or must match the beginning of this instance.  
  
 This method performs a comparison using the specified casing and culture.  
  
   
  
## Examples  
 The following example determines whether a string occurs at the beginning of another string. The StartsWith method is called several times using case sensitivity, case insensitivity, and different cultures that influence the results of the search.  
  
 [!code-vb[system.string.StartsWithCI#1](~/add/codesnippet/visualbasic/372b987b-05c6-4c5f-99d3-_1.vb)]
 [!code-cs[system.string.StartsWithCI#1](~/add/codesnippet/csharp/372b987b-05c6-4c5f-99d3-_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">The zero-based starting character position of a substring in this instance.</param>
        <summary>Retrieves a substring from this instance. The substring starts at a specified character position and continues to the end of the string.</summary>
        <returns>A string that is equivalent to the substring that begins at <paramref name="startIndex" /> in this instance, or <see cref="T:System.String" /> if <paramref name="startIndex" /> is equal to the length of this instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 You call the Substring method to extract a substring from a string that begins at a specified character position and ends at the end of the string. The starting character position is a zero-based; in other words, the first character in the string is at index 0, not index 1. To extract a substring that begins at a specified character position and ends before to the end of the string, call the <xref:System.String.Substring%2A> method.  
  
> [!NOTE]
>  This method does not modify the value of the current instance. Instead, it returns a new string that begins at the `startIndex` position in the current string.  
  
 To extract a substring that begins with a particular character or character sequence, call a method such as  <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> to get the value of `startIndex`. The second example illustrates this; it extracts a key value that begins one character position after the "=" character.  
  
 If `startIndex` is equal to zero, the method returns the original string unchanged.  
  
   
  
## Examples  
 The following example demonstrates obtaining a substring from a string.  
  
 [!code-cpp[System.String.Substring#10](~/add/codesnippet/cpp/m-system.string.substrin_1_1.cpp)]
 [!code-vb[System.String.Substring#10](~/add/codesnippet/visualbasic/m-system.string.substrin_1_1.vb)]
 [!code-cs[System.String.Substring#10](~/add/codesnippet/csharp/m-system.string.substrin_1_1.cs)]  
  
 The following example uses the <xref:System.String.Substring%2A> method to separate key/value pairs that are delimited by an equals ("=") character.  
  
 [!code-cs[System.String.Substring#1](~/add/codesnippet/csharp/m-system.string.substrin_1_2.cs)]
 [!code-vb[System.String.Substring#1](~/add/codesnippet/visualbasic/m-system.string.substrin_1_2.vb)]  
  
 The <xref:System.String.IndexOf%2A> method is used to get the position of the equals character in the string.. The call to the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method extracts the key name., which starts from the first character in the string and extends for the number of characters returned by the call to the    <xref:System.String.IndexOf%2A> method. The call to the Substring method then extracts the value assigned to the key. It starts at one character position beyond the equals character and extends to the end of the string.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> is less than zero or greater than the length of this instance.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">The zero-based starting character position of a substring in this instance.</param>
        <param name="length">The number of characters in the substring.</param>
        <summary>Retrieves a substring from this instance. The substring starts at a specified character position and has a specified length.</summary>
        <returns>A string that is equivalent to the substring of length <paramref name="length" /> that begins at <paramref name="startIndex" /> in this instance, or <see cref="T:System.String" /> if <paramref name="startIndex" /> is equal to the length of this instance and <paramref name="length" /> is zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 You call the Substring method to extract a substring from a string that begins at a specified character position and ends before the end of the string. The starting character position is a zero-based; in other words, the first character in the string is at index 0, not index 1. To extract a substring that begins at a specified character position and continues to the end of the string, call the <xref:System.String.Substring%28System.Int32%29> method.  
  
> [!NOTE]
>  This method does not modify the value of the current instance. Instead, it returns a new string with `length` characters starting from the `startIndex` position in the current string.  
  
 The `length` parameter represents the total number of characters to extract from the current string instance. This includes the starting character found at index  `startIndex`.  In other words, the Substring method attempts to extract characters from index `startIndex` to index `startIndex` + `length` - 1.  
  
 To extract a substring that begins with a particular character or character sequence, call a method such as  <xref:System.String.IndexOf%2A> or <xref:System.String.LastIndexOf%2A> to get the value of `startIndex`.  
  
 If the substring extends from `startIndex` to a specified character sequence, you can call a method such as  <xref:System.String.IndexOf%2A> or <xref:System.String.LastIndexOf%2A> to get the index of the ending character or character sequence.  You can then convert that value to an index position in the string as follows:  
  
-   If you've searched for a single character that is to mark the end of the substring, the `length` parameter equals  `endIndex` - `startIndex` + 1, where `endIndex` is the return value of the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> method. The following example extracts a continuous block of "b" characters from a string.  
  
     [!code-vb[System.String.Substring#2](~/add/codesnippet/visualbasic/m-system.string.substrin_0_1.vb)]
     [!code-cs[System.String.Substring#2](~/add/codesnippet/csharp/m-system.string.substrin_0_1.cs)]  
  
-   If you've searched for multiple characters that are to mark the end of the substring, the `length` parameter equals  `endIndex` + `endMatchLength` - `startIndex`, where `endIndex` is the return value of the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> method., and `endMatchLength` is the length of the character sequence that marks the end of the substring. The following example extracts a block of text that contains an XML `<definition>` element.  
  
     [!code-vb[System.String.Substring#3](~/add/codesnippet/visualbasic/m-system.string.substrin_0_2.vb)]
     [!code-cs[System.String.Substring#3](~/add/codesnippet/csharp/m-system.string.substrin_0_2.cs)]  
  
-   If the character or character sequence is not included in the end of the substring, the `length` parameter equals `endIndex` - `startIndex`, where `endIndex` is the return value of the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> method.  
  
 If `startIndex` is equal to zero and  equals the length of the current string, the method returns the original string unchanged.  
  
   
  
## Examples  
 The following example illustrates a simple call to the Substring method that extracts two characters from a string starting at the sixth character position (that is, at index five).  
  
 [!code-vb[System.String.Substring#4](~/add/codesnippet/visualbasic/m-system.string.substrin_0_3.vb)]
 [!code-cs[System.String.Substring#4](~/add/codesnippet/csharp/m-system.string.substrin_0_3.cs)]  
  
 The following example uses the Substring method in the following three cases to isolate substrings within a string. In two cases the substrings are used in comparisons, and in the third case an exception is thrown because invalid parameters are specified.  
  
-   It extracts the single character and the third position in the string (at index 2) and compares it with a "c". This comparison returns `true`.  
  
-   It extracts zero characters starting at the fourth position in the string (at index 3) and passes it to the <xref:System.String.IsNullOrEmpty%2A> method. This returns true because the call to the Substring method returns <xref:System.String.Empty?displayProperty=fullName>.  
  
-   It attempts to extract one character starting at the fourth position in the string. Because there is no character at that position, the method call throws an <xref:System.ArgumentOutOfRangeException> exception.  
  
 [!code-vb[Classic String.Substring1 Example#1](~/add/codesnippet/visualbasic/m-system.string.substrin_0_4.vb)]
 [!code-cs[Classic String.Substring1 Example#1](~/add/codesnippet/csharp/m-system.string.substrin_0_4.cs)]  
  
 The following example uses the <xref:System.String.Substring%2A> method to separate key/value pairs that are delimited by an equals ("=") character.  
  
 [!code-cs[System.String.Substring#1](~/add/codesnippet/csharp/m-system.string.substrin_0_5.cs)]
 [!code-vb[System.String.Substring#1](~/add/codesnippet/visualbasic/m-system.string.substrin_0_5.vb)]  
  
 The <xref:System.String.IndexOf%2A> method is used to get the position of the equals character in the string.. The call to the Substring method extracts the key name., which starts from the first character in the string and extends for the number of characters returned by the call to the    <xref:System.String.IndexOf%2A> method. The call to the <xref:System.String.Substring%28System.Int32%29> method then extracts the value assigned to the key. It starts at one character position beyond the equals character and extends to the end of the string.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> plus <paramref name="length" /> indicates a position not within this instance.  
  
 -or-  
  
 <paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Char&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;char&gt; IEnumerable&lt;char&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;char&gt; System.Collections.Generic.IEnumerable&lt;System.Char&gt;.GetEnumerator() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an enumerator that iterates through the current <see cref="T:System.String" /> object.</summary>
        <returns>An enumerator that can be used to iterate through the current string.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This member is an explicit interface member implementation. It can be used only when the <xref:System.String> instance is cast to an <xref:System.Collections.IEnumerable> interface. For more information, see the <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=fullName> method.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>For a description of this member, see &lt;xref:System.IConvertible.ToBoolean%2A&gt;.</summary>
        <returns>
          <see langword="true" /> if the value of the current string is <see cref="T:System.Boolean" />; <see langword="false" /> if the value of the current string is <see cref="T:System.Boolean" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This member is an explicit interface member implementation. It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToBoolean%28System.String%29?displayProperty=fullName> method.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">The value of the current string is not <see cref="T:System.Boolean" /> or <see cref="T:System.Boolean" />.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">An object that provides culture-specific formatting information.</param>
        <summary>For a description of this member, see &lt;xref:System.IConvertible.ToByte%2A&gt;.</summary>
        <returns>The converted value of the current <see cref="T:System.String" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This member is an explicit interface member implementation. It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> method.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">The value of the current <see cref="T:System.String" /> object cannot be parsed.</exception>
        <exception cref="T:System.OverflowException">The value of the current <see cref="T:System.String" /> object is a number greater than <see cref="F:System.Byte.MaxValue" /> or less than <see cref="F:System.Byte.MinValue" />.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">An object that provides culture-specific formatting information.</param>
        <summary>For a description of this member, see &lt;xref:System.IConvertible.ToChar%2A&gt;.</summary>
        <returns>The character at index 0 in the current <see cref="T:System.String" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This member is an explicit interface member implementation. It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> method.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">An object that provides culture-specific formatting information.</param>
        <summary>For a description of this member, see &lt;xref:System.IConvertible.ToDateTime%2A&gt;.</summary>
        <returns>The converted value of the current <see cref="T:System.String" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This member is an explicit interface member implementation. It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> method.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">An object that provides culture-specific formatting information.</param>
        <summary>For a description of this member, see &lt;xref:System.IConvertible.ToDecimal%2A&gt;.</summary>
        <returns>The converted value of the current <see cref="T:System.String" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This member is an explicit interface member implementation. It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> method.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">The value of the current <see cref="T:System.String" /> object cannot be parsed.</exception>
        <exception cref="T:System.OverflowException">The value of the current <see cref="T:System.String" /> object is a number less than <see cref="F:System.Decimal.MinValue" /> or than <see cref="F:System.Decimal.MaxValue" /> greater.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">An object that provides culture-specific formatting information.</param>
        <summary>For a description of this member, see &lt;xref:System.IConvertible.ToDouble%2A&gt;.</summary>
        <returns>The converted value of the current <see cref="T:System.String" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This member is an explicit interface member implementation. It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> method.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">The value of the current <see cref="T:System.String" /> object cannot be parsed.</exception>
        <exception cref="T:System.OverflowException">The value of the current <see cref="T:System.String" /> object is a number less than <see cref="F:System.Double.MinValue" /> or greater than <see cref="F:System.Double.MaxValue" />.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">An object that provides culture-specific formatting information.</param>
        <summary>For a description of this member, see &lt;xref:System.IConvertible.ToInt16%2A&gt;.</summary>
        <returns>The converted value of the current <see cref="T:System.String" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This member is an explicit interface member implementation. It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> method.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">The value of the current <see cref="T:System.String" /> object cannot be parsed.</exception>
        <exception cref="T:System.OverflowException">The value of the current <see cref="T:System.String" /> object is a number greater than <see cref="F:System.Int16.MaxValue" /> or less than <see cref="F:System.Int16.MinValue" />.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">An object that provides culture-specific formatting information.</param>
        <summary>For a description of this member, see &lt;xref:System.IConvertible.ToInt32%2A&gt;.</summary>
        <returns>The converted value of the current <see cref="T:System.String" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This member is an explicit interface member implementation. It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> method.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">An object that provides culture-specific formatting information.</param>
        <summary>For a description of this member, see &lt;xref:System.IConvertible.ToInt64%2A&gt;.</summary>
        <returns>The converted value of the current <see cref="T:System.String" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This member is an explicit interface member implementation. It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> method.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">An object that provides culture-specific formatting information.</param>
        <summary>For a description of this member, see &lt;xref:System.IConvertible.ToSByte%2A&gt;.</summary>
        <returns>The converted value of the current <see cref="T:System.String" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This member is an explicit interface member implementation. It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> method.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">The value of the current <see cref="T:System.String" /> object cannot be parsed.</exception>
        <exception cref="T:System.OverflowException">The value of the current <see cref="T:System.String" /> object is a number greater than <see cref="F:System.SByte.MaxValue" /> or less than <see cref="F:System.SByte.MinValue" />.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">An object that provides culture-specific formatting information.</param>
        <summary>For a description of this member, see &lt;xref:System.IConvertible.ToSingle%2A&gt;.</summary>
        <returns>The converted value of the current <see cref="T:System.String" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This member is an explicit interface member implementation. It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> method.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">The type of the returned object.</param>
        <param name="provider">An object that provides culture-specific formatting information.</param>
        <summary>For a description of this member, see &lt;xref:System.IConvertible.ToType%2A&gt;.</summary>
        <returns>The converted value of the current <see cref="T:System.String" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This member is an explicit interface member implementation. It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ChangeType%2A> method.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">The value of the current <see cref="T:System.String" /> object cannot be converted to the type specified by the <paramref name="type" /> parameter.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">An object that provides culture-specific formatting information.</param>
        <summary>For a description of this member, see &lt;xref:System.IConvertible.ToUInt16%2A&gt;.</summary>
        <returns>The converted value of the current <see cref="T:System.String" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This member is an explicit interface member implementation. It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> method.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">The value of the current <see cref="T:System.String" /> object cannot be parsed.</exception>
        <exception cref="T:System.OverflowException">The value of the current <see cref="T:System.String" /> object is a number greater than <see cref="F:System.UInt16.MaxValue" /> or less than <see cref="F:System.UInt16.MinValue" />.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">An object that provides culture-specific formatting information.</param>
        <summary>For a description of this member, see &lt;xref:System.IConvertible.ToUInt32%2A&gt;.</summary>
        <returns>The converted value of the current <see cref="T:System.String" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This member is an explicit interface member implementation. It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> method.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">The value of the current <see cref="T:System.String" /> object cannot be parsed.</exception>
        <exception cref="T:System.OverflowException">The value of the current <see cref="T:System.String" /> object is a number greater <see cref="F:System.UInt32.MaxValue" /> or less than <see cref="F:System.UInt32.MinValue" /></exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">An object that provides culture-specific formatting information.</param>
        <summary>For a description of this member, see &lt;xref:System.IConvertible.ToUInt64%2A&gt;.</summary>
        <returns>The converted value of the current <see cref="T:System.String" /> object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This member is an explicit interface member implementation. It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName> method.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copies the characters in this instance to a Unicode character array.</summary>
        <returns>A Unicode character array whose elements are the individual characters of this instance. If this instance is an empty string, the returned array is empty and has a zero length.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method copies each character (that is, each <xref:System.Char> object) in a string to a character array. The first character copied is at index zero of the returned character array; the last character copied is at index <xref:System.Array.Length%2A?displayProperty=fullName> â 1.  
  
 To create a string from the characters in a character array, call the [String(Char\[\])](assetId:///M:System.String.#ctor(System.Char[])?qualifyHint=False&autoUpgrade=False) constructor.  
  
 To create a byte array that contains the encoded characters in a string, instantiate the appropriate <xref:System.Text.Encoding> object and call its <xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=fullName> method. Some of the standard encodings available in the .NET Framework include the following:  
  
|Encoding|Object|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 For more information, see [Character Encoding in the .NET Framework](../Topic/Character%20Encoding%20in%20the%20.NET%20Framework.md).  
  
   
  
## Examples  
 The following example calls the ToCharArray method to extract the characters in a string to a character array. It then displays the original string and the elements in the array.  
  
 [!code-vb[System.String.ToCharArray#1](~/add/codesnippet/visualbasic/m-system.string.tocharar_0_1.vb)]
 [!code-cs[System.String.ToCharArray#1](~/add/codesnippet/csharp/m-system.string.tocharar_0_1.cs)]  
  
 The following example defines a string containing the characters that serve as delimiters in a delimited string. It then calls the ToCharArray method to create a character array that can be passed to the [Split(Char\[\])](assetId:///M:System.String.Split(System.Char[])?qualifyHint=False&autoUpgrade=False) method to separate the delimited string into its individual substrings.  
  
 [!code-cs[StringSplit2#1](~/add/codesnippet/csharp/m-system.string.tocharar_0_2.cs)]
 [!code-cs[StringSplit2#1](~/add/codesnippet/csharp/m-system.string.tocharar_0_2.cs)]
 [!code-cpp[StringSplit2#1](~/add/codesnippet/cpp/m-system.string.tocharar_0_2.cpp)]
 [!code-vb[StringSplit2#1](~/add/codesnippet/visualbasic/m-system.string.tocharar_0_2.vb)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray(int32 startIndex, int32 length) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">The starting position of a substring in this instance.</param>
        <param name="length">The length of the substring in this instance.</param>
        <summary>Copies the characters in a specified substring in this instance to a Unicode character array.</summary>
        <returns>A Unicode character array whose elements are the <paramref name="length" /> number of characters in this instance starting from character position <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method copies the characters in a portion of a string to a character array. To create a string from a range of characters in a character array, call the  [String(Char\[\],âInt32,âInt32)](assetId:///M:System.String.#ctor(System.Char[],System.Int32,System.Int32)?qualifyHint=False&autoUpgrade=False) constructor.  
  
 The `startIndex` parameter is zero-based. That is, the index of the first character in the string instance is zero.  
  
 If `length` is zero, the returned array is empty and has a zero length. If this instance is `null` or an empty string (""), the returned array is empty and has a zero length.  
  
 To create a byte array that contains the encoded characters in a portion of a string, instantiate the appropriate <xref:System.Text.Encoding> object and call its [GetBytes(String,âInt32,âInt32,âByte\[\],âInt32)](assetId:///M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)?qualifyHint=False&autoUpgrade=False) method. Some of the standard encodings available in the .NET Framework include the following:  
  
|Encoding|Object|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 For more information, see [Character Encoding in the .NET Framework](../Topic/Character%20Encoding%20in%20the%20.NET%20Framework.md).  
  
   
  
## Examples  
 The following example converts a substring within a string to an array of characters, then enumerates and displays the elements of the array.  
  
 [!code-cpp[string.tochararray1#1](~/add/codesnippet/cpp/m-system.string.tocharar_1_1.cpp)]
 [!code-vb[string.tochararray1#1](~/add/codesnippet/visualbasic/m-system.string.tocharar_1_1.vb)]
 [!code-cs[string.tochararray1#1](~/add/codesnippet/csharp/m-system.string.tocharar_1_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> or <paramref name="length" /> is less than zero.  
  
 -or-  
  
 <paramref name="startIndex" /> plus <paramref name="length" /> is greater than the length of this instance.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a copy of this string converted to lowercase.</summary>
        <returns>A string in lowercase.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method takes into account the casing rules of the current culture.  
  
> [!NOTE]
>  This method does not modify the value of the current instance. Instead, it returns a new string in which all characters in the current instance are converted to lowercase.  
  
## Security Considerations  
 The casing operation that results from calling the ToLower method takes the casing conventions of the current culture into account. If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> methods. This produces the same result in every culture (unlike the ToLower method) and performs more efficiently.  
  
   
  
## Examples  
 The following example converts several mixed case strings to lowercase.  
  
 [!code-cs[stringlowerupper#1](~/add/codesnippet/csharp/m-system.string.tolower_1.cs)]
 [!code-cpp[stringlowerupper#1](~/add/codesnippet/cpp/m-system.string.tolower_1.cpp)]
 [!code-vb[stringlowerupper#1](~/add/codesnippet/visualbasic/m-system.string.tolower_1.vb)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">An object that supplies culture-specific casing rules.</param>
        <summary>Returns a copy of this string converted to lowercase, using the casing rules of the specified culture.</summary>
        <returns>The lowercase equivalent of the current string.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The casing rules of the culture specified by the `culture` parameter determine the way the case of the string is changed.  
  
> [!NOTE]
>  This method does not modify the value of the current instance. Instead, it returns a new string in which all characters in the current instance are converted to lowercase.  
  
## Security Considerations  
 If you pass the ToLower method a <xref:System.Globalization.CultureInfo> object other than <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=fullName>, the casing operation will take culture-specific rules into account. If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> method. This produces the same result in every culture and performs more efficiently.  
  
   
  
## Examples  
 The following example converts two strings of uppercase characters to lowercase characters using the English-United States and Turkish-Turkey cultures, then compares the lowercase strings. The uppercase strings are identical except that for each occurrence of the Unicode LATIN CAPITAL LETTER I in one string, the other string contains LATIN CAPITAL LETTER I WITH DOT ABOVE.  
  
 [!code-cpp[string.tolower1#1](~/add/codesnippet/cpp/m-system.string.tolower-_1.cpp)]
 [!code-vb[string.tolower1#1](~/add/codesnippet/visualbasic/m-system.string.tolower-_1.vb)]
 [!code-cs[string.tolower1#1](~/add/codesnippet/csharp/m-system.string.tolower-_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> is <see langword="null" />.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public string ToLowerInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLowerInvariant() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a copy of this <see cref="T:System.String" /> object converted to lowercase using the casing rules of the invariant culture.</summary>
        <returns>The lowercase equivalent of the current string.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The invariant culture represents a culture that is culture-insensitive. It is associated with the English language but not with a specific country or region. For more information, see the <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=fullName> property.  
  
 If your application depends on the case of a string changing in a predictable way that is unaffected by the current culture, use the ToLowerInvariant method. The ToLowerInvariant method is equivalent to `ToLower(CultureInfo.InvariantCulture)`. The method is recommended when a collection of strings must appear in a predictable order in a user interface control.  
  
> [!NOTE]
>  This method does not modify the value of the current instance. Instead, it returns a new string in which all characters in the current instance are converted to lowercase.  
  
## Security Considerations  
 If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the ToLowerInvariant or <xref:System.String.ToUpperInvariant%2A> methods.  
  
   
  
## Examples  
 The following example defines a string array that contains a single word in a number of languages. The ToLowerInvariant method is used to populate the elements of a parallel array with the case-insensitive version of each word. The [Array.Sort\<TKey,âTValue>(TKey\[\],âTValue\[\],âIComparer\<TKey>)](assetId:///M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})?qualifyHint=True&autoUpgrade=False) method is used to sort the case-sensitive array based on the order of elements in the lowercase array to ensure that elements appear in the same order regardless of language.  
  
 [!code-cs[System.String.ToLowerInvariant#1](~/add/codesnippet/csharp/m-system.string.toloweri_1.cs)]
 [!code-vb[System.String.ToLowerInvariant#1](~/add/codesnippet/visualbasic/m-system.string.toloweri_1.vb)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns this instance of <see cref="T:System.String" />; no actual conversion is performed.</summary>
        <returns>The current string.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Because this method simply returns the current string unchanged, there is no need to call it directly. It is usually called implicitly in a composite formatting operation, as the example shows.  
  
   
  
## Examples  
 The following example demonstrates the ToString method.Note that the example does not explicitly call the ToString method. Instead, the method is called implicitly by the [composite formatting](../Topic/Composite%20Formatting.md) feature.  
  
 [!code-vb[string.tostring#1](~/add/codesnippet/visualbasic/m-system.string.tostring_1.vb)]
 [!code-cs[string.tostring#1](~/add/codesnippet/csharp/m-system.string.tostring_1.cs)]
 [!code-cpp[string.tostring#1](~/add/codesnippet/cpp/m-system.string.tostring_1.cpp)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">(Reserved) An object that supplies culture-specific formatting information.</param>
        <summary>Returns this instance of <see cref="T:System.String" />; no actual conversion is performed.</summary>
        <returns>The current string.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `provider` is reserved, and does not currently participate in this operation.  
  
 Because this method simply returns the current string unchanged, there is no need to call it directly.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a copy of this string converted to uppercase.</summary>
        <returns>The uppercase equivalent of the current string.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method uses the casing rules of the current culture to convert each character in the current instance to its uppercase equivalent. If a character does not have an uppercase equivalent, it is included unchanged in the returned string.  
  
> [!NOTE]
>  This method does not modify the value of the current instance. Instead, it returns a new string in which all characters in the current instance are converted to uppercase.  
  
 The ToUpper method is often used to convert a string to uppercase so that it can be used in a case-insensitive comparison. A better method to perform case-insensitive comparison is to call a string comparison method that has a <xref:System.StringComparison> parameter whose value you set to <xref:System.StringComparison?displayProperty=fullName> for a culture-sensitive, case-insensitive comparison.  
  
## Security Considerations  
 The casing operation that results from calling the ToUpper method takes the casing conventions of the current culture into account. If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> method. This produces the same result in every culture (unlike the ToUpper method) and performs more efficiently.  
  
   
  
## Examples  
 The following example calls the ToUpper method to convert a series of one-character strings that contain each character in the Basic Latin, Latin-1 Supplement, and Latin Extended-A character sets. It then displays each string whose uppercase character is different from its lowercase character.  
  
 [!code-vb[System.String.ToUpper#1](~/add/codesnippet/visualbasic/m-system.string.toupper_1.vb)]
 [!code-cs[System.String.ToUpper#1](~/add/codesnippet/csharp/m-system.string.toupper_1.cs)]
 [!code-cpp[System.String.ToUpper#1](~/add/codesnippet/cpp/m-system.string.toupper_1.cpp)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">An object that supplies culture-specific casing rules.</param>
        <summary>Returns a copy of this string converted to uppercase, using the casing rules of the specified culture.</summary>
        <returns>The uppercase equivalent of the current string.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The casing rules of the culture specified by the `culture` parameter determine the way the case of a string is changed.  
  
> [!NOTE]
>  This method does not modify the value of the current instance. Instead, it returns a new string in which all characters in the current instance are converted to uppercase.  
  
## Security Considerations  
 If you pass the ToUpper method a <xref:System.Globalization.CultureInfo> object other than <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=fullName>, the casing operation will take culture-specific rules into account. If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> method. This produces the same result in every culture and performs more efficiently.  
  
   
  
## Examples  
 The following example converts a string of lowercase characters to two strings of uppercase characters using the English-United States and Turkish-Turkey cultures, then compares the uppercase strings. The uppercase strings are identical except that for each occurrence of the Unicode LATIN CAPITAL LETTER I in one string, the other string contains LATIN CAPITAL LETTER I WITH DOT ABOVE.  
  
 [!code-cs[string.toupper1#1](~/add/codesnippet/csharp/m-system.string.toupper-_1.cs)]
 [!code-vb[string.toupper1#1](~/add/codesnippet/visualbasic/m-system.string.toupper-_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> is <see langword="null" />.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public string ToUpperInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpperInvariant() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a copy of this <see cref="T:System.String" /> object converted to uppercase using the casing rules of the invariant culture.</summary>
        <returns>The uppercase equivalent of the current string.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The invariant culture represents a culture that is culture-insensitive. It is associated with the English language but not with a specific country or region. For more information, see the <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=fullName> property.  
  
 If your application depends on the case of a string changing in a predictable way that is unaffected by the current culture, use the ToUpperInvariant method. The ToUpperInvariant method is equivalent to `ToUpper(CultureInfo.InvariantCulture)`. The method is recommended when a collection of strings must appear in a predictable order in a user interface control.  
  
> [!NOTE]
>  This method does not modify the value of the current instance. Instead, it returns a new string in which all characters in the current instance are converted to uppercase.  
  
## Security Considerations  
 If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or ToUpperInvariant methods.  
  
   
  
## Examples  
 The following example defines a string array that contains a single word in a number of languages. The ToUpperInvariant method is used to populate the elements of a parallel array with the case-insensitive version of each word. The [Array.Sort\<TKey,âTValue>(TKey\[\],âTValue\[\],âIComparer\<TKey>)](assetId:///M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})?qualifyHint=True&autoUpgrade=False) method is used to sort the case-sensitive array based on the order of elements in the uppercase array to ensure that elements appear in the same order regardless of language.  
  
 [!code-cs[System.String.ToUpperInvariant#1](~/add/codesnippet/csharp/m-system.string.toupperi_1.cs)]
 [!code-vb[System.String.ToUpperInvariant#1](~/add/codesnippet/visualbasic/m-system.string.toupperi_1.vb)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Removes all leading and trailing white-space characters from the current <see cref="T:System.String" /> object.</summary>
        <returns>The string that remains after all white-space characters are removed from the start and end of the current string. If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The Trim method removes from the current string all leading and trailing white-space characters. Each leading and trailing trim operation stops when a non-white-space character is encountered. For example, if the current string is "   abc   xyz   ", the Trim method returns "abc   xyz". To remove white-space characters between words in a string, use a [.NET Framework Regular Expressions](../Topic/.NET%20Framework%20Regular%20Expressions.md).  
  
> [!NOTE]
>  If the Trim method removes any characters from the current instance, this method does not modify the value of the current instance. Instead, it returns a new string in which all leading and trailing white space characters found in the current instance are removed.  
  
 If the current string equals <xref:System.String> or all the characters in the current instance consist of white-space characters, the method returns <xref:System.String>.  
  
 White-space characters are defined by the Unicode standard. The Trim method removes any leading and trailing characters that produce a return value of `true` when they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName> method.  
  
   
  
## Examples  
 The following example uses the Trim method to remove any extra white space from strings entered by the user before concatenating them.  
  
 [!code-cpp[System.String.Trim#2](~/add/codesnippet/cpp/m-system.string.trim_1.cpp)]
 [!code-cs[System.String.Trim#2](~/add/codesnippet/csharp/m-system.string.trim_1.cs)]
 [!code-vb[System.String.Trim#2](~/add/codesnippet/visualbasic/m-system.string.trim_1.vb)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char[] trimChars) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">An array of Unicode characters to remove, or <see langword="null" />.</param>
        <summary>Removes all leading and trailing occurrences of a set of characters specified in an array from the current <see cref="T:System.String" /> object.</summary>
        <returns>The string that remains after all occurrences of the characters in the <paramref name="trimChars" /> parameter are removed from the start and end of the current string. If <paramref name="trimChars" /> is <see langword="null" /> or an empty array, white-space characters are removed instead. If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The Trim method removes from the current string all leading and trailing characters that are in the `trimChars` parameter. Each leading and trailing trim operation stops when a character that is not in `trimChars` is encountered. For example, if the current string is "123abc456xyz789" and `trimChars` contains the digits from "1" through "9", the Trim method returns "abc456xyz".  
  
> [!NOTE]
>  If the Trim method removes any characters from the current instance, this method does not modify the value of the current instance. Instead, it returns a new string in which all leading and trailing `trimChars` characters found in the current instance are removed.  
  
 If the current string equals <xref:System.String> or all the characters in the current instance consist of characters in the `trimChars` array, the method returns <xref:System.String>.  
  
 If `trimChars` is `null` or an empty array, this method removes any leading or trailing characters that result in the method returning `true` when they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=fullName> method,  
  
   
  
## Examples  
 The following example uses the Trim method to remove space, asterisk (*), and apostrophe (') characters from a string.  
  
 [!code-cpp[System.String.Trim#1](~/add/codesnippet/cpp/m-system.string.trim-sys_1.cpp)]
 [!code-vb[System.String.Trim#1](~/add/codesnippet/visualbasic/m-system.string.trim-sys_1.vb)]
 [!code-cs[System.String.Trim#1](~/add/codesnippet/csharp/m-system.string.trim-sys_1.cs)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char[] trimChars) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">An array of Unicode characters to remove, or <see langword="null" />.</param>
        <summary>Removes all trailing occurrences of a set of characters specified in an array from the current <see cref="T:System.String" /> object.</summary>
        <returns>The string that remains after all occurrences of the characters in the <paramref name="trimChars" /> parameter are removed from the end of the current string. If <paramref name="trimChars" /> is <see langword="null" /> or an empty array, Unicode white-space characters are removed instead. If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The TrimEnd method removes from the current string all trailing characters that are in the `trimChars` parameter. The trim operation stops when the first character that is not in `trimChars` is encountered at the end of the string. For example, if the current string is "123abc456xyz789" and `trimChars` contains the digits from "1" through "9", the TrimEnd method returns "123abc456xyz".  
  
> [!NOTE]
>  If the TrimEnd method removes any characters from the current instance, this method does not modify the value of the current instance. Instead, it returns a new string in which all trailing characters found in `trimChars` are removed from the current string.  
  
   
  
## Examples  
 The following example demonstrates how you can use the TrimEnd method to trim white space or punctuation marks from the end of a string.  
  
 [!code-cs[System.String.TrimEnd#2](~/add/codesnippet/csharp/m-system.string.trimend-_1.cs)]
 [!code-vb[System.String.TrimEnd#2](~/add/codesnippet/visualbasic/m-system.string.trimend-_1.vb)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char[] trimChars) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">An array of Unicode characters to remove, or <see langword="null" />.</param>
        <summary>Removes all leading occurrences of a set of characters specified in an array from the current <see cref="T:System.String" /> object.</summary>
        <returns>The string that remains after all occurrences of characters in the <paramref name="trimChars" /> parameter are removed from the start of the current string. If <paramref name="trimChars" /> is <see langword="null" /> or an empty array, white-space characters are removed instead.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The TrimStart method removes from the current string all leading characters that are in the `trimChars` parameter. The trim operation stops when a character that is not in `trimChars` is encountered. For example, if the current string is "123abc456xyz789" and `trimChars` contains the digits from "1" through "9", the TrimStart method returns "abc456xyz789".  
  
> [!NOTE]
>  If the TrimStart method removes any characters from the current instance, this method does not modify the value of the current instance. Instead, it returns a new string in which all leading white space characters found in the current instance are removed.  
  
   
  
## Examples  
 The following example uses the TrimStart method to trim white space and comment characters from lines of source code. The `StripComments` method wraps a call to TrimStart and passes it a character array that contains a space and the comment character, which is an apostrophe ( ' ) in Visual Basic and a slash ( / ) in C#. The TrimStart method is also called to remove leading white space when evaluating whether a string is a comment.  
  
 [!code-cs[System.String.TrimStart#1](~/add/codesnippet/csharp/m-system.string.trimstar_1.cs)]
 [!code-vb[System.String.TrimStart#1](~/add/codesnippet/visualbasic/m-system.string.trimstar_1.vb)]  
  
 The following example then illustrates a call to the `StripComments` method.  
  
 [!code-cs[System.String.TrimStart#2](~/add/codesnippet/csharp/m-system.string.trimstar_2.cs)]
 [!code-vb[System.String.TrimStart#2](~/add/codesnippet/visualbasic/m-system.string.trimstar_2.vb)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
  </Members>
</Type>