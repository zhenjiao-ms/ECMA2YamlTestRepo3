<Type Name="MethodBase" FullName="System.Reflection.MethodBase">
  <TypeSignature Language="C#" Value="public abstract class MethodBase : System.Reflection.MemberInfo, System.Runtime.InteropServices._MethodBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit MethodBase extends System.Reflection.MemberInfo implements class System.Runtime.InteropServices._MethodBase" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._MethodBase</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._MethodBase))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Provides information about methods and constructors.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `MethodBase` is the base class of <xref:System.Reflection.MethodInfo> and <xref:System.Reflection.ConstructorInfo>.  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">for full trust for inheritors. This class cannot be inherited by partially trusted code.</permission>
    <threadsafe>This type is thread safe.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MethodBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Reflection.MethodBase" /> class.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the attributes associated with this method.</summary>
        <value>One of the <see cref="T:System.Reflection.MethodAttributes" /> values.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 All members have a set of attributes, which are defined in relation to the specific type of member.  
  
 To get the <xref:System.Reflection.MethodAttributes>, first get the type. From the type, get the method. From the method, get the <xref:System.Reflection.MethodAttributes>.  
  
   
  
## Examples  
 The following code example displays the attributes of the user-defined method Mymethod.  
  
 [!code-cs[Classic MethodBase.Attributes Example#1](~/add/codesnippet/csharp/p-system.reflection.meth_15_1.cs)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/add/codesnippet/visualbasic/p-system.reflection.meth_15_1.vb)]
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/add/codesnippet/cpp/p-system.reflection.meth_15_1.cpp)]  
  
 This code produces the following output:  
  
 Reflection.MethodBase.Attributes Sample  
  
 Mymethodbase = Void Mymethod(Int32, System.String ByRef, System.String ByRef)  
  
 PrivateScope  
  
 FamANDAssem  
  
 Family  
  
 Public  
  
 HideBySig  
  
 ReuseSlot  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating the calling conventions for this method.</summary>
        <value>The <see cref="T:System.Reflection.CallingConventions" /> for this method.</value>
        <remarks>To be added.</remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the generic method contains unassigned generic type parameters.</summary>
        <value>
          <see langword="true" /> if the current <see cref="T:System.Reflection.MethodBase" /> object represents a generic method that contains unassigned generic type parameters; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A generic method can be invoked only if there are no generic type definitions or open constructed types in the type arguments of the method itself or in any enclosing types. Because types can be arbitrarily complex, making this recursive determination is difficult. For convenience, and to reduce the chance of error, the ContainsGenericParameters property provides a standard way to distinguish between closed constructed methods, which can be invoked, and open constructed methods, which cannot. If the ContainsGenericParameters property returns `true`, the method cannot be invoked.  
  
 The ContainsGenericParameters property searches recursively for type parameters. For example, it returns `true` for any method in an open type `A<T>` (`A(Of T)` in Visual Basic), even though the method itself is not generic. Contrast this with the behavior of the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property, which returns `false` for such a method.  
  
 Similarly, the ContainsGenericParameters property parameter returns `true` for any constructor in an open type, even though constructors cannot have type parameters of their own.  
  
 For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodInfo.IsGenericMethod%2A?displayProperty=fullName> property. For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=fullName> property.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">An object to compare with this instance, or <see langword="null" />.</param>
        <summary>Returns a value that indicates whether this instance is equal to a specified object.</summary>
        <returns>
          <see langword="true" /> if <paramref name="obj" /> equals the type and value of this instance; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentMethod">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetCurrentMethod ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetCurrentMethod() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a <see langword="MethodBase" /> object representing the currently executing method.</summary>
        <returns>GetCurrentMethod is a static method that is called from within an executing method and that returns information about that method.  
  
 A <see langword="MethodBase" /> object representing the currently executing method.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If the currently executing method is defined on a generic type, the <xref:System.Reflection.MethodInfo> that is returned by GetCurrentMethod is obtained from the generic type definition (that is, <xref:System.Reflection.MethodInfo.ContainsGenericParameters%2A?displayProperty=fullName> returns `true`). Therefore, it does not reflect the type arguments that were used when the method was called. For example, if a method `M()` is defined on a generic type `C<T>` (`C(Of T)` in Visual Basic), and GetCurrentMethod is called from `C<string>.M()`, then GetCurrentMethod returns `C<T>.M()` (`C(Of T).M()` in Visual Basic).  
  
 If the currently executing method is a generic method, GetCurrentMethod returns the generic method definition. If the generic method is defined on a generic type, the <xref:System.Reflection.MethodInfo> is obtained from the generic type definition.  
  
   
  
## Examples  
 The following example defines two types. The first is a non-generic class, `TestClass`, includes a constructor, a method named `GetValue`, and a read-write property named `GetValue`. The second is a generic class named `TestClass<T>` that includes a constructor, a `GetValue` method, and a generic method, `ConvertValue<Y>`. Each constructor, method, and property accessor includes a call to the GetCurrentMethod method.  
  
 [!code-cs[System.Reflection.MethodBase.GetCurrentMethod#1](~/add/codesnippet/csharp/m-system.reflection.meth_0_1.cs)]
 [!code-vb[System.Reflection.MethodBase.GetCurrentMethod#1](~/add/codesnippet/visualbasic/m-system.reflection.meth_0_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException">This member was invoked with a late-binding mechanism.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</summary>
        <returns>An array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic method or the type parameters of a generic method definition. Returns an empty array if the current method is not a generic method.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The elements of the returned array are in the order in which they appear in the list of type parameters for the generic method.  
  
-   If the current method is a closed constructed method (that is, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `false`), the array returned by the GetGenericArguments method contains the types that have been assigned to the generic type parameters of the generic method definition.  
  
-   If the current method is a generic method definition, the array contains the type parameters.  
  
-   If the current method is an open constructed method (that is, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `true`) in which specific types have been assigned to some type parameters and type parameters of enclosing generic types have been assigned to other type parameters, the array contains both types and type parameters. Use the <xref:System.Type.IsGenericParameter%2A> property to tell them apart. For a demonstration of this scenario, see the code example provided for the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property.  
  
 Generic constructors are not supported in the .NET Framework version 2.0. This property throws <xref:System.NotSupportedException> if not overridden in a derived class, so an exception is thrown if the current instance is of type <xref:System.Reflection.ConstructorInfo>.  
  
 For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodInfo.IsGenericMethod%2A?displayProperty=fullName> property. For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=fullName> property.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The current object is a <see cref="T:System.Reflection.ConstructorInfo" />. Generic constructors are not supported in the .NET Framework version 2.0. This exception is the default behavior if this method is not overridden in a derived class.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the hash code for this instance.</summary>
        <returns>A 32-bit signed integer hash code.</returns>
        <remarks>To be added.</remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetMethodBody">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBody GetMethodBody ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBody GetMethodBody() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBody</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden in a derived class, gets a <see cref="T:System.Reflection.MethodBody" /> object that provides access to the MSIL stream, local variables, and exceptions for the current method.</summary>
        <returns>A <see cref="T:System.Reflection.MethodBody" /> object that provides access to the MSIL stream, local variables, and exceptions for the current method.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 You do not have to override the GetMethodBody in order to use it. You can call the GetMethodBody method on <xref:System.Reflection.MethodInfo> and <xref:System.Reflection.ConstructorInfo> objects, because the method is overridden in the runtime versions of these classes. For example, the runtime version of the <xref:System.Reflection.MethodInfo> class derives from the <xref:System.Reflection.MethodInfo> class, which in turn derives from the <xref:System.Reflection.MethodBase> class.  
  
   
  
## Examples  
 The following code example defines a test method named `MethodBodyExample` and displays its local variable information and exception-handling clauses. The GetMethodBody method is used to obtain a <xref:System.Reflection.MethodBody> object for the test method.  
  
 The <xref:System.Reflection.MethodBody.LocalVariables%2A> property is used to obtain a list of <xref:System.Reflection.LocalVariableInfo> objects and display their types and index order. The <xref:System.Reflection.MethodBody.ExceptionHandlingClauses%2A> property is used to obtain a list of exception-handling clauses.  
  
> [!NOTE]
>  Not all computer languages can generate <xref:System.Reflection.ExceptionHandlingClauseOptions?displayProperty=fullName> clauses. The Visual Basic example shows a filter clause, using a Visual Basic `When` expression, which is omitted from the examples for other languages.  
  
 [!code-cpp[MethodBody#1](~/add/codesnippet/cpp/m-system.reflection.meth_4_1.cpp)]
 [!code-vb[MethodBody#1](~/add/codesnippet/visualbasic/m-system.reflection.meth_4_1.vb)]
 [!code-cs[MethodBody#1](~/add/codesnippet/csharp/m-system.reflection.meth_4_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This method is invalid unless overridden in a derived class.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">for the access to metadata for members. Permission value: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" /></permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetMethodFromHandle">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodFromHandle (RuntimeMethodHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodFromHandle(valuetype System.RuntimeMethodHandle handle) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeMethodHandle" />
      </Parameters>
      <Docs>
        <param name="handle">The method's handle.</param>
        <summary>Gets method information by using the method's internal metadata representation (handle).</summary>
        <returns>A <see langword="MethodBase" /> containing information about the method.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Handles are valid only in the application domain in which they were obtained.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="handle" /> is invalid.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetMethodFromHandle">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodFromHandle (RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodFromHandle(valuetype System.RuntimeMethodHandle handle, valuetype System.RuntimeTypeHandle declaringType) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeMethodHandle" />
        <Parameter Name="declaringType" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">A handle to the internal metadata representation of a constructor or method.</param>
        <param name="declaringType">A handle to the generic type that defines the constructor or method.</param>
        <summary>Gets a <see cref="T:System.Reflection.MethodBase" /> object for the constructor or method represented by the specified handle, for the specified generic type.</summary>
        <returns>A <see cref="T:System.Reflection.MethodBase" /> object representing the method or constructor specified by <paramref name="handle" />, in the generic type specified by <paramref name="declaringType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Handles are valid only in the application domain in which they were obtained.  
  
 A <xref:System.RuntimeMethodHandle> structure for a constructor or method of a generic type can represent different <xref:System.Reflection.MethodBase> objects, depending on the types specified for the type parameters of the generic type. For example, if `class G<T>` (`class G(Of T)` in Visual Basic, `generic <T> ref class G` in C++) has a method that returns type `T`, the <xref:System.Reflection.MethodBase> object for that method in a constructed class such as `G<int>` is different from the <xref:System.Reflection.MethodBase> object for that method in the generic type definition.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="handle" /> is invalid.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden in a derived class, returns the <see cref="T:System.Reflection.MethodImplAttributes" /> flags.</summary>
        <returns>The <see langword="MethodImplAttributes" /> flags.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example defines a constructor in a dynamic assembly and then uses the GetMethodImplementationFlags method to display the method implementation flags that are set by default.  
  
 [!code-cs[ConstructorBuilder_GetModule_4#3](~/add/codesnippet/csharp/m-system.reflection.meth_8_1.cs)]
 [!code-cpp[ConstructorBuilder_GetModule_4#3](~/add/codesnippet/cpp/m-system.reflection.meth_8_1.cpp)]
 [!code-vb[ConstructorBuilder_GetModule_4#3](~/add/codesnippet/visualbasic/m-system.reflection.meth_8_1.vb)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>When overridden in a derived class, gets the parameters of the specified method or constructor.</summary>
        <returns>An array of type <see langword="ParameterInfo" /> containing information that matches the signature of the method (or constructor) reflected by this <see langword="MethodBase" /> instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 The following example uses the GetParameters method to retrieve the parameters of the `Invoke` method of a delegate.  
  
 The example defines a delegate named `MyDelegate` and an event named `ev` of type `MyDelegate`. The code in the `Main` method discovers the event signature by getting the delegate type of the event, getting the `Invoke` method of the delegate type, and then retrieving and displaying the parameters.  
  
 [!code-cs[eventarg#1](~/add/codesnippet/csharp/m-system.reflection.meth_5_1.cs)]
 [!code-cpp[eventarg#1](~/add/codesnippet/cpp/m-system.reflection.meth_5_1.cpp)]
 [!code-vb[eventarg#1](~/add/codesnippet/visualbasic/m-system.reflection.meth_5_1.vb)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (object obj, object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(object obj, object[] parameters) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="parameters" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="obj">The object on which to invoke the method or constructor. If a method is static, this argument is ignored. If a constructor is static, this argument must be <see langword="null" /> or an instance of the class that defines the constructor.</param>
        <param name="parameters">An argument list for the invoked method or constructor. This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked. If there are no parameters, `parameters` should be <see langword="null" />.  
  
 If the method or constructor represented by this instance takes a <see langword="ref" /> parameter (<see langword="ByRef" /> in Visual Basic), no special attribute is required for that parameter in order to invoke the method or constructor using this function. Any object in this array that is not explicitly initialized with a value will contain the default value for that object type. For reference-type elements, this value is <see langword="null" />. For value-type elements, this value is 0, 0.0, or <see langword="false" />, depending on the specific element type.</param>
        <summary>Invokes the method or constructor represented by the current instance, using the specified parameters.</summary>
        <returns>An object containing the return value of the invoked method, or <see langword="null" /> in the case of a constructor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This is a convenience method that calls the [Invoke(Object, BindingFlags, Binder, Object\[\], CultureInfo)](assetId:///M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)?qualifyHint=False&autoUpgrade=False) method overload, passing <xref:System.Reflection.BindingFlags> for `invokeAttr` and `null` for `binder` and `culture`.  
  
 If the invoked method throws an exception, the <xref:System.Exception.GetBaseException%2A?displayProperty=fullName> method returns the exception.  
  
 To invoke a static method using its <xref:System.Reflection.MethodInfo> object, pass `null` for `obj`.  
  
> [!NOTE]
>  If this method overload is used to invoke an instance constructor, the object supplied for `obj` is reinitialized; that is, all instance initializers are executed. The return value is `null`. If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed. The return value is `null`.  
  
> [!NOTE]
>  Starting with the [!INCLUDE[net_v20sp1_long](~/add/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof. (See [Security Considerations for Reflection](../Topic/Security%20Considerations%20for%20Reflection.md).)  
>   
>  To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/add/includes/net-v35-long-md.md)] or later.  
  
 If a parameter of the current method is a value type, and the corresponding argument in `parameters` is `null`, the runtime passes a zero-initialized instance of the value type.  
  
   
  
## Examples  
 The following code example demonstrates dynamic method lookup using reflection. Note that you cannot use the <xref:System.Reflection.MethodInfo> object from the base class to invoke the overridden method in the derived class, because late binding cannot resolve overrides.  
  
 [!code-cpp[Classic MethodBase.Invoke1 Example#1](~/add/codesnippet/cpp/m-system.reflection.meth_3_1.cpp)]
 [!code-cs[Classic MethodBase.Invoke1 Example#1](~/add/codesnippet/csharp/m-system.reflection.meth_3_1.cs)]
 [!code-vb[Classic MethodBase.Invoke1 Example#1](~/add/codesnippet/visualbasic/m-system.reflection.meth_3_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException">
          <block subset="none" type="note">  
 In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](../Topic/Cross-Platform%20Development%20with%20the%20Portable%20Class%20Library.md), catch <see cref="T:System.Exception" /> instead.  
  
</block>  
  
 The <paramref name="obj" /> parameter is <see langword="null" /> and the method is not static.  
  
 -or-  
  
 The method is not declared or inherited by the class of <paramref name="obj" />.  
  
 -or-  
  
 A static constructor is invoked, and <paramref name="obj" /> is neither <see langword="null" /> nor an instance of the class that declared the constructor.</exception>
        <exception cref="T:System.ArgumentException">The elements of the <paramref name="parameters" />array do not match the signature of the method or constructor reflected by this instance.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">The invoked method or constructor throws an exception.  
  
 -or-  
  
 The current instance is a <see cref="T:System.Reflection.Emit.DynamicMethod" /> that contains unverifiable code. See the "Verification" section in Remarks for <see cref="T:System.Reflection.Emit.DynamicMethod" />.</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">The <paramref name="parameters" /> array does not have the correct number of arguments.</exception>
        <exception cref="T:System.MethodAccessException">
          <block subset="none" type="note">  
 In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](../Topic/Cross-Platform%20Development%20with%20the%20Portable%20Class%20Library.md), catch the base class exception, <see cref="T:System.MemberAccessException" />, instead.  
  
</block>  
  
 The caller does not have permission to execute the method or constructor that is represented by the current instance.</exception>
        <exception cref="T:System.InvalidOperationException">The type that declares the method is an open generic type. That is, the <see cref="System.Type.ContainsGenericParameters%2A" /> property returns <see langword="true" /> for the declaring type.</exception>
        <exception cref="T:System.NotSupportedException">The current instance is a <see cref="T:System.Reflection.Emit.MethodBuilder" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public abstract object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="parameters" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="obj">The object on which to invoke the method or constructor. If a method is static, this argument is ignored. If a constructor is static, this argument must be <see langword="null" /> or an instance of the class that defines the constructor.</param>
        <param name="invokeAttr">A bitmask that is a combination of 0 or more bit flags from <see cref="T:System.Reflection.BindingFlags" />. If `binder` is <see langword="null" />, this parameter is assigned the value <see cref="T:System.Reflection.BindingFlags" />; thus, whatever you pass in is ignored.</param>
        <param name="binder">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects via reflection. If `binder` is <see langword="null" />, the default binder is used.</param>
        <param name="parameters">An argument list for the invoked method or constructor. This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked. If there are no parameters, this should be <see langword="null" />.  
  
 If the method or constructor represented by this instance takes a ByRef parameter, there is no special attribute required for that parameter in order to invoke the method or constructor using this function. Any object in this array that is not explicitly initialized with a value will contain the default value for that object type. For reference-type elements, this value is <see langword="null" />. For value-type elements, this value is 0, 0.0, or <see langword="false" />, depending on the specific element type.</param>
        <param name="culture">An instance of <see langword="CultureInfo" /> used to govern the coercion of types. If this is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread is used. (This is necessary to convert a <see langword="String" /> that represents 1000 to a <see langword="Double" /> value, for example, since 1000 is represented differently by different cultures.)</param>
        <summary>When overridden in a derived class, invokes the reflected method or constructor with the given parameters.</summary>
        <returns>An <see langword="Object" /> containing the return value of the invoked method, or <see langword="null" /> in the case of a constructor, or <see langword="null" /> if the method's return type is <see langword="void" />. Before calling the method or constructor, <see langword="Invoke" /> checks to see if the user has access permission and verifies that the parameters are valid.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dynamically invokes the method reflected by this instance on `obj`, and passes along the specified parameters. If the method is static, the `obj` parameter is ignored. For non-static methods, `obj` should be an instance of a class that inherits or declares the method and must be the same type as this class. If the method has no parameters, the value of `parameters` should be `null`. Otherwise, the number, type, and order of elements in `parameters` should be identical to the number, type, and order of parameters for the method reflected by this instance.  
  
 You may not omit optional parameters in calls to `Invoke`. To invoke a method omitting optional parameters, you should call `Type.InvokeMember` instead.  
  
> [!NOTE]
>  If this method overload is used to invoke an instance constructor, the object supplied for `obj` is reinitialized; that is, all instance initializers are executed. The return value is `null`. If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed. The return value is `null`.  
  
 For pass-by-value primitive parameters, normal widening is performed (Int16 -> Int32, for example). For pass-by-value reference parameters, normal reference widening is allowed (derived class to base class, and base class to interface type). However, for pass-by-reference primitive parameters, the types must match exactly. For pass-by-reference reference parameters, the normal widening still applies.  
  
 For example, if the method reflected by this instance is declared as `public boolean Compare(String a, String b)`, then `parameters` should be an array of `Objects` with length 2 such that `parameters[0] = new Object("SomeString1") and parameters[1] = new Object("SomeString2")`.  
  
 If a parameter of the current method is a value type, and the corresponding argument in `parameters` is `null`, the runtime passes a zero-initialized instance of the value type.  
  
 Reflection uses dynamic method lookup when invoking virtual methods. For example, suppose that class B inherits from class A and both implement a virtual method named M. Now suppose that you have a `MethodInfo` object that represents M on class A. If you use the `Invoke` method to invoke M on an object of type B, then reflection will use the implementation given by class B. Even if the object of type B is cast to A, the implementation given by class B is used (see code sample below).  
  
 On the other hand, if the method is non-virtual, then reflection will use the implementation given by the type from which the `MethodInfo` was obtained, regardless of the type of the object passed as the target.  
  
 Access restrictions are ignored for fully trusted code. That is, private constructors, methods, fields, and properties can be accessed and invoked via reflection whenever the code is fully trusted.  
  
 If the invoked method throws an exception, `TargetInvocationException.GetException` returns the exception. This implementation throws a `NotSupportedException`.  
  
> [!NOTE]
>  Starting with the [!INCLUDE[net_v20sp1_long](~/add/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof. (See [Security Considerations for Reflection](../Topic/Security%20Considerations%20for%20Reflection.md).)  
>   
>  To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/add/includes/net-v35-long-md.md)] or later.  
  
   
  
## Examples  
 The following example demonstrates all members of the <xref:System.Reflection.Binder?displayProperty=fullName> class using an overload of <xref:System.Type.InvokeMember%2A?displayProperty=fullName>. The private method `CanConvertFrom` finds compatible types for a given type. For another example of invoking members in a custom binding scenario, see [Dynamically Loading and Using Types](../Topic/Dynamically%20Loading%20and%20Using%20Types.md).  
  
 [!code-cpp[Binder_1#1](~/add/codesnippet/cpp/1c0c697d-6d92-4a27-8956-_1.cpp)]
 [!code-vb[Binder_1#1](~/add/codesnippet/visualbasic/1c0c697d-6d92-4a27-8956-_1.vb)]
 [!code-cs[Binder_1#1](~/add/codesnippet/csharp/1c0c697d-6d92-4a27-8956-_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException">The <paramref name="obj" /> parameter is <see langword="null" /> and the method is not static.  
  
 -or-  
  
 The method is not declared or inherited by the class of <paramref name="obj" />.  
  
 -or-  
  
 A static constructor is invoked, and <paramref name="obj" /> is neither <see langword="null" /> nor an instance of the class that declared the constructor.</exception>
        <exception cref="T:System.ArgumentException">The type of the <paramref name="parameters" /> parameter does not match the signature of the method or constructor reflected by this instance.</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">The <paramref name="parameters" /> array does not have the correct number of arguments.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">The invoked method or constructor throws an exception.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have permission to execute the method or constructor that is represented by the current instance.</exception>
        <exception cref="T:System.InvalidOperationException">The type that declares the method is an open generic type. That is, the <see cref="System.Type.ContainsGenericParameters%2A" /> property returns <see langword="true" /> for the declaring type.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the method is abstract.</summary>
        <value>
          <see langword="true" /> if the method is abstract; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 An abstract member is declared on a base class and has no implementation supplied.  
  
 To get the <xref:System.Reflection.MethodBase>, first get the type. From the type, get the method. From the method, get the `MethodBase`. If the `MethodBase` or constructor is other than public, it is protected and cannot be readily accessed. To access a non-public method, set the <xref:System.Reflection.BindingFlags> mask to `NonPublic` in `GetMethod`.  
  
   
  
## Examples  
 The following example determines whether specified the method is abstract and displays the result.  
  
 [!code-cpp[Classic MethodBase.IsAbstract Example#1](~/add/codesnippet/cpp/p-system.reflection.meth_0_1.cpp)]
 [!code-cs[Classic MethodBase.IsAbstract Example#1](~/add/codesnippet/csharp/p-system.reflection.meth_0_1.cs)]
 [!code-vb[Classic MethodBase.IsAbstract Example#1](~/add/codesnippet/visualbasic/p-system.reflection.meth_0_1.vb)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IsAssembly">
      <MemberSignature Language="C#" Value="public bool IsAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the potential visibility of this method or constructor is described by <see cref="T:System.Reflection.MethodAttributes" />; that is, the method or constructor is visible at most to other types in the same assembly, and is not visible to derived types outside the assembly.</summary>
        <value>
          <see langword="true" /> if the visibility of this method or constructor is exactly described by <see cref="T:System.Reflection.MethodAttributes" />; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The actual visibility of a method is limited by the visibility of its type. The IsAssembly property might be `true` for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.  
  
 The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes?displayProperty=fullName> if the only visibility modifier is `internal` (`Friend` in Visual Basic). This property is `false` for methods that are `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++); use the <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> property to identify such methods.  
  
   
  
## Examples  
 The following code example defines methods with varying levels of visibility, and displays the values of their IsAssembly, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.  
  
> [!NOTE]
>  The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes?displayProperty=fullName> visibility; that access level appears only in the C++ example.  
  
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/add/codesnippet/visualbasic/p-system.reflection.meth_14_1.vb)]
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/add/codesnippet/cpp/p-system.reflection.meth_14_1.cpp)]
 [!code-cs[Classic MethodBase.IsAssembly Example#1](~/add/codesnippet/csharp/p-system.reflection.meth_14_1.cs)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IsConstructor">
      <MemberSignature Language="C#" Value="public bool IsConstructor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the method is a constructor.</summary>
        <value>
          <see langword="true" /> if this method is a constructor represented by a <see cref="T:System.Reflection.ConstructorInfo" /> object (see note in Remarks about <see cref="T:System.Reflection.Emit.ConstructorBuilder" /> objects); otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  The IsConstructor property returns `false` for a <xref:System.Reflection.Emit.ConstructorBuilder> object in a dynamic type, unless the <xref:System.Reflection.MethodAttributes?displayProperty=fullName> flag was included in the `attributes` parameter when the constructor was defined. Omitting the <xref:System.Reflection.MethodAttributes> flag does not affect the correctness of the emitted constructor.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IsFamily">
      <MemberSignature Language="C#" Value="public bool IsFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the visibility of this method or constructor is described by <see cref="T:System.Reflection.MethodAttributes" />; that is, the method or constructor is visible only within its class and derived classes.</summary>
        <value>
          <see langword="true" /> if access to this method or constructor is exactly described by <see cref="T:System.Reflection.MethodAttributes" />; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes?displayProperty=fullName> if the only visibility modifier is `protected`. This property is `false` for methods that are `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++); use the <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> property to identify such methods.  
  
   
  
## Examples  
 The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, IsFamily, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.  
  
> [!NOTE]
>  The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes?displayProperty=fullName> visibility; that access level appears only in the C++ example.  
  
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/add/codesnippet/visualbasic/p-system.reflection.meth_9_1.vb)]
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/add/codesnippet/cpp/p-system.reflection.meth_9_1.cpp)]
 [!code-cs[Classic MethodBase.IsAssembly Example#1](~/add/codesnippet/csharp/p-system.reflection.meth_9_1.cs)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IsFamilyAndAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyAndAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyAndAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the visibility of this method or constructor is described by <see cref="T:System.Reflection.MethodAttributes" />; that is, the method or constructor can be called by derived classes, but only if they are in the same assembly.</summary>
        <value>
          <see langword="true" /> if access to this method or constructor is exactly described by <see cref="T:System.Reflection.MethodAttributes" />; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes?displayProperty=fullName> if the visibility modifier is `protected private` in C++. Methods with this visibility cannot be defined in Visual Basic or C#.  
  
   
  
## Examples  
 The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and IsFamilyAndAssembly properties.  
  
> [!NOTE]
>  The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes?displayProperty=fullName> visibility; that access level appears only in the C++ example.  
  
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/add/codesnippet/visualbasic/p-system.reflection.meth_8_1.vb)]
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/add/codesnippet/cpp/p-system.reflection.meth_8_1.cpp)]
 [!code-cs[Classic MethodBase.IsAssembly Example#1](~/add/codesnippet/csharp/p-system.reflection.meth_8_1.cs)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IsFamilyOrAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyOrAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyOrAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the potential visibility of this method or constructor is described by <see cref="T:System.Reflection.MethodAttributes" />; that is, the method or constructor can be called by derived classes wherever they are, and by classes in the same assembly.</summary>
        <value>
          <see langword="true" /> if access to this method or constructor is exactly described by <see cref="T:System.Reflection.MethodAttributes" />; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If a type member has <xref:System.Reflection.MethodAttributes?displayProperty=fullName>visibility, it can be called from any member in a derived class or any member in the same assembly, but not from any other type.  
  
 The actual visibility of a method is limited by the visibility of its type. The IsFamilyOrAssembly property might be `true` for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.  
  
 The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes?displayProperty=fullName> if the visibility modifier is `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++).  
  
   
  
## Examples  
 The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, IsFamilyOrAssembly, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.  
  
> [!NOTE]
>  The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes?displayProperty=fullName> visibility; that access level appears only in the C++ example.  
  
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/add/codesnippet/visualbasic/p-system.reflection.meth_7_1.vb)]
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/add/codesnippet/cpp/p-system.reflection.meth_7_1.cpp)]
 [!code-cs[Classic MethodBase.IsAssembly Example#1](~/add/codesnippet/csharp/p-system.reflection.meth_7_1.cs)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IsFinal">
      <MemberSignature Language="C#" Value="public bool IsFinal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFinal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether this method is <see langword="final" />.</summary>
        <value>
          <see langword="true" /> if this method is <see langword="final" />; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To determine if a method is overridable, it is not sufficient to check that <xref:System.Reflection.MethodBase.IsVirtual%2A> is `true`. For a method to be overridable, `IsVirtual` must be `true` and `IsFinal` must be `false`. For example, a method might be non-virtual, but it implements an interface method. The common language runtime requires that all methods that implement interface members must be marked as `virtual`; therefore, the compiler marks the method `virtual final`. So there are cases where a method is marked as `virtual` but is still not overridable.  
  
 To establish with certainty whether a method is overridable, use code such as this:  
  
 `if (MethodInfo.IsVirtual && !MethodInfo.IsFinal)`  
  
 If `IsVirtual` is `false` or `IsFinal` is `true`, then the method cannot be overridden.  
  
   
  
## Examples  
 The following example displays `false` for `IsFinal`, which might lead you to think that MyMethod is overridable. The code prints `false` even though MyMethod is not marked `virtual` and thus cannot be overridden.  
  
 [!code-cs[Classic MethodBase.IsVirtual Example#1](~/add/codesnippet/csharp/p-system.reflection.meth_10_1.cs)]
 [!code-cpp[Classic MethodBase.IsVirtual Example#1](~/add/codesnippet/cpp/p-system.reflection.meth_10_1.cpp)]
 [!code-vb[Classic MethodBase.IsVirtual Example#1](~/add/codesnippet/visualbasic/p-system.reflection.meth_10_1.vb)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethod">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the method is generic.</summary>
        <value>
          <see langword="true" /> if the current <see cref="T:System.Reflection.MethodBase" /> represents a generic method; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use the IsGenericMethod property to determine whether the current <xref:System.Reflection.MethodBase> object represents a generic method. Use the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property to determine whether the current <xref:System.Reflection.MethodBase> object represents an open constructed method or a closed constructed method.  
  
> [!NOTE]
>  Generics are not supported by default; this property returns `false` if not overridden in a derived class. Generic constructors are not supported in the .NET Framework version 2.0, so this property returns `false` if the current instance is of type <xref:System.Reflection.ConstructorInfo>.  
  
 For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodInfo.IsGenericMethod%2A?displayProperty=fullName> property. For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=fullName> property.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the method is a generic method definition.</summary>
        <value>
          <see langword="true" /> if the current <see cref="T:System.Reflection.MethodBase" /> object represents the definition of a generic method; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If the current <xref:System.Reflection.MethodBase> represents a generic method definition, then:  
  
-   The IsGenericMethodDefinition property is `true`.  
  
-   For each <xref:System.Type> object in the array returned by the <xref:System.Reflection.MethodBase.GetGenericArguments%2A> method:  
  
    -   The <xref:System.Type.IsGenericParameter%2A?displayProperty=fullName> property is `true`.  
  
    -   The <xref:System.Type.DeclaringMethod%2A?displayProperty=fullName> property returns the current instance.  
  
    -   The <xref:System.Type.GenericParameterPosition%2A?displayProperty=fullName> property is the same as the position of the <xref:System.Type> object in the array.  
  
> [!NOTE]
>  Generics are not supported by default; this property returns `false` if not overridden in a derived class. Generic constructors are not supported in the .NET Framework version 2.0, so this property returns `false` if the current instance is of type <xref:System.Reflection.ConstructorInfo>.  
  
 For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodInfo.IsGenericMethod%2A?displayProperty=fullName> property. For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=fullName> property.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IsHideBySig">
      <MemberSignature Language="C#" Value="public bool IsHideBySig { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHideBySig" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether only a member of the same kind with exactly the same signature is hidden in the derived class.</summary>
        <value>
          <see langword="true" /> if the member is hidden by signature; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 When a member in a derived class is declared with the C# `new` modifier or the Visual Basic `Shadows` modifier, it can hide a member of the same name in the base class. C# hides base class members by signature. That is, if the base class member has multiple overloads, the only one that is hidden is the one that has the identical signature. By contrast, Visual Basic hides all the base class overloads. Thus, IsHideBySig returns `false` on a member declared with the Visual Basic `Shadows` modifier, and `true` on a member declared with the C# `new` modifier.  
  
> [!WARNING]
>  This property does not determine whether a method has the <xref:System.Reflection.MethodAttributes> attribute. A method that is declared with either the `new` or the `Shadows` modifier will have the <xref:System.Reflection.MethodAttributes> attribute, but only methods declared with `new` (that is, only C# methods) will have the IsHideBySig property set to `true`.  To determine whether a method has the <xref:System.Reflection.MethodAttributes> attribute, use code similar to the following: `if ((myMethodInfo.Attributes & MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)` in C# or `If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot` in Visual Basic. Note, however, that although all methods declared with `new` or `Shadows` have the <xref:System.Reflection.MethodAttributes> attribute, not all methods that have the <xref:System.Reflection.MethodAttributes> attribute are declared with `new` or `Shadows`.  
  
   
  
## Examples  
 The following code example contains a base class with an overloaded method, and a derived class that hides one of the overloads. In the Visual Basic version of the code example, the IsHideBySig property returns `false` for the member in the derived class. In the C# version of the code sample, the property returns `true` for the member in the derived class.  
  
 [!code-cpp[System.Reflection.MethodBase.IsHideBySig#1](~/add/codesnippet/cpp/p-system.reflection.meth_16_1.cpp)]
 [!code-cs[System.Reflection.MethodBase.IsHideBySig#1](~/add/codesnippet/csharp/p-system.reflection.meth_16_1.cs)]
 [!code-vb[System.Reflection.MethodBase.IsHideBySig#1](~/add/codesnippet/visualbasic/p-system.reflection.meth_16_1.vb)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IsPrivate">
      <MemberSignature Language="C#" Value="public bool IsPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrivate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether this member is private.</summary>
        <value>
          <see langword="true" /> if access to this method is restricted to other members of the class itself; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If a type member has `Private` level visibility, it can be called from any member in the same class and no others.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether this is a public method.</summary>
        <value>
          <see langword="true" /> if this method is public; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To get the <xref:System.Reflection.MethodBase>, first get the type. From the type, get the method. From the method, get the `MethodBase`. If the `MethodBase` or constructor is other than public, it is protected and cannot be readily accessed. To access a non-public method, set the <xref:System.Reflection.BindingFlags> mask to `NonPublic` in `GetMethod`.  
  
   
  
## Examples  
 The following example uses the IsPublic property to display a message that indicates whether the specified method is public.  
  
 [!code-vb[Classic MethodBase.IsPublic Example#1](~/add/codesnippet/visualbasic/p-system.reflection.meth_5_1.vb)]
 [!code-cpp[Classic MethodBase.IsPublic Example#1](~/add/codesnippet/cpp/p-system.reflection.meth_5_1.cpp)]
 [!code-cs[Classic MethodBase.IsPublic Example#1](~/add/codesnippet/csharp/p-system.reflection.meth_5_1.cs)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the current method or constructor is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</summary>
        <value>
          <see langword="true" /> if the current method or constructor is security-critical or security-safe-critical at the current trust level; <see langword="false" /> if it is transparent.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The IsSecurityCritical, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR). The combinations of these properties are shown in the following table:  
  
|Security level|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critical|`true`|`false`|`false`|  
|Safe critical|`true`|`true`|`false`|  
|Transparent|`false`|`false`|`true`|  
  
 Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.  
  
> [!IMPORTANT]
>  For partial-trust assemblies, the value of this property depends on the current trust level of the assembly. If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly. The assembly and all its types are treated as transparent. The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application). By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted. You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName> properties.  
  
 For more information about reflection and transparency, see [Security Considerations for Reflection](../Topic/Security%20Considerations%20for%20Reflection.md). For information about transparency, see [Security Changes](../Topic/Security%20Changes%20in%20the%20.NET%20Framework.md).  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the current method or constructor is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</summary>
        <value>
          <see langword="true" /> if the method or constructor is security-safe-critical at the current trust level; <see langword="false" /> if it is security-critical or transparent.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, IsSecuritySafeCritical, and <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR). The combinations of these properties are shown in the following table:  
  
|Security level|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critical|`true`|`false`|`false`|  
|Safe critical|`true`|`true`|`false`|  
|Transparent|`false`|`false`|`true`|  
  
 Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.  
  
> [!IMPORTANT]
>  For partial-trust assemblies, the value of this property depends on the current trust level of the assembly. If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly. The assembly and all its types are treated as transparent. The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application). By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted. You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName> properties.  
  
 For more information about reflection and transparency, see [Security Considerations for Reflection](../Topic/Security%20Considerations%20for%20Reflection.md). For information about transparency, see [Security Changes](../Topic/Security%20Changes%20in%20the%20.NET%20Framework.md).  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the current method or constructor is transparent at the current trust level, and therefore cannot perform critical operations.</summary>
        <value>
          <see langword="true" /> if the method or constructor is security-transparent at the current trust level; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If this property returns `true`, the <xref:System.Reflection.MethodBase.IsSecurityCritical%2A> and <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> properties return `false`.  
  
 The <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, and IsSecurityTransparent properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR). Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.  
  
> [!IMPORTANT]
>  For partial-trust assemblies, the value of this property depends on the current trust level of the assembly. If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly. The assembly and all its types are treated as transparent. The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application). By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted. You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName> properties.  
  
 For more information about reflection and transparency, see [Security Considerations for Reflection](../Topic/Security%20Considerations%20for%20Reflection.md). For information about transparency, see [Security Changes](../Topic/Security%20Changes%20in%20the%20.NET%20Framework.md).  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether this method has a special name.</summary>
        <value>
          <see langword="true" /> if this method has a special name; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Reflection.MethodAttributes> bit is set to flag members that are treated in a special way by some compilers (such as property accessors and operator overloading methods).  
  
   
  
## Examples  
 This example shows a use of IsSpecialName to filter internal or private members out of a list.  
  
 [!code-cpp[Classic Type.IsSpecialName Example#1](~/add/codesnippet/cpp/p-system.reflection.meth_4_1.cpp)]
 [!code-cs[Classic Type.IsSpecialName Example#1](~/add/codesnippet/csharp/p-system.reflection.meth_4_1.cs)]
 [!code-vb[Classic Type.IsSpecialName Example#1](~/add/codesnippet/visualbasic/p-system.reflection.meth_4_1.vb)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IsStatic">
      <MemberSignature Language="C#" Value="public bool IsStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStatic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the method is <see langword="static" />.</summary>
        <value>
          <see langword="true" /> if this method is <see langword="static" />; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A static member cannot implicitly reference instance data in a class.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IsVirtual">
      <MemberSignature Language="C#" Value="public bool IsVirtual { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVirtual" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the method is <see langword="virtual" />.</summary>
        <value>
          <see langword="true" /> if this method is <see langword="virtual" />; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A virtual member may reference instance data in a class and must be referenced through an instance of the class.  
  
 To determine if a method is overridable, it is not sufficient to check that `IsVirtual` is `true`. For a method to be overridable, `IsVirtual` must be `true` and <xref:System.Reflection.MethodBase.IsFinal%2A> must be `false`. For example, a method might be non-virtual, but it implements an interface method. The common language runtime requires that all methods that implement interface members must be marked as `virtual`; therefore, the compiler marks the method `virtual final`. So there are cases where a method is marked as `virtual` but is still not overridable.  
  
 To establish with certainty whether a method is overridable, use code such as this:  
  
```c#  
if (MethodInfo.IsVirtual && !MethodInfo.IsFinal)  
```  
  
```vb  
If MethodInfo.IsVirtual AndAlso Not MethodInfo.IsFinal Then  
```  
  
 If `IsVirtual` is `false` or `IsFinal` is `true`, then the method cannot be overridden.  
  
 You can determine whether the current method overrides a method in a base class by calling the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A?displayProperty=fullName> method. The following example implements an `IsOverride` method that does this.  
  
 [!code-cs[system.reflection.methodinfo.getbasedefinition#2](~/add/codesnippet/csharp/p-system.reflection.meth_6_1.cs)]
 [!code-vb[system.reflection.methodinfo.getbasedefinition#2](~/add/codesnippet/visualbasic/p-system.reflection.meth_6_1.vb)]  
  
   
  
## Examples  
 The following example displays `false` for `IsFinal`, which might lead you to think that `MyMethod` is overridable. The code prints `false` even though `MyMethod` is not marked `virtual` and thus cannot be overridden.  
  
 [!code-cs[Classic MethodBase.IsVirtual Example#1](~/add/codesnippet/csharp/p-system.reflection.meth_6_2.cs)]
 [!code-cpp[Classic MethodBase.IsVirtual Example#1](~/add/codesnippet/cpp/p-system.reflection.meth_6_2.cpp)]
 [!code-vb[Classic MethodBase.IsVirtual Example#1](~/add/codesnippet/visualbasic/p-system.reflection.meth_6_2.vb)]  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public abstract RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a handle to the internal metadata representation of a method.</summary>
        <value>A <see cref="T:System.RuntimeMethodHandle" /> object.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The handles are valid only in the application domain in which they were obtained.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Reflection.MethodImplAttributes" /> flags that specify the attributes of a method implementation.</summary>
        <value>The method implementation flags.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 See the <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> method for more information.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool op_Equality (System.Reflection.MethodBase left, System.Reflection.MethodBase right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.MethodBase left, class System.Reflection.MethodBase right) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodBase" />
        <Parameter Name="right" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="left">The first object to compare.</param>
        <param name="right">The second object to compare.</param>
        <summary>Indicates whether two <see cref="T:System.Reflection.MethodBase" /> objects are equal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool op_Inequality (System.Reflection.MethodBase left, System.Reflection.MethodBase right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.MethodBase left, class System.Reflection.MethodBase right) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodBase" />
        <Parameter Name="right" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="left">The first object to compare.</param>
        <param name="right">The second object to compare.</param>
        <summary>Indicates whether two <see cref="T:System.Reflection.MethodBase" /> objects are not equal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _MethodBase.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetIDsOfNames(valuetype System.Guid riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Reserved for future use. Must be IID_NULL.</param>
        <param name="rgszNames">Passed-in array of names to be mapped.</param>
        <param name="cNames">Count of the names to be mapped.</param>
        <param name="lcid">The locale context in which to interpret the names.</param>
        <param name="rgDispId">Caller-allocated array which receives the IDs corresponding to the names.</param>
        <summary>Maps a set of names to a corresponding set of dispatch identifiers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Late-bound access using the COM `IDispatch` interface is not supported.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetType">
      <MemberSignature Language="C#" Value="Type _MethodBase.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._MethodBase.GetType() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>For a description of this member, see <see cref="System.Runtime.InteropServices._MethodBase.GetType%2A" />.</summary>
        <returns>For a description of this member, see <see cref="System.Runtime.InteropServices._MethodBase.GetType%2A" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _MethodBase.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">The type information to return.</param>
        <param name="lcid">The locale identifier for the type information.</param>
        <param name="ppTInfo">Receives a pointer to the requested type information object.</param>
        <summary>Retrieves the type information for an object, which can then be used to get the type information for an interface.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Late-bound access using the COM `IDispatch` interface is not supported.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _MethodBase.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetTypeInfoCount(unsigned int32 pcTInfo) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Points to a location that receives the number of type information interfaces provided by the object.</param>
        <summary>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Late-bound access using the COM `IDispatch` interface is not supported.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.Invoke">
      <MemberSignature Language="C#" Value="void _MethodBase.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.Invoke(unsigned int32 dispIdMember, valuetype System.Guid riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identifies the member.</param>
        <param name="riid">Reserved for future use. Must be IID_NULL.</param>
        <param name="lcid">The locale context in which to interpret arguments.</param>
        <param name="wFlags">Flags describing the context of the call.</param>
        <param name="pDispParams">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</param>
        <param name="pVarResult">Pointer to the location where the result is to be stored.</param>
        <param name="pExcepInfo">Pointer to a structure that contains exception information.</param>
        <param name="puArgErr">The index of the first argument that has an error.</param>
        <summary>Provides access to properties and methods exposed by an object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about `IDispatch::Invoke`, see the MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Late-bound access using the COM `IDispatch` interface is not supported.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsAbstract">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsAbstract" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>For a description of this member, see <see cref="System.Runtime.InteropServices._MethodBase.IsAbstract%2A" />.</summary>
        <value>For a description of this member, see <see cref="System.Runtime.InteropServices._MethodBase.IsAbstract%2A" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>For a description of this member, see <see cref="System.Runtime.InteropServices._MethodBase.IsAssembly%2A" />.</summary>
        <value>For a description of this member, see <see cref="System.Runtime.InteropServices._MethodBase.IsAssembly%2A" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsConstructor">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsConstructor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsConstructor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>For a description of this member, see <see cref="System.Runtime.InteropServices._MethodBase.IsConstructor%2A" />.</summary>
        <value>For a description of this member, see <see cref="System.Runtime.InteropServices._MethodBase.IsConstructor%2A" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamily">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>For a description of this member, see <see cref="System.Runtime.InteropServices._MethodBase.IsFamily%2A" />.</summary>
        <value>For a description of this member, see <see cref="System.Runtime.InteropServices._MethodBase.IsFamily%2A" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>For a description of this member, see <see cref="System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly%2A" />.</summary>
        <value>For a description of this member, see <see cref="System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly%2A" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>For a description of this member, see <see cref="System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly%2A" />.</summary>
        <value>For a description of this member, see <see cref="System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly%2A" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFinal">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFinal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFinal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>For a description of this member, see <see cref="System.Runtime.InteropServices._MethodBase.IsFinal%2A" />.</summary>
        <value>For a description of this member, see <see cref="System.Runtime.InteropServices._MethodBase.IsFinal%2A" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsHideBySig">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsHideBySig { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsHideBySig" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>For a description of this member, see <see cref="System.Runtime.InteropServices._MethodBase.IsHideBySig%2A" />.</summary>
        <value>For a description of this member, see <see cref="System.Runtime.InteropServices._MethodBase.IsHideBySig%2A" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsPrivate">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsPrivate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>For a description of this member, see <see cref="System.Runtime.InteropServices._MethodBase.IsPrivate%2A" />.</summary>
        <value>For a description of this member, see <see cref="System.Runtime.InteropServices._MethodBase.IsPrivate%2A" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsPublic">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>For a description of this member, see <see cref="System.Runtime.InteropServices._MethodBase.IsPublic%2A" />.</summary>
        <value>For a description of this member, see <see cref="System.Runtime.InteropServices._MethodBase.IsPublic%2A" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsSpecialName">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsSpecialName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>For a description of this member, see <see cref="System.Runtime.InteropServices._MethodBase.IsSpecialName%2A" />.</summary>
        <value>For a description of this member, see <see cref="System.Runtime.InteropServices._MethodBase.IsSpecialName%2A" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsStatic">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsStatic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>For a description of this member, see <see cref="System.Runtime.InteropServices._MethodBase.IsStatic%2A" />.</summary>
        <value>For a description of this member, see <see cref="System.Runtime.InteropServices._MethodBase.IsStatic%2A" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsVirtual">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsVirtual { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsVirtual" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>For a description of this member, see <see cref="System.Runtime.InteropServices._MethodBase.IsVirtual%2A" />.</summary>
        <value>For a description of this member, see <see cref="System.Runtime.InteropServices._MethodBase.IsVirtual%2A" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
  </Members>
</Type>