<Type Name="AssemblyBuilder" FullName="System.Reflection.Emit.AssemblyBuilder">
  <TypeSignature Language="C#" Value="public sealed class AssemblyBuilder : System.Reflection.Assembly, System.Runtime.InteropServices._AssemblyBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit AssemblyBuilder extends System.Reflection.Assembly implements class System.Runtime.InteropServices._AssemblyBuilder" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.Assembly</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._AssemblyBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._AssemblyBuilder))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Defines and represents a dynamic assembly.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A dynamic assembly is an assembly that is created using the Reflection Emit APIs. The dynamic modules in the assembly are saved when the dynamic assembly is saved using the <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> method. To generate an executable, the <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> method must be called to identify the method that is the entry point to the assembly. Assemblies are saved as DLLs by default, unless the <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A> method requests the generation of a console application or a Windows-based application.  
  
 If a dynamic assembly contains more than one dynamic module, the assembly's manifest file name should match the module's name that is specified as the first argument to the <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> method.  
  
 Some methods on the base <xref:System.Reflection.Assembly> class, such as `GetModules` and `GetLoadedModules`, will not work correctly when called from AssemblyBuilder objects. You can load the defined dynamic assembly and call the methods on the loaded assembly. For example, to ensure that resource modules are included in the returned module list, call `GetModules` on the loaded <xref:System.Reflection.Assembly> object.  
  
 The signing of a dynamic assembly using <xref:System.Reflection.AssemblyName.KeyPair%2A> is not effective until the assembly is saved to disk. So, strong names will not work with transient dynamic assemblies.  
  
 To get an AssemblyBuilder object, use the <xref:System.AppDomain.DefineDynamicAssembly%2A?displayProperty=fullName> method.  
  
## Reflection emit dynamic assembly scenarios  
 The following are some things to consider when using the AssemblyBuilder class to create dynamic assemblies.  
  
### Dynamic modules  
 Reflection emit supports the creation of dynamic modules defined in dynamic assemblies. A dynamic module created in a dynamic assembly can be transient or persistable.  
  
### Restrictions on type references  
 Assemblies can reference types defined in another assembly. A transient dynamic assembly can safely reference types defined in another transient dynamic assembly, a persistable dynamic assembly, or a static assembly. However, the common language runtime does not allow a persistable dynamic module to reference a type defined in a transient dynamic module. This is because when the persisted dynamic module is loaded after being saved to disk, the runtime cannot resolve the references to types defined in the transient dynamic module.  
  
### Restrictions on emitting to remote application domains  
 Some scenarios require a dynamic assembly to be created and executed in a remote application domain. Reflection emit does not allow a dynamic assembly to be emitted directly to a remote application domain. The solution is to emit the dynamic assembly in the current application domain, save the emitted dynamic assembly to disk, and then load the dynamic assembly into the remote application domain.  
  
### Dynamic assembly access modes  
 Dynamic assemblies can be created using one of the following access modes:  
  
-   <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=fullName>  
  
     The dynamic assembly represented by an AssemblyBuilder object is transient. The dynamic assembly can only be used to execute the emitted code.  
  
-   <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=fullName>  
  
     The dynamic assembly represented by an AssemblyBuilder object is persistable but cannot be executed until the saved portable executable (PE) file has been loaded from disk.  
  
-   <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=fullName>  
  
     The dynamic assembly represented by an AssemblyBuilder object is persistable, but can also be executed before and/or after the assembly is saved to disk.  
  
 The access mode must be specified by providing the appropriate <xref:System.Reflection.Emit.AssemblyBuilderAccess> value in the call to the <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicAssembly%2A?displayProperty=fullName> method when the dynamic assembly is defined and cannot be changed later. The runtime uses the access mode of a dynamic assembly to optimize the assembly's internal representation.  
  
   
  
## Examples  
 The following code example shows how to define a dynamic assembly with one module. The module in the example assembly contains one type, `MyDynamicType`, which has a private field, a property that gets and sets the private field, constructors that initialize the private field, and a method that multiplies a user-supplied number by the private field value and returns the result.  
  
 <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=fullName> is specified when the assembly is created. The assembly code is used immediately, and the assembly is also saved to disk so that it can be examined with [Ildasm.exe (IL Disassembler)](../Topic/Ildasm.exe%20\(IL%20Disassembler\).md) or used in another program.  
  
 [!code-vb[AssemblyBuilderClass#1](~/add/codesnippet/visualbasic/t-system.reflection.emit_1_1.vb)]
 [!code-cpp[AssemblyBuilderClass#1](~/add/codesnippet/cpp/t-system.reflection.emit_1_1.cpp)]
 [!code-cs[AssemblyBuilderClass#1](~/add/codesnippet/csharp/t-system.reflection.emit_1_1.cs)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
    <threadsafe />
  </Docs>
  <Members>
    <Member MemberName="AddResourceFile">
      <MemberSignature Language="C#" Value="public void AddResourceFile (string name, string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddResourceFile(string name, string fileName) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The logical name of the resource.</param>
        <param name="fileName">The physical file name (.resources file) to which the logical name is mapped. This should not include a path; the file must be in the same directory as the assembly to which it is added.</param>
        <summary>Adds an existing resource file to this assembly.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `fileName` should not be the same as that of any other persistable module, standalone managed resource, or the standalone manifest file.  
  
 The managed resources in the file are assumed to be public.  
  
 The specified resource file must be in the directory where the assembly will be saved.  
  
> [!NOTE]
>  Starting with the [!INCLUDE[net_v20sp1_long](~/add/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag. (See [Security Issues in Reflection Emit](../Topic/Security%20Issues%20in%20Reflection%20Emit.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/add/includes/net-v35-long-md.md)] or later.  
  
   
  
## Examples  
 The following code sample demonstrates how to attach a resource file to a dynamically created assembly, using `AddResourceFile`.  
  
 [!code-cpp[System.Reflection.Emit.AssemblyBuilder.AddResourceFile Example#1](~/add/codesnippet/cpp/b26364cc-0c47-4dc7-b969-_1.cpp)]
 [!code-cs[System.Reflection.Emit.AssemblyBuilder.AddResourceFile Example#1](~/add/codesnippet/csharp/b26364cc-0c47-4dc7-b969-_1.cs)]
 [!code-vb[System.Reflection.Emit.AssemblyBuilder.AddResourceFile Example#1](~/add/codesnippet/visualbasic/b26364cc-0c47-4dc7-b969-_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> has been previously defined.  
  
 -or-  
  
 There is another file in the assembly named <paramref name="fileName" />.  
  
 -or-  
  
 The length of <paramref name="name" /> is zero.  
  
 -or-  
  
 The length of <paramref name="fileName" /> is zero, or if <paramref name="fileName" /> includes a path.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> or <paramref name="fileName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The file <paramref name="fileName" /> is not found.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">The FileIOPermissionAccess.Read permission is needed to access the resource file <paramref name="resourceFileName" />.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="AddResourceFile">
      <MemberSignature Language="C#" Value="public void AddResourceFile (string name, string fileName, System.Reflection.ResourceAttributes attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddResourceFile(string name, string fileName, valuetype System.Reflection.ResourceAttributes attribute) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="attribute" Type="System.Reflection.ResourceAttributes" />
      </Parameters>
      <Docs>
        <param name="name">The logical name of the resource.</param>
        <param name="fileName">The physical file name (.resources file) to which the logical name is mapped. This should not include a path; the file must be in the same directory as the assembly to which it is added.</param>
        <param name="attribute">The resource attributes.</param>
        <summary>Adds an existing resource file to this assembly.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `fileName` should not be the same as that of any other persistable module, standalone managed resource, or the standalone manifest file.  
  
 Attributes can be specified for the managed resource.  
  
 The specified resource file must be in the directory where the assembly will be saved.  
  
> [!NOTE]
>  Starting with the [!INCLUDE[net_v20sp1_long](~/add/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag. (See [Security Issues in Reflection Emit](../Topic/Security%20Issues%20in%20Reflection%20Emit.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/add/includes/net-v35-long-md.md)] or later.  
  
   
  
## Examples  
 The following code sample demonstrates how to attach a resource file to a dynamically created assembly, using `AddResourceFile`.  
  
 [!code-cpp[System.Reflection.Emit.AssemblyBuilder.AddResourceFile Example#1](~/add/codesnippet/cpp/52d62565-36a7-44e7-bbf0-_1.cpp)]
 [!code-cs[System.Reflection.Emit.AssemblyBuilder.AddResourceFile Example#1](~/add/codesnippet/csharp/52d62565-36a7-44e7-bbf0-_1.cs)]
 [!code-vb[System.Reflection.Emit.AssemblyBuilder.AddResourceFile Example#1](~/add/codesnippet/visualbasic/52d62565-36a7-44e7-bbf0-_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> has been previously defined.  
  
 -or-  
  
 There is another file in the assembly named <paramref name="fileName" />.  
  
 -or-  
  
 The length of <paramref name="name" /> is zero or if the length of <paramref name="fileName" /> is zero.  
  
 -or-  
  
 <paramref name="fileName" /> includes a path.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> or <paramref name="fileName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">If the file <paramref name="fileName" /> is not found.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">The FileIOPermissionAccess.Read permission is needed to access the resource file <paramref name="resourceFileName" />.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="CodeBase">
      <MemberSignature Language="C#" Value="public override string CodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CodeBase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the location of the assembly, as specified originally (such as in an <see cref="T:System.Reflection.AssemblyName" /> object).</summary>
        <value>The location of the assembly, as specified originally.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To get the absolute path to the loaded manifest-containing file, use the <xref:System.Reflection.Assembly.Location%2A?displayProperty=fullName> property.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">This method is not currently supported.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
      </Parameters>
      <Docs>
        <param name="name">The name of the assembly.</param>
        <param name="access">The access rights of the assembly.</param>
        <summary>Defines a dynamic assembly that has the specified name and access rights.</summary>
        <returns>An object that represents the new assembly.</returns>
        <remarks>To be added.</remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">The name of the assembly.</param>
        <param name="access">The access rights of the assembly.</param>
        <param name="assemblyAttributes">A collection that contains the attributes of the assembly.</param>
        <summary>Defines a new assembly that has the specified name, access rights, and attributes.</summary>
        <returns>An object that represents the new assembly.</returns>
        <remarks>To be added.</remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ModuleBuilder DefineDynamicModule (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ModuleBuilder DefineDynamicModule(string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ModuleBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dynamic module. Must be less than 260 characters in length.</param>
        <summary>Defines a named transient dynamic module in this assembly.</summary>
        <returns>A <see cref="T:System.Reflection.Emit.ModuleBuilder" /> representing the defined dynamic module.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 It is an error to define multiple dynamic modules with the same name in an assembly.  
  
 The defined dynamic module is transient. The dynamic module is not saved, even if the parent dynamic assembly was created with <xref:System.Reflection.Emit.AssemblyBuilderAccess>.  
  
> [!NOTE]
>  To suppress optimizations when debugging dynamic modules, apply the <xref:System.Diagnostics.DebuggableAttribute> attribute to the dynamic assembly before calling <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>. Create an instance of <xref:System.Diagnostics.DebuggableAttribute> with the <xref:System.Diagnostics.DebuggableAttribute.DebuggingModes> flag and apply it using the <xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A> method. The attribute must be applied to the dynamic assembly. It has no effect if applied to the module.  
  
> [!NOTE]
>  Starting with the [!INCLUDE[net_v20sp1_long](~/add/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag. (See [Security Issues in Reflection Emit](../Topic/Security%20Issues%20in%20Reflection%20Emit.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/add/includes/net-v35-long-md.md)] or later.  
  
   
  
## Examples  
 [Visual Basic, C#]  
  
 The code example below demonstrates how to create a transient dynamic module using `DefineDynamicModule`.  
  
 [!code-cpp[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example#1](~/add/codesnippet/cpp/m-system.reflection.emit_47_1.cpp)]
 [!code-cs[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example#1](~/add/codesnippet/csharp/m-system.reflection.emit_47_1.cs)]
 [!code-vb[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example#1](~/add/codesnippet/visualbasic/m-system.reflection.emit_47_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> begins with white space.  
  
 -or-  
  
 The length of <paramref name="name" /> is zero.  
  
 -or-  
  
 The length of <paramref name="name" /> is greater than or equal to 260.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <exception cref="T:System.ExecutionEngineException">The assembly for default symbol writer cannot be loaded.  
  
 -or-  
  
 The type that implements the default symbol writer interface cannot be found.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ModuleBuilder DefineDynamicModule (string name, bool emitSymbolInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ModuleBuilder DefineDynamicModule(string name, bool emitSymbolInfo) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ModuleBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="emitSymbolInfo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dynamic module. Must be less than 260 characters in length.</param>
        <param name="emitSymbolInfo">
          <see langword="true" /> if symbol information is to be emitted; otherwise, <see langword="false" />.</param>
        <summary>Defines a named transient dynamic module in this assembly and specifies whether symbol information should be emitted.</summary>
        <returns>A <see cref="T:System.Reflection.Emit.ModuleBuilder" /> representing the defined dynamic module.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 It is an error to define multiple dynamic modules with the same name in an assembly.  
  
 The dynamic module is not saved, even if the parent dynamic assembly was created with <xref:System.Reflection.Emit.AssemblyBuilderAccess>.  
  
> [!NOTE]
>  To suppress optimizations when debugging dynamic modules, apply the <xref:System.Diagnostics.DebuggableAttribute> attribute to the dynamic assembly before calling <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>. Create an instance of <xref:System.Diagnostics.DebuggableAttribute> with the <xref:System.Diagnostics.DebuggableAttribute.DebuggingModes> flag and apply it using the <xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A> method. The attribute must be applied to the dynamic assembly. It has no effect if applied to the module.  
  
> [!NOTE]
>  Starting with the [!INCLUDE[net_v20sp1_long](~/add/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag. (See [Security Issues in Reflection Emit](../Topic/Security%20Issues%20in%20Reflection%20Emit.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/add/includes/net-v35-long-md.md)] or later.  
  
   
  
## Examples  
 [Visual Basic, C#]  
  
 The code example below demonstrates how to create a transient dynamic module using `DefineDynamicModule`, suppressing symbol information.  
  
 [!code-cpp[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example#2](~/add/codesnippet/cpp/cc7727b8-7d85-4337-aa0a-_1.cpp)]
 [!code-cs[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example#2](~/add/codesnippet/csharp/cc7727b8-7d85-4337-aa0a-_1.cs)]
 [!code-vb[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example#2](~/add/codesnippet/visualbasic/cc7727b8-7d85-4337-aa0a-_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> begins with white space.  
  
 -or-  
  
 The length of <paramref name="name" /> is zero.  
  
 -or-  
  
 The length of <paramref name="name" /> is greater than or equal to 260.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ExecutionEngineException">The assembly for default symbol writer cannot be loaded.  
  
 -or-  
  
 The type that implements the default symbol writer interface cannot be found.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ModuleBuilder DefineDynamicModule (string name, string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ModuleBuilder DefineDynamicModule(string name, string fileName) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ModuleBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dynamic module. Must be less than 260 characters in length.</param>
        <param name="fileName">The name of the file to which the dynamic module should be saved.</param>
        <summary>Defines a persistable dynamic module with the given name that will be saved to the specified file. No symbol information is emitted.</summary>
        <returns>A <see cref="T:System.Reflection.Emit.ModuleBuilder" /> object representing the defined dynamic module.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To define a persistable dynamic module, this assembly needs to be created with the <xref:System.Reflection.Emit.AssemblyBuilderAccess> or the <xref:System.Reflection.Emit.AssemblyBuilderAccess> attribute.  
  
 If you want the module to contain the assembly manifest, `name` should be the same as the name of the assembly (that is, the <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=fullName> property of the <xref:System.Reflection.AssemblyName> used to create the dynamic assembly) and `fileName` should be the same as the filename you specify when you save the assembly.  
  
 In an assembly with only one module, that module should contain the assembly manifest.  
  
> [!NOTE]
>  To suppress optimizations when debugging dynamic modules, apply the <xref:System.Diagnostics.DebuggableAttribute> attribute to the dynamic assembly before calling <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>. Create an instance of <xref:System.Diagnostics.DebuggableAttribute> with the <xref:System.Diagnostics.DebuggableAttribute.DebuggingModes> flag and apply it using the <xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A> method. The attribute must be applied to the dynamic assembly. It has no effect if applied to the module.  
  
> [!NOTE]
>  Starting with the [!INCLUDE[net_v20sp1_long](~/add/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag. (See [Security Issues in Reflection Emit](../Topic/Security%20Issues%20in%20Reflection%20Emit.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/add/includes/net-v35-long-md.md)] or later.  
  
   
  
## Examples  
 [Visual Basic, C#]  
  
 The code example below demonstrates how to create a persistent dynamic module using `DefineDynamicModule`.  
  
 [!code-cpp[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example#3](~/add/codesnippet/cpp/838a38f1-f026-4d3d-89f1-_1.cpp)]
 [!code-cs[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example#3](~/add/codesnippet/csharp/838a38f1-f026-4d3d-89f1-_1.cs)]
 [!code-vb[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example#3](~/add/codesnippet/visualbasic/838a38f1-f026-4d3d-89f1-_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> or <paramref name="fileName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The length of <paramref name="name" /> or <paramref name="fileName" /> is zero.  
  
 -or-  
  
 The length of <paramref name="name" /> is greater than or equal to 260.  
  
 -or-  
  
 <paramref name="fileName" /> contains a path specification (a directory component, for example).  
  
 -or-  
  
 There is a conflict with the name of another file that belongs to this assembly.</exception>
        <exception cref="T:System.InvalidOperationException">This assembly has been previously saved.</exception>
        <exception cref="T:System.NotSupportedException">This assembly was called on a dynamic assembly with <see cref="T:System.Reflection.Emit.AssemblyBuilderAccess" /> attribute.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <exception cref="T:System.ExecutionEngineException">The assembly for default symbol writer cannot be loaded.  
  
 -or-  
  
 The type that implements the default symbol writer interface cannot be found.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Write=true or Append=true is needed to save the module</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ModuleBuilder DefineDynamicModule (string name, string fileName, bool emitSymbolInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ModuleBuilder DefineDynamicModule(string name, string fileName, bool emitSymbolInfo) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ModuleBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="emitSymbolInfo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dynamic module. Must be less than 260 characters in length.</param>
        <param name="fileName">The name of the file to which the dynamic module should be saved.</param>
        <param name="emitSymbolInfo">If <see langword="true" />, symbolic information is written using the default symbol writer.</param>
        <summary>Defines a persistable dynamic module, specifying the module name, the name of the file to which the module will be saved, and whether symbol information should be emitted using the default symbol writer.</summary>
        <returns>A <see cref="T:System.Reflection.Emit.ModuleBuilder" /> object representing the defined dynamic module.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To define a persistable dynamic module, this assembly needs to be created with the <xref:System.Reflection.Emit.AssemblyBuilderAccess> or the <xref:System.Reflection.Emit.AssemblyBuilderAccess> attribute.  
  
 If you want the module to contain the assembly manifest, `name` should be the same as the name of the assembly (that is, the <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=fullName> property of the <xref:System.Reflection.AssemblyName> used to create the dynamic assembly) and `fileName` should be the same as the filename you specify when you save the assembly.  
  
 In an assembly with only one module, that module should contain the assembly manifest.  
  
> [!NOTE]
>  To suppress optimizations when debugging dynamic modules, apply the <xref:System.Diagnostics.DebuggableAttribute> attribute to the dynamic assembly before calling <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>. Create an instance of <xref:System.Diagnostics.DebuggableAttribute> with the <xref:System.Diagnostics.DebuggableAttribute.DebuggingModes> flag and apply it using the <xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A> method. The attribute must be applied to the dynamic assembly. It has no effect if applied to the module.  
  
> [!NOTE]
>  Starting with the [!INCLUDE[net_v20sp1_long](~/add/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag. (See [Security Issues in Reflection Emit](../Topic/Security%20Issues%20in%20Reflection%20Emit.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/add/includes/net-v35-long-md.md)] or later.  
  
   
  
## Examples  
 [Visual Basic, C#]  
  
 The code example below demonstrates how to create a persistent dynamic module with symbol emission using `DefineDynamicModule`.  
  
 [!code-cpp[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example#4](~/add/codesnippet/cpp/ca7a3c95-a913-494c-9f7f-_1.cpp)]
 [!code-cs[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example#4](~/add/codesnippet/csharp/ca7a3c95-a913-494c-9f7f-_1.cs)]
 [!code-vb[System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule Example#4](~/add/codesnippet/visualbasic/ca7a3c95-a913-494c-9f7f-_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> or <paramref name="fileName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The length of <paramref name="name" /> or <paramref name="fileName" /> is zero.  
  
 -or-  
  
 The length of <paramref name="name" /> is greater than or equal to 260.  
  
 -or-  
  
 <paramref name="fileName" /> contains a path specification (a directory component, for example).  
  
 -or-  
  
 There is a conflict with the name of another file that belongs to this assembly.</exception>
        <exception cref="T:System.InvalidOperationException">This assembly has been previously saved.</exception>
        <exception cref="T:System.NotSupportedException">This assembly was called on a dynamic assembly with the <see cref="T:System.Reflection.Emit.AssemblyBuilderAccess" /> attribute.</exception>
        <exception cref="T:System.ExecutionEngineException">The assembly for default symbol writer cannot be loaded.  
  
 -or-  
  
 The type that implements the default symbol writer interface cannot be found.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Write=true or Append=true is needed to save this module</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="DefineResource">
      <MemberSignature Language="C#" Value="public System.Resources.IResourceWriter DefineResource (string name, string description, string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Resources.IResourceWriter DefineResource(string name, string description, string fileName) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.IResourceWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The logical name of the resource.</param>
        <param name="description">A textual description of the resource.</param>
        <param name="fileName">The physical file name (.resources file) to which the logical name is mapped. This should not include a path.</param>
        <summary>Defines a standalone managed resource for this assembly with the default public resource attribute.</summary>
        <returns>A <see cref="T:System.Resources.ResourceWriter" /> object for the specified resource.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Fine grain resources can be added with the returned <xref:System.Resources.ResourceWriter> by calling <xref:System.Resources.ResourceWriter.AddResource%2A>.  
  
 `fileName` should not be the same as that of any other persistable module, stand-alone managed resource, or the stand-alone manifest file.  
  
 The runtime calls the <xref:System.Resources.ResourceWriter.Close%2A> method when the dynamic assembly is saved.  
  
> [!NOTE]
>  Starting with the [!INCLUDE[net_v20sp1_long](~/add/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag. (See [Security Issues in Reflection Emit](../Topic/Security%20Issues%20in%20Reflection%20Emit.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/add/includes/net-v35-long-md.md)] or later.  
  
   
  
## Examples  
 The following example uses the DefineResource method to get a resource writer. The example uses the resource writer to add three resource strings.  
  
 [!code-cpp[AssemblyBuilder.DefineResource Example 2#1](~/add/codesnippet/cpp/c4267784-b13b-4208-8221-_1.cpp)]
 [!code-vb[AssemblyBuilder.DefineResource Example 2#1](~/add/codesnippet/visualbasic/c4267784-b13b-4208-8221-_1.vb)]
 [!code-cs[AssemblyBuilder.DefineResource Example 2#1](~/add/codesnippet/csharp/c4267784-b13b-4208-8221-_1.cs)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> has been previously defined.  
  
 -or-  
  
 There is another file in the assembly named <paramref name="fileName" />.  
  
 -or-  
  
 The length of <paramref name="name" /> is zero.  
  
 -or-  
  
 The length of <paramref name="fileName" /> is zero.  
  
 -or-  
  
 <paramref name="fileName" /> includes a path.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> or <paramref name="fileName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Write=true or Append=true</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="DefineResource">
      <MemberSignature Language="C#" Value="public System.Resources.IResourceWriter DefineResource (string name, string description, string fileName, System.Reflection.ResourceAttributes attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Resources.IResourceWriter DefineResource(string name, string description, string fileName, valuetype System.Reflection.ResourceAttributes attribute) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.IResourceWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="attribute" Type="System.Reflection.ResourceAttributes" />
      </Parameters>
      <Docs>
        <param name="name">The logical name of the resource.</param>
        <param name="description">A textual description of the resource.</param>
        <param name="fileName">The physical file name (.resources file) to which the logical name is mapped. This should not include a path.</param>
        <param name="attribute">The resource attributes.</param>
        <summary>Defines a standalone managed resource for this assembly. Attributes can be specified for the managed resource.</summary>
        <returns>A <see cref="T:System.Resources.ResourceWriter" /> object for the specified resource.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Fine-grain resources can be added with the returned <xref:System.Resources.ResourceWriter> by calling <xref:System.Resources.ResourceWriter.AddResource%2A>.  
  
 `fileName` should not be the same as that of any other persistable module, standalone managed resource, or the standalone manifest file.  
  
 The runtime calls the <xref:System.Resources.ResourceWriter.Close%2A> method when the dynamic assembly is saved.  
  
> [!NOTE]
>  Starting with the [!INCLUDE[net_v20sp1_long](~/add/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag. (See [Security Issues in Reflection Emit](../Topic/Security%20Issues%20in%20Reflection%20Emit.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/add/includes/net-v35-long-md.md)] or later.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> has been previously defined or if there is another file in the assembly named <paramref name="fileName" />.  
  
 -or-  
  
 The length of <paramref name="name" /> is zero.  
  
 -or-  
  
 The length of <paramref name="fileName" /> is zero.  
  
 -or-  
  
 <paramref name="fileName" /> includes a path.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> or <paramref name="fileName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Write=true or Append=true</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="DefineUnmanagedResource">
      <MemberSignature Language="C#" Value="public void DefineUnmanagedResource (byte[] resource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineUnmanagedResource(unsigned int8[] resource) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resource" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="resource">The opaque blob of bytes representing the unmanaged resource.</param>
        <summary>Defines an unmanaged resource for this assembly as an opaque blob of bytes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 An assembly can be associated with only one unmanaged resource. This means that calling <xref:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource%2A> or DefineUnmanagedResource after either one of the methods was called previously will throw the System.ArgumentException being throw. Multiple unmanaged resources need to be merged with a tool such as the Microsoft ResMerge utility (not supplied with the common language runtime).  
  
   
  
## Examples  
 The following code sample creates and attaches an array of bytes representing an unmanaged resource to a dynamic assembly, using `DefineUnmanagedResource`.  
  
 [!code-cs[AssemblyBuilder_DefineUnmanagedResource2#1](~/add/codesnippet/csharp/m-system.reflection.emit_20_1.cs)]
 [!code-cpp[AssemblyBuilder_DefineUnmanagedResource2#1](~/add/codesnippet/cpp/m-system.reflection.emit_20_1.cpp)]
 [!code-vb[AssemblyBuilder_DefineUnmanagedResource2#1](~/add/codesnippet/visualbasic/m-system.reflection.emit_20_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">An unmanaged resource was previously defined.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resource" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="DefineUnmanagedResource">
      <MemberSignature Language="C#" Value="public void DefineUnmanagedResource (string resourceFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineUnmanagedResource(string resourceFileName) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceFileName">The name of the resource file.</param>
        <summary>Defines an unmanaged resource file for this assembly given the name of the resource file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 An assembly can be associated with only one unmanaged resource. This means that calling <xref:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource%2A> or <xref:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource%2A> after either one of the methods was called previously will throw the System.ArgumentException. Multiple unmanaged resources need to be merged with a tool such as the Microsoft ResMerge utility (not supplied with the common language runtime).  
  
> [!NOTE]
>  Starting with the [!INCLUDE[net_v20sp1_long](~/add/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag. (See [Security Issues in Reflection Emit](../Topic/Security%20Issues%20in%20Reflection%20Emit.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/add/includes/net-v35-long-md.md)] or later.  
  
   
  
## Examples  
 The example below demonstrates a call to `DefineUnmanagedResource`, passing an external resource file.  
  
 [!code-cs[AssemblyBuilder_DefineUnmanagedResource#3](~/add/codesnippet/csharp/m-system.reflection.emit_37_1.cs)]
 [!code-cpp[AssemblyBuilder_DefineUnmanagedResource#3](~/add/codesnippet/cpp/m-system.reflection.emit_37_1.cpp)]
 [!code-vb[AssemblyBuilder_DefineUnmanagedResource#3](~/add/codesnippet/visualbasic/m-system.reflection.emit_37_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">An unmanaged resource was previously defined.  
  
 -or-  
  
 The file <paramref name="resourceFileName" /> is not readable.  
  
 -or-  
  
 <paramref name="resourceFileName" /> is the empty string ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceFileName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="resourceFileName" /> is not found.  
  
 -or-  
  
 <paramref name="resourceFileName" /> is a directory.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">The FileIOPermissionAccess.Read permission is needed to access the resource file <paramref name="resourceFileName" />.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="DefineVersionInfoResource">
      <MemberSignature Language="C#" Value="public void DefineVersionInfoResource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineVersionInfoResource() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Defines an unmanaged version information resource using the information specified in the assembly's AssemblyName object and the assembly's custom attributes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 An assembly can be associated with only one unmanaged resource. This means that calling <xref:System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource%2A> or <xref:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource%2A> after either one of the methods was called previously will throw the System.ArgumentException. Multiple unmanaged resources need to be merged with a tool such as the Microsoft ResMerge utility (not supplied with the common language runtime SDK).  
  
 Empty argument strings get written as a single space. Spaces are substituted for null characters in the argument strings.  
  
 The information is inferred from the `AssemblyName` object used to define this dynamic assembly. This assembly's custom attributes override information specified in the `AssemblyName` object.  
  
> [!NOTE]
>  Starting with the [!INCLUDE[net_v20sp1_long](~/add/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag. (See [Security Issues in Reflection Emit](../Topic/Security%20Issues%20in%20Reflection%20Emit.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/add/includes/net-v35-long-md.md)] or later.  
  
   
  
## Examples  
 The example below illustrates the usage of `DefineVersionInfoResource`.  
  
 [!code-cs[AssemblyBuilder_DefineVersionInfoResource#1](~/add/codesnippet/csharp/m-system.reflection.emit_17_1.cs)]
 [!code-cpp[AssemblyBuilder_DefineVersionInfoResource#1](~/add/codesnippet/cpp/m-system.reflection.emit_17_1.cpp)]
 [!code-vb[AssemblyBuilder_DefineVersionInfoResource#1](~/add/codesnippet/visualbasic/m-system.reflection.emit_17_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">An unmanaged version information resource was previously defined.  
  
 -or-  
  
 The unmanaged version information is too large to persist.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="DefineVersionInfoResource">
      <MemberSignature Language="C#" Value="public void DefineVersionInfoResource (string product, string productVersion, string company, string copyright, string trademark);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineVersionInfoResource(string product, string productVersion, string company, string copyright, string trademark) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="product" Type="System.String" />
        <Parameter Name="productVersion" Type="System.String" />
        <Parameter Name="company" Type="System.String" />
        <Parameter Name="copyright" Type="System.String" />
        <Parameter Name="trademark" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="product">The name of the product with which this assembly is distributed.</param>
        <param name="productVersion">The version of the product with which this assembly is distributed.</param>
        <param name="company">The name of the company that produced this assembly.</param>
        <param name="copyright">Describes all copyright notices, trademarks, and registered trademarks that apply to this assembly. This should include the full text of all notices, legal symbols, copyright dates, trademark numbers, and so on. In English, this string should be in the format "Copyright Microsoft Corp. 1990-2001".</param>
        <param name="trademark">Describes all trademarks and registered trademarks that apply to this assembly. This should include the full text of all notices, legal symbols, trademark numbers, and so on. In English, this string should be in the format "Windows is a trademark of Microsoft Corporation".</param>
        <summary>Defines an unmanaged version information resource for this assembly with the given specifications.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 An assembly can be associated with only one unmanaged resource. This means that calling DefineVersionInfoResource or <xref:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource%2A> after either one of the methods was called previously will throw the System.ArgumentException. Multiple unmanaged resources need to be merged with a tool such as the Microsoft `ResMerge` utility (not supplied with the common language runtime SDK).  
  
 Empty argument strings get written as a single space. Spaces are substituted for null characters in the argument strings.  
  
 The structure of the version resource includes data that identifies the version, language, and distribution of the file. Installation programs use the functions in the file installation library (VER.DLL) to retrieve the version information resource from a file and to extract the version information blocks from the resource.  
  
> [!NOTE]
>  Starting with the [!INCLUDE[net_v20sp1_long](~/add/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag. (See [Security Issues in Reflection Emit](../Topic/Security%20Issues%20in%20Reflection%20Emit.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/add/includes/net-v35-long-md.md)] or later.  
  
   
  
## Examples  
 The example below illustrates the usage of `DefineVersionInfoResource`.  
  
 [!code-cs[AssemblyBuilder_DefineVersionInfoResource#1](~/add/codesnippet/csharp/01ed1215-3c06-4062-ab4e-_1.cs)]
 [!code-cpp[AssemblyBuilder_DefineVersionInfoResource#1](~/add/codesnippet/cpp/01ed1215-3c06-4062-ab4e-_1.cpp)]
 [!code-vb[AssemblyBuilder_DefineVersionInfoResource#1](~/add/codesnippet/visualbasic/01ed1215-3c06-4062-ab4e-_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">An unmanaged version information resource was previously defined.  
  
 -or-  
  
 The unmanaged version information is too large to persist.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo EntryPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo EntryPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the entry point of this assembly.</summary>
        <value>The entry point of this assembly.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">An object to compare with this instance, or <see langword="null" />.</param>
        <summary>Returns a value that indicates whether this instance is equal to the specified object.</summary>
        <returns>
          <see langword="true" /> if <paramref name="obj" /> equals the type and value of this instance; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public override System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the evidence for this assembly.</summary>
        <value>The evidence for this assembly.</value>
        <remarks>To be added.</remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public override string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the display name of the current dynamic assembly.</summary>
        <value>The display name of the dynamic assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 See <xref:System.Reflection.AssemblyName> for a description of the format of the display name of an assembly.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">This argument is ignored for objects of this type.</param>
        <summary>Returns all the custom attributes that have been applied to the current <see cref="T:System.Reflection.Emit.AssemblyBuilder" />.</summary>
        <returns>An array that contains the custom attributes; the array is empty if there are no attributes.</returns>
        <remarks>To be added.</remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">The base type from which attributes derive.</param>
        <param name="inherit">This argument is ignored for objects of this type.</param>
        <summary>Returns all the custom attributes that have been applied to the current <see cref="T:System.Reflection.Emit.AssemblyBuilder" />, and that derive from a specified attribute type.</summary>
        <returns>An array that contains the custom attributes that are derived at any level from <paramref name="attributeType" />; the array is empty if there are no such attributes.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" /> is not a <see cref="T:System.Type" /> object supplied by the runtime. For example, <paramref name="attributeType" /> is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> object.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns <see cref="T:System.Reflection.CustomAttributeData" /> objects that contain information about the attributes that have been applied to the current <see cref="T:System.Reflection.Emit.AssemblyBuilder" />.</summary>
        <returns>A generic list of <see cref="T:System.Reflection.CustomAttributeData" /> objects representing data about the attributes that have been applied to the current module.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use this method to examine the custom attributes of code in the reflection-only context, in cases where the custom attributes themselves are defined in code that is loaded into the reflection-only context. Methods such as <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=fullName> and <xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=fullName> cannot be used in such cases, because they create instances of the attributes. Code in the reflection-only context cannot be executed. For more information and for example code, see the <xref:System.Reflection.CustomAttributeData> class.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetDynamicModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ModuleBuilder GetDynamicModule (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ModuleBuilder GetDynamicModule(string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ModuleBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the requested dynamic module.</param>
        <summary>Returns the dynamic module with the specified name.</summary>
        <returns>A ModuleBuilder object representing the requested dynamic module.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The length of <paramref name="name" /> is zero.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetExportedTypes">
      <MemberSignature Language="C#" Value="public override Type[] GetExportedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetExportedTypes() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the exported types defined in this assembly.</summary>
        <returns>An array of <see cref="T:System.Type" /> containing the exported types defined in this assembly.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">This method is not implemented.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetFile">
      <MemberSignature Language="C#" Value="public override System.IO.FileStream GetFile (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.FileStream GetFile(string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the specified file.</param>
        <summary>Gets a <see cref="T:System.IO.FileStream" /> for the specified file in the file table of the manifest of this assembly.</summary>
        <returns>A <see cref="T:System.IO.FileStream" /> for the specified file, or <see langword="null" />, if the file is not found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `name` should not include the path to the file.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">This method is not currently supported.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public override System.IO.FileStream[] GetFiles (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.FileStream[] GetFiles(bool getResourceModules) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">
          <see langword="true" /> to include resource modules; otherwise, <see langword="false" />.</param>
        <summary>Gets the files in the file table of an assembly manifest, specifying whether to include resource modules.</summary>
        <returns>An array of <see cref="T:System.IO.FileStream" /> objects.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">This method is not currently supported.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the hash code for this instance.</summary>
        <returns>A 32-bit signed integer hash code.</returns>
        <remarks>To be added.</remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module[] GetLoadedModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.Module[] GetLoadedModules(bool getResourceModules) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">
          <see langword="true" /> to include resource modules; otherwise, <see langword="false" />.</param>
        <summary>Returns all the loaded modules that are part of this assembly, and optionally includes resource modules.</summary>
        <returns>The loaded modules that are part of this assembly.</returns>
        <remarks>To be added.</remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceInfo">
      <MemberSignature Language="C#" Value="public override System.Reflection.ManifestResourceInfo GetManifestResourceInfo (string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ManifestResourceInfo GetManifestResourceInfo(string resourceName) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ManifestResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceName">The name of the resource.</param>
        <summary>Returns information about how the given resource has been persisted.</summary>
        <returns>
          <see cref="T:System.Reflection.ManifestResourceInfo" /> populated with information about the resource's topology, or <see langword="null" /> if the resource is not found.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">This method is not currently supported.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceNames">
      <MemberSignature Language="C#" Value="public override string[] GetManifestResourceNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string[] GetManifestResourceNames() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Loads the specified manifest resource from this assembly.</summary>
        <returns>An array of type <see langword="String" /> containing the names of all the resources.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">This method is not supported on a dynamic assembly. To get the manifest resource names, use <see cref="System.Reflection.Assembly.GetManifestResourceNames%2A" />.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream GetManifestResourceStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream GetManifestResourceStream(string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the manifest resource being requested.</param>
        <summary>Loads the specified manifest resource from this assembly.</summary>
        <returns>A <see cref="T:System.IO.Stream" /> representing this manifest resource.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">This method is not currently supported.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream GetManifestResourceStream (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream GetManifestResourceStream(class System.Type type, string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">The type whose namespace is used to scope the manifest resource name.</param>
        <param name="name">The name of the manifest resource being requested.</param>
        <summary>Loads the specified manifest resource, scoped by the namespace of the specified type, from this assembly.</summary>
        <returns>A <see cref="T:System.IO.Stream" /> representing this manifest resource.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The returned <xref:System.IO.Stream> has its file pointer set to the beginning of the resource.  
  
   
  
## Examples  
 If the full name of `type` is "MyNameSpace.MyClasses" and `name` is "Dot", `GetManifestResourceStream` will search for a resource named MyNameSpace.Dot.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">This method is not currently supported.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module GetModule (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.Module GetModule(string name) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the requested module.</param>
        <summary>Gets the specified module in this assembly.</summary>
        <returns>The module being requested, or <see langword="null" /> if the module is not found.</returns>
        <remarks>To be added.</remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module[] GetModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.Module[] GetModules(bool getResourceModules) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">
          <see langword="true" /> to include resource modules; otherwise, <see langword="false" />.</param>
        <summary>Gets all the modules that are part of this assembly, and optionally includes resource modules.</summary>
        <returns>The modules that are part of this assembly.</returns>
        <remarks>To be added.</remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public override System.Reflection.AssemblyName GetName (bool copiedName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.AssemblyName GetName(bool copiedName) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="copiedName" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="copiedName">
          <see langword="true" /> to set the code base to the location of the assembly after it is shadow-copied; <see langword="false" /> to set the code base to the original location.</param>
        <summary>Gets the <see cref="T:System.Reflection.AssemblyName" /> that was specified when the current dynamic assembly was created, and sets the code base as specified.</summary>
        <returns>The name of the dynamic assembly.</returns>
        <remarks>To be added.</remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetReferencedAssemblies">
      <MemberSignature Language="C#" Value="public override System.Reflection.AssemblyName[] GetReferencedAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.AssemblyName[] GetReferencedAssemblies() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets an incomplete list of <see cref="T:System.Reflection.AssemblyName" /> objects for the assemblies that are referenced by this <see cref="T:System.Reflection.Emit.AssemblyBuilder" />.</summary>
        <returns>An array of assembly names for the referenced assemblies. This array is not a complete list.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method does not return a complete list of referenced assemblies. For example, if you apply a custom attribute to the <xref:System.Reflection.Emit.AssemblyBuilder>, the assembly in which the attribute was defined is included in the list returned by this method. However, if you use a <xref:System.Type> object to specify the type of a method parameter, that type is not included.  
  
 To get a complete list of referenced assemblies, save the assembly, load it into another application domain, and call the <xref:System.Reflection.Assembly.GetReferencedAssemblies%2A?displayProperty=fullName> method.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public override System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">The specified culture.</param>
        <summary>Gets the satellite assembly for the specified culture.</summary>
        <returns>The specified satellite assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Satellite assemblies contain localized resources, as distinct from main application assemblies, which contain non-localizable executable code and resources for a single culture that serve as the default or neutral culture.  
  
 Call this method to use your current assembly version.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The assembly cannot be found.</exception>
        <exception cref="T:System.IO.FileLoadException">The satellite assembly with a matching file name was found, but the <see langword="CultureInfo" /> did not match the one specified.</exception>
        <exception cref="T:System.BadImageFormatException">The satellite assembly is not a valid assembly.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public override System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture, Version version);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture, class System.Version version) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="version" Type="System.Version" />
      </Parameters>
      <Docs>
        <param name="culture">The specified culture.</param>
        <param name="version">The version of the satellite assembly.</param>
        <summary>Gets the specified version of the satellite assembly for the specified culture.</summary>
        <returns>The specified satellite assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Satellite assemblies contain localized resources, as distinct from main application assemblies, which contain non-localizable executable code and resources for a single culture that serve as the default or neutral culture.  
  
 Call the <xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29> overload to use your current assembly version.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> is <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileLoadException">The satellite assembly with a matching file name was found, but the <see langword="CultureInfo" /> or the version did not match the one specified.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The assembly cannot be found.</exception>
        <exception cref="T:System.BadImageFormatException">The satellite assembly is not a valid assembly.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public override Type GetType (string name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetType(string name, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">The name of the type to search for.</param>
        <param name="throwOnError">
          <see langword="true" /> to throw an exception if the type is not found; otherwise, <see langword="false" />.</param>
        <param name="ignoreCase">
          <see langword="true" /> to ignore the case of the type name when searching; otherwise, <see langword="false" />.</param>
        <summary>Gets the specified type from the types that have been defined and created in the current <see cref="T:System.Reflection.Emit.AssemblyBuilder" />.</summary>
        <returns>The specified type, or <see langword="null" /> if the type is not found or has not been created yet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A type cannot be found until it has been created by calling the <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> method.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="GlobalAssemblyCache">
      <MemberSignature Language="C#" Value="public override bool GlobalAssemblyCache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool GlobalAssemblyCache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the assembly was loaded from the global assembly cache.</summary>
        <value>Always <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.AssemblyBuilder> objects always represent dynamic assemblies, and therefore are never loaded from the global assembly cache.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="HostContext">
      <MemberSignature Language="C#" Value="public override long HostContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 HostContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the host context where the dynamic assembly is being created.</summary>
        <value>A value that indicates the host context where the dynamic assembly is being created.</value>
        <remarks>To be added.</remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="ImageRuntimeVersion">
      <MemberSignature Language="C#" Value="public override string ImageRuntimeVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ImageRuntimeVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the version of the common language runtime that will be saved in the file containing the manifest.</summary>
        <value>A string representing the common language runtime version.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">The type of attribute to test for.</param>
        <param name="inherit">This argument is ignored for objects of this type.</param>
        <summary>Returns a value that indicates whether one or more instances of the specified attribute type is applied to this member.</summary>
        <returns>
          <see langword="true" /> if one or more instances of <paramref name="attributeType" /> is applied to this dynamic assembly; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="IsDynamic">
      <MemberSignature Language="C#" Value="public override bool IsDynamic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDynamic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates that the current assembly is a dynamic assembly.</summary>
        <value>Always <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 An <xref:System.Reflection.Emit.AssemblyBuilder> object always represents a dynamic assembly.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public override string Location { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Location" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the location, in codebase format, of the loaded file that contains the manifest if it is not shadow-copied.</summary>
        <value>The location of the loaded file that contains the manifest. If the loaded file has been shadow-copied, the <see langword="Location" /> is that of the file before being shadow-copied.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">This method is not currently supported.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="ManifestModule">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module ManifestModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module ManifestModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the module in the current <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> that contains the assembly manifest.</summary>
        <value>The manifest module.</value>
        <remarks>To be added.</remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public override System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the grant set of the current dynamic assembly.</summary>
        <value>The grant set of the current dynamic assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.PermissionSet> objects can contain sensitive information such as paths. Therefore, full trust is required to access these objects.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requires full trust for the immediate caller. This member cannot be used by partially trusted or transparent code.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnly">
      <MemberSignature Language="C#" Value="public override bool ReflectionOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReflectionOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the dynamic assembly is in the reflection-only context.</summary>
        <value>
          <see langword="true" /> if the dynamic assembly is in the reflection-only context; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To emit a dynamic assembly in the reflection-only context, specify <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=fullName> when you create the <xref:System.Reflection.Emit.AssemblyBuilder>. If a dynamic assembly is emitted in the reflection-only context, its code cannot be executed.  
  
> [!NOTE]
>  After you have saved a dynamic assembly to disk, you can use the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=fullName> method to load the completed assembly into the reflection-only context. However, the assembly can no longer be modified.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string assemblyFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string assemblyFileName) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFileName">The file name of the assembly.</param>
        <summary>Saves this dynamic assembly to disk.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method saves all non-transient dynamic modules defined in this dynamic assembly. Transient dynamic modules are not saved. The assembly file name can be the same as the name of one of the modules. If so, the assembly manifest is stored within that module. `assemblyFileName` can be different from the names of all of the modules contained within the assembly. If so, the assembly file contains only the assembly manifest.  
  
 For each <xref:System.Resources.ResourceWriter> obtained using <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, this method writes the .resources file and calls <xref:System.Resources.ResourceWriter.Close%2A> to close the stream.  
  
 The `assemblyFileName` needs to be a simple file name without a drive or directory component. To create an assembly in a specific directory, use one of the <xref:System.AppDomain.DefineDynamicAssembly%2A> methods that takes a target directory argument.  
  
 In the .NET Framework version 2.0, this overload of the <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A> method is equivalent to calling the <xref:System.Reflection.Emit.AssemblyBuilder.Save%28System.String%2CSystem.Reflection.PortableExecutableKinds%2CSystem.Reflection.ImageFileMachine%29> method overload with <xref:System.Reflection.PortableExecutableKinds> for the `portableExecutableKind` parameter and <xref:System.Reflection.ImageFileMachine> for the `imageFileMachine` parameter.  
  
   
  
## Examples  
 The following code sample creates a dynamic assembly and then persists it to a local disk using `Save`.  
  
 [!code-cs[System.Reflection.Emit.AssemblyBuilder.Save Example#1](~/add/codesnippet/csharp/m-system.reflection.emit_16_1.cs)]
 [!code-cpp[System.Reflection.Emit.AssemblyBuilder.Save Example#1](~/add/codesnippet/cpp/m-system.reflection.emit_16_1.cpp)]
 [!code-vb[System.Reflection.Emit.AssemblyBuilder.Save Example#1](~/add/codesnippet/visualbasic/m-system.reflection.emit_16_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The length of <paramref name="assemblyFileName" /> is 0.  
  
 -or-  
  
 There are two or more modules resource files in the assembly with the same name.  
  
 -or-  
  
 The target directory of the assembly is invalid.  
  
 -or-  
  
 <paramref name="assemblyFileName" /> is not a simple file name (for example, has a directory or drive component), or more than one unmanaged resource, including a version information resource, was defined in this assembly.  
  
 -or-  
  
 The <see langword="CultureInfo" /> string in <see cref="T:System.Reflection.AssemblyCultureAttribute" /> is not a valid string and <see cref="System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource%2A" /> was called prior to calling this method.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFileName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">This assembly has been saved before.  
  
 -or-  
  
 This assembly has access <see langword="Run" /><see cref="T:System.Reflection.Emit.AssemblyBuilderAccess" /></exception>
        <exception cref="T:System.IO.IOException">An output error occurs during the save.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="System.Reflection.Emit.TypeBuilder.CreateType%2A" /> has not been called for any of the types in the modules of the assembly to be written to disk.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Write = true or Append = true is needed to save this assembly to the specified file name.</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string assemblyFileName, System.Reflection.PortableExecutableKinds portableExecutableKind, System.Reflection.ImageFileMachine imageFileMachine);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string assemblyFileName, valuetype System.Reflection.PortableExecutableKinds portableExecutableKind, valuetype System.Reflection.ImageFileMachine imageFileMachine) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFileName" Type="System.String" />
        <Parameter Name="portableExecutableKind" Type="System.Reflection.PortableExecutableKinds" />
        <Parameter Name="imageFileMachine" Type="System.Reflection.ImageFileMachine" />
      </Parameters>
      <Docs>
        <param name="assemblyFileName">The file name of the assembly.</param>
        <param name="portableExecutableKind">A bitwise combination of the <see cref="T:System.Reflection.PortableExecutableKinds" /> values that specifies the nature of the code.</param>
        <param name="imageFileMachine">One of the <see cref="T:System.Reflection.ImageFileMachine" /> values that specifies the target platform.</param>
        <summary>Saves this dynamic assembly to disk, specifying the nature of code in the assembly's executables and the target platform.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If `imageFileMachine` and `portableExecutableKind` are incompatible, `imageFileMachine` takes precedence over `portableExecutableKind`. No exception is thrown. For example, if you specify <xref:System.Reflection.ImageFileMachine?displayProperty=fullName> with <xref:System.Reflection.PortableExecutableKinds?displayProperty=fullName>, <xref:System.Reflection.PortableExecutableKinds?displayProperty=fullName> is ignored.  
  
 This method saves all non-transient dynamic modules defined in this dynamic assembly. Transient dynamic modules are not saved. The assembly file name can be the same as the name of one of the module. If so, the assembly manifest is stored within that module. `assemblyFileName` can be different from the names of all of the modules contained within the assembly. If so, the assembly file contains only the assembly manifest.  
  
 For each <xref:System.Resources.ResourceWriter> obtained using <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, this method writes the .resources file and calls <xref:System.Resources.ResourceWriter.Close%2A> to close the stream.  
  
 The `assemblyFileName` needs to be a simple file name without a drive or directory component. To create an assembly in a specific directory, use one of the <xref:System.AppDomain.DefineDynamicAssembly%2A> methods that takes a target directory argument.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The length of <paramref name="assemblyFileName" /> is 0.  
  
 -or-  
  
 There are two or more modules resource files in the assembly with the same name.  
  
 -or-  
  
 The target directory of the assembly is invalid.  
  
 -or-  
  
 <paramref name="assemblyFileName" /> is not a simple file name (for example, has a directory or drive component), or more than one unmanaged resource, including a version information resources, was defined in this assembly.  
  
 -or-  
  
 The <see langword="CultureInfo" /> string in <see cref="T:System.Reflection.AssemblyCultureAttribute" /> is not a valid string and <see cref="System.Reflection.Emit.AssemblyBuilder.DefineVersionInfoResource%2A" /> was called prior to calling this method.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFileName" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">This assembly has been saved before.  
  
 -or-  
  
 This assembly has access <see langword="Run" /><see cref="T:System.Reflection.Emit.AssemblyBuilderAccess" /></exception>
        <exception cref="T:System.IO.IOException">An output error occurs during the save.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="System.Reflection.Emit.TypeBuilder.CreateType%2A" /> has not been called for any of the types in the modules of the assembly to be written to disk.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Write = true or Append = true is needed to save this assembly to the specified file name.</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="SecurityRuleSet">
      <MemberSignature Language="C#" Value="public override System.Security.SecurityRuleSet SecurityRuleSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.SecurityRuleSet SecurityRuleSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityRuleSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates which set of security rules the common language runtime (CLR) enforces for this assembly.</summary>
        <value>The security rule set that the CLR enforces for this dynamic assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The [!INCLUDE[net_v40_long](~/add/includes/net-v40-long-md.md)] always enforces level 2 transparency (<xref:System.Security.SecurityRuleSet?displayProperty=fullName>) for the dynamic assemblies it generates.  
  
 ]]></format>
        </remarks>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.Emit.CustomAttributeBuilder customBuilder) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customBuilder" Type="System.Reflection.Emit.CustomAttributeBuilder" />
      </Parameters>
      <Docs>
        <param name="customBuilder">An instance of a helper class to define the custom attribute.</param>
        <summary>Set a custom attribute on this assembly using a custom attribute builder.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <xref:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute%2A> cannot be used to set declarative security attributes. Use one of the overloads of <xref:System.AppDomain.DefineDynamicAssembly%2A> that takes required, optional, and refused permissions.  
  
> [!NOTE]
>  Starting with the [!INCLUDE[net_v20sp1_long](~/add/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag. (See [Security Issues in Reflection Emit](../Topic/Security%20Issues%20in%20Reflection%20Emit.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/add/includes/net-v35-long-md.md)] or later.  
  
   
  
## Examples  
 The following code sample illustrates the use of `SetCustomAttribute` within <xref:System.Reflection.Emit.AssemblyBuilder>, using a <xref:System.Reflection.Emit.CustomAttributeBuilder>.  
  
 [!code-cs[AssemblyBuilder_SetCustomAttribute1#1](~/add/codesnippet/csharp/66abc141-85f2-4323-8875-_1.cs)]
 [!code-cpp[AssemblyBuilder_SetCustomAttribute1#1](~/add/codesnippet/cpp/66abc141-85f2-4323-8875-_1.cpp)]
 [!code-vb[AssemblyBuilder_SetCustomAttribute1#1](~/add/codesnippet/visualbasic/66abc141-85f2-4323-8875-_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="con" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.ConstructorInfo con, unsigned int8[] binaryAttribute) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="binaryAttribute" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="con">The constructor for the custom attribute.</param>
        <param name="binaryAttribute">A byte blob representing the attributes.</param>
        <summary>Set a custom attribute on this assembly using a specified custom attribute blob.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 See the metadata specification in the ECMA Partition II documentation for details on how to format `binaryAttribute`. The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.  
  
 `RuntimeConstructorInfo` is a special type generated by the system. It derives from the <xref:System.Reflection.ConstructorInfo> class, and any <xref:System.Reflection.ConstructorInfo> object you obtain through reflection is actually an instance of `RuntimeConstructorInfo`.  
  
> [!NOTE]
>  SetCustomAttribute cannot be used to set declarative security attributes. Use one of the overloads of <xref:System.AppDomain.DefineDynamicAssembly%2A> that takes required, optional, and refused permissions.  
  
> [!NOTE]
>  Starting with the [!INCLUDE[net_v20sp1_long](~/add/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag. (See [Security Issues in Reflection Emit](../Topic/Security%20Issues%20in%20Reflection%20Emit.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/add/includes/net-v35-long-md.md)] or later.  
  
   
  
## Examples  
 The following code sample illustrates the use of `SetCustomAttribute` to attach a custom attribute to a dynamically generated assembly.  
  
 [!code-cs[AssemblyBuilder_SetCustomAttribute2#1](~/add/codesnippet/csharp/4a993094-ead2-4e71-8091-_1.cs)]
 [!code-cpp[AssemblyBuilder_SetCustomAttribute2#1](~/add/codesnippet/cpp/4a993094-ead2-4e71-8091-_1.cpp)]
 [!code-vb[AssemblyBuilder_SetCustomAttribute2#1](~/add/codesnippet/visualbasic/4a993094-ead2-4e71-8091-_1.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="con" /> or <paramref name="binaryAttribute" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="con" /> is not a <see langword="RuntimeConstructorInfo" /> object.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="SetEntryPoint">
      <MemberSignature Language="C#" Value="public void SetEntryPoint (System.Reflection.MethodInfo entryMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetEntryPoint(class System.Reflection.MethodInfo entryMethod) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entryMethod" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="entryMethod">A reference to the method that represents the entry point for this dynamic assembly.</param>
        <summary>Sets the entry point for this dynamic assembly, assuming that a console application is being built.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entryMethod" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="entryMethod" /> is not contained within this assembly.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="SetEntryPoint">
      <MemberSignature Language="C#" Value="public void SetEntryPoint (System.Reflection.MethodInfo entryMethod, System.Reflection.Emit.PEFileKinds fileKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetEntryPoint(class System.Reflection.MethodInfo entryMethod, valuetype System.Reflection.Emit.PEFileKinds fileKind) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entryMethod" Type="System.Reflection.MethodInfo" />
        <Parameter Name="fileKind" Type="System.Reflection.Emit.PEFileKinds" />
      </Parameters>
      <Docs>
        <param name="entryMethod">A reference to the method that represents the entry point for this dynamic assembly.</param>
        <param name="fileKind">The type of the assembly executable being built.</param>
        <summary>Sets the entry point for this assembly and defines the type of the portable executable (PE file) being built.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Starting with the [!INCLUDE[net_v20sp1_long](~/add/includes/net-v20sp1-long-md.md)], this member no longer requires <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag. (See [Security Issues in Reflection Emit](../Topic/Security%20Issues%20in%20Reflection%20Emit.md).) To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/add/includes/net-v35-long-md.md)] or later.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entryMethod" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="entryMethod" /> is not contained within this assembly.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember%2A" />. Associated enumeration: <see cref="T:System.Security.Permissions.ReflectionPermissionFlag" />.</permission>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._AssemblyBuilder.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _AssemblyBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._AssemblyBuilder.GetIDsOfNames(valuetype System.Guid riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Reserved for future use. Must be IID_NULL.</param>
        <param name="rgszNames">Passed-in array of names to be mapped.</param>
        <param name="cNames">Count of the names to be mapped.</param>
        <param name="lcid">The locale context in which to interpret the names.</param>
        <param name="rgDispId">Caller-allocated array which receives the IDs corresponding to the names.</param>
        <summary>Maps a set of names to a corresponding set of dispatch identifiers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">The method is called late-bound using the COM `IDispatch` interface.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._AssemblyBuilder.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _AssemblyBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._AssemblyBuilder.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">The type information to return.</param>
        <param name="lcid">The locale identifier for the type information.</param>
        <param name="ppTInfo">Receives a pointer to the requested type information object.</param>
        <summary>Retrieves the type information for an object, which can then be used to get the type information for an interface.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">The method is called late-bound using the COM `IDispatch` interface.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._AssemblyBuilder.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _AssemblyBuilder.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._AssemblyBuilder.GetTypeInfoCount(unsigned int32 pcTInfo) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Points to a location that receives the number of type information interfaces provided by the object.</param>
        <summary>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">The method is called late-bound using the COM `IDispatch` interface.</exception>
        <threadsafe />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._AssemblyBuilder.Invoke">
      <MemberSignature Language="C#" Value="void _AssemblyBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._AssemblyBuilder.Invoke(unsigned int32 dispIdMember, valuetype System.Guid riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identifies the member.</param>
        <param name="riid">Reserved for future use. Must be IID_NULL.</param>
        <param name="lcid">The locale context in which to interpret arguments.</param>
        <param name="wFlags">Flags describing the context of the call.</param>
        <param name="pDispParams">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</param>
        <param name="pVarResult">Pointer to the location where the result is to be stored.</param>
        <param name="pExcepInfo">Pointer to a structure that contains exception information.</param>
        <param name="puArgErr">The index of the first argument that has an error.</param>
        <summary>Provides access to properties and methods exposed by an object.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about `IDispatch::Invoke`, see the MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">The method is called late-bound using the COM `IDispatch` interface.</exception>
        <threadsafe />
      </Docs>
    </Member>
  </Members>
</Type>